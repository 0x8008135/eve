// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: network.proto

package deprecatedzconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ACEMatch struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ACEMatch) Reset()                    { *m = ACEMatch{} }
func (m *ACEMatch) String() string            { return proto.CompactTextString(m) }
func (*ACEMatch) ProtoMessage()               {}
func (*ACEMatch) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{0} }

func (m *ACEMatch) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ACEMatch) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ACEAction struct {
	Drop                bool   `protobuf:"varint,1,opt,name=drop,proto3" json:"drop,omitempty"`
	Limit               bool   `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Limitrate           uint32 `protobuf:"varint,3,opt,name=limitrate,proto3" json:"limitrate,omitempty"`
	Limitunit           string `protobuf:"bytes,4,opt,name=limitunit,proto3" json:"limitunit,omitempty"`
	Limitburst          uint32 `protobuf:"varint,5,opt,name=limitburst,proto3" json:"limitburst,omitempty"`
	Allocate            bool   `protobuf:"varint,6,opt,name=allocate,proto3" json:"allocate,omitempty"`
	Exportprivate       bool   `protobuf:"varint,7,opt,name=exportprivate,proto3" json:"exportprivate,omitempty"`
	Allocationprefix    []byte `protobuf:"bytes,8,opt,name=allocationprefix,proto3" json:"allocationprefix,omitempty"`
	Allocationprefixlen uint32 `protobuf:"varint,9,opt,name=allocationprefixlen,proto3" json:"allocationprefixlen,omitempty"`
}

func (m *ACEAction) Reset()                    { *m = ACEAction{} }
func (m *ACEAction) String() string            { return proto.CompactTextString(m) }
func (*ACEAction) ProtoMessage()               {}
func (*ACEAction) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{1} }

func (m *ACEAction) GetDrop() bool {
	if m != nil {
		return m.Drop
	}
	return false
}

func (m *ACEAction) GetLimit() bool {
	if m != nil {
		return m.Limit
	}
	return false
}

func (m *ACEAction) GetLimitrate() uint32 {
	if m != nil {
		return m.Limitrate
	}
	return 0
}

func (m *ACEAction) GetLimitunit() string {
	if m != nil {
		return m.Limitunit
	}
	return ""
}

func (m *ACEAction) GetLimitburst() uint32 {
	if m != nil {
		return m.Limitburst
	}
	return 0
}

func (m *ACEAction) GetAllocate() bool {
	if m != nil {
		return m.Allocate
	}
	return false
}

func (m *ACEAction) GetExportprivate() bool {
	if m != nil {
		return m.Exportprivate
	}
	return false
}

func (m *ACEAction) GetAllocationprefix() []byte {
	if m != nil {
		return m.Allocationprefix
	}
	return nil
}

func (m *ACEAction) GetAllocationprefixlen() uint32 {
	if m != nil {
		return m.Allocationprefixlen
	}
	return 0
}

type ACE struct {
	Matches []*ACEMatch  `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
	Actions []*ACEAction `protobuf:"bytes,2,rep,name=actions" json:"actions,omitempty"`
}

func (m *ACE) Reset()                    { *m = ACE{} }
func (m *ACE) String() string            { return proto.CompactTextString(m) }
func (*ACE) ProtoMessage()               {}
func (*ACE) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{2} }

func (m *ACE) GetMatches() []*ACEMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

func (m *ACE) GetActions() []*ACEAction {
	if m != nil {
		return m.Actions
	}
	return nil
}

type NameToEid struct {
	Hostname string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Eids     []string `protobuf:"bytes,2,rep,name=eids" json:"eids,omitempty"`
}

func (m *NameToEid) Reset()                    { *m = NameToEid{} }
func (m *NameToEid) String() string            { return proto.CompactTextString(m) }
func (*NameToEid) ProtoMessage()               {}
func (*NameToEid) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{3} }

func (m *NameToEid) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *NameToEid) GetEids() []string {
	if m != nil {
		return m.Eids
	}
	return nil
}

type AdditionInfoDevice struct {
	Underlayip string `protobuf:"bytes,1,opt,name=underlayip,proto3" json:"underlayip,omitempty"`
	Hostname   string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	City       string `protobuf:"bytes,3,opt,name=city,proto3" json:"city,omitempty"`
	Region     string `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
	Country    string `protobuf:"bytes,5,opt,name=country,proto3" json:"country,omitempty"`
	Loc        string `protobuf:"bytes,6,opt,name=loc,proto3" json:"loc,omitempty"`
	Org        string `protobuf:"bytes,7,opt,name=org,proto3" json:"org,omitempty"`
}

func (m *AdditionInfoDevice) Reset()                    { *m = AdditionInfoDevice{} }
func (m *AdditionInfoDevice) String() string            { return proto.CompactTextString(m) }
func (*AdditionInfoDevice) ProtoMessage()               {}
func (*AdditionInfoDevice) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{4} }

func (m *AdditionInfoDevice) GetUnderlayip() string {
	if m != nil {
		return m.Underlayip
	}
	return ""
}

func (m *AdditionInfoDevice) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AdditionInfoDevice) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *AdditionInfoDevice) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *AdditionInfoDevice) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *AdditionInfoDevice) GetLoc() string {
	if m != nil {
		return m.Loc
	}
	return ""
}

func (m *AdditionInfoDevice) GetOrg() string {
	if m != nil {
		return m.Org
	}
	return ""
}

type OverlayNetwork struct {
	Iid           uint32              `protobuf:"varint,1,opt,name=iid,proto3" json:"iid,omitempty"`
	Ip            string              `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Lispsignature string              `protobuf:"bytes,3,opt,name=lispsignature,proto3" json:"lispsignature,omitempty"`
	Acls          []*ACE              `protobuf:"bytes,4,rep,name=acls" json:"acls,omitempty"`
	Nmtoeid       []*NameToEid        `protobuf:"bytes,5,rep,name=nmtoeid" json:"nmtoeid,omitempty"`
	Addinfodev    *AdditionInfoDevice `protobuf:"bytes,6,opt,name=addinfodev" json:"addinfodev,omitempty"`
}

func (m *OverlayNetwork) Reset()                    { *m = OverlayNetwork{} }
func (m *OverlayNetwork) String() string            { return proto.CompactTextString(m) }
func (*OverlayNetwork) ProtoMessage()               {}
func (*OverlayNetwork) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{5} }

func (m *OverlayNetwork) GetIid() uint32 {
	if m != nil {
		return m.Iid
	}
	return 0
}

func (m *OverlayNetwork) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *OverlayNetwork) GetLispsignature() string {
	if m != nil {
		return m.Lispsignature
	}
	return ""
}

func (m *OverlayNetwork) GetAcls() []*ACE {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *OverlayNetwork) GetNmtoeid() []*NameToEid {
	if m != nil {
		return m.Nmtoeid
	}
	return nil
}

func (m *OverlayNetwork) GetAddinfodev() *AdditionInfoDevice {
	if m != nil {
		return m.Addinfodev
	}
	return nil
}

type EIDAllocation struct {
	Allocate            bool   `protobuf:"varint,1,opt,name=allocate,proto3" json:"allocate,omitempty"`
	Exportprivate       bool   `protobuf:"varint,2,opt,name=exportprivate,proto3" json:"exportprivate,omitempty"`
	Allocationprefix    []byte `protobuf:"bytes,3,opt,name=allocationprefix,proto3" json:"allocationprefix,omitempty"`
	Allocationprefixlen uint32 `protobuf:"varint,4,opt,name=allocationprefixlen,proto3" json:"allocationprefixlen,omitempty"`
}

func (m *EIDAllocation) Reset()                    { *m = EIDAllocation{} }
func (m *EIDAllocation) String() string            { return proto.CompactTextString(m) }
func (*EIDAllocation) ProtoMessage()               {}
func (*EIDAllocation) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{6} }

func (m *EIDAllocation) GetAllocate() bool {
	if m != nil {
		return m.Allocate
	}
	return false
}

func (m *EIDAllocation) GetExportprivate() bool {
	if m != nil {
		return m.Exportprivate
	}
	return false
}

func (m *EIDAllocation) GetAllocationprefix() []byte {
	if m != nil {
		return m.Allocationprefix
	}
	return nil
}

func (m *EIDAllocation) GetAllocationprefixlen() uint32 {
	if m != nil {
		return m.Allocationprefixlen
	}
	return 0
}

type EIDConfigDetails struct {
	Iid           uint32         `protobuf:"varint,1,opt,name=iid,proto3" json:"iid,omitempty"`
	Eidalloc      *EIDAllocation `protobuf:"bytes,2,opt,name=eidalloc" json:"eidalloc,omitempty"`
	Eid           string         `protobuf:"bytes,3,opt,name=eid,proto3" json:"eid,omitempty"`
	Lispsignature string         `protobuf:"bytes,4,opt,name=lispsignature,proto3" json:"lispsignature,omitempty"`
	Pemcert       []byte         `protobuf:"bytes,5,opt,name=pemcert,proto3" json:"pemcert,omitempty"`
	Pemprivatekey []byte         `protobuf:"bytes,6,opt,name=pemprivatekey,proto3" json:"pemprivatekey,omitempty"`
}

func (m *EIDConfigDetails) Reset()                    { *m = EIDConfigDetails{} }
func (m *EIDConfigDetails) String() string            { return proto.CompactTextString(m) }
func (*EIDConfigDetails) ProtoMessage()               {}
func (*EIDConfigDetails) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{7} }

func (m *EIDConfigDetails) GetIid() uint32 {
	if m != nil {
		return m.Iid
	}
	return 0
}

func (m *EIDConfigDetails) GetEidalloc() *EIDAllocation {
	if m != nil {
		return m.Eidalloc
	}
	return nil
}

func (m *EIDConfigDetails) GetEid() string {
	if m != nil {
		return m.Eid
	}
	return ""
}

func (m *EIDConfigDetails) GetLispsignature() string {
	if m != nil {
		return m.Lispsignature
	}
	return ""
}

func (m *EIDConfigDetails) GetPemcert() []byte {
	if m != nil {
		return m.Pemcert
	}
	return nil
}

func (m *EIDConfigDetails) GetPemprivatekey() []byte {
	if m != nil {
		return m.Pemprivatekey
	}
	return nil
}

type EIDOverlayConfig struct {
	Eidcfgdetails *EIDConfigDetails `protobuf:"bytes,1,opt,name=eidcfgdetails" json:"eidcfgdetails,omitempty"`
	Acls          []*ACE            `protobuf:"bytes,2,rep,name=acls" json:"acls,omitempty"`
	Ntoeid        []*NameToEid      `protobuf:"bytes,3,rep,name=ntoeid" json:"ntoeid,omitempty"`
}

func (m *EIDOverlayConfig) Reset()                    { *m = EIDOverlayConfig{} }
func (m *EIDOverlayConfig) String() string            { return proto.CompactTextString(m) }
func (*EIDOverlayConfig) ProtoMessage()               {}
func (*EIDOverlayConfig) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{8} }

func (m *EIDOverlayConfig) GetEidcfgdetails() *EIDConfigDetails {
	if m != nil {
		return m.Eidcfgdetails
	}
	return nil
}

func (m *EIDOverlayConfig) GetAcls() []*ACE {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *EIDOverlayConfig) GetNtoeid() []*NameToEid {
	if m != nil {
		return m.Ntoeid
	}
	return nil
}

type UnderlayNetwork struct {
	Acls []*ACE `protobuf:"bytes,1,rep,name=acls" json:"acls,omitempty"`
}

func (m *UnderlayNetwork) Reset()                    { *m = UnderlayNetwork{} }
func (m *UnderlayNetwork) String() string            { return proto.CompactTextString(m) }
func (*UnderlayNetwork) ProtoMessage()               {}
func (*UnderlayNetwork) Descriptor() ([]byte, []int) { return fileDescriptorNetwork, []int{9} }

func (m *UnderlayNetwork) GetAcls() []*ACE {
	if m != nil {
		return m.Acls
	}
	return nil
}

func init() {
	proto.RegisterType((*ACEMatch)(nil), "ACEMatch")
	proto.RegisterType((*ACEAction)(nil), "ACEAction")
	proto.RegisterType((*ACE)(nil), "ACE")
	proto.RegisterType((*NameToEid)(nil), "NameToEid")
	proto.RegisterType((*AdditionInfoDevice)(nil), "AdditionInfoDevice")
	proto.RegisterType((*OverlayNetwork)(nil), "OverlayNetwork")
	proto.RegisterType((*EIDAllocation)(nil), "EIDAllocation")
	proto.RegisterType((*EIDConfigDetails)(nil), "EIDConfigDetails")
	proto.RegisterType((*EIDOverlayConfig)(nil), "EIDOverlayConfig")
	proto.RegisterType((*UnderlayNetwork)(nil), "UnderlayNetwork")
}
func (m *ACEMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACEMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *ACEAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACEAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Drop {
		dAtA[i] = 0x8
		i++
		if m.Drop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Limit {
		dAtA[i] = 0x10
		i++
		if m.Limit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Limitrate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Limitrate))
	}
	if len(m.Limitunit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Limitunit)))
		i += copy(dAtA[i:], m.Limitunit)
	}
	if m.Limitburst != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Limitburst))
	}
	if m.Allocate {
		dAtA[i] = 0x30
		i++
		if m.Allocate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Exportprivate {
		dAtA[i] = 0x38
		i++
		if m.Exportprivate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Allocationprefix) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Allocationprefix)))
		i += copy(dAtA[i:], m.Allocationprefix)
	}
	if m.Allocationprefixlen != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Allocationprefixlen))
	}
	return i, nil
}

func (m *ACE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACE) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Matches) > 0 {
		for _, msg := range m.Matches {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNetwork(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetwork(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NameToEid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameToEid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Eids) > 0 {
		for _, s := range m.Eids {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AdditionInfoDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdditionInfoDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Underlayip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Underlayip)))
		i += copy(dAtA[i:], m.Underlayip)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.Loc) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Loc)))
		i += copy(dAtA[i:], m.Loc)
	}
	if len(m.Org) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Org)))
		i += copy(dAtA[i:], m.Org)
	}
	return i, nil
}

func (m *OverlayNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OverlayNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Iid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Iid))
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Lispsignature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Lispsignature)))
		i += copy(dAtA[i:], m.Lispsignature)
	}
	if len(m.Acls) > 0 {
		for _, msg := range m.Acls {
			dAtA[i] = 0x22
			i++
			i = encodeVarintNetwork(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nmtoeid) > 0 {
		for _, msg := range m.Nmtoeid {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNetwork(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Addinfodev != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Addinfodev.Size()))
		n1, err := m.Addinfodev.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *EIDAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EIDAllocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Allocate {
		dAtA[i] = 0x8
		i++
		if m.Allocate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Exportprivate {
		dAtA[i] = 0x10
		i++
		if m.Exportprivate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Allocationprefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Allocationprefix)))
		i += copy(dAtA[i:], m.Allocationprefix)
	}
	if m.Allocationprefixlen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Allocationprefixlen))
	}
	return i, nil
}

func (m *EIDConfigDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EIDConfigDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Iid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Iid))
	}
	if m.Eidalloc != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Eidalloc.Size()))
		n2, err := m.Eidalloc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Eid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Eid)))
		i += copy(dAtA[i:], m.Eid)
	}
	if len(m.Lispsignature) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Lispsignature)))
		i += copy(dAtA[i:], m.Lispsignature)
	}
	if len(m.Pemcert) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Pemcert)))
		i += copy(dAtA[i:], m.Pemcert)
	}
	if len(m.Pemprivatekey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Pemprivatekey)))
		i += copy(dAtA[i:], m.Pemprivatekey)
	}
	return i, nil
}

func (m *EIDOverlayConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EIDOverlayConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eidcfgdetails != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNetwork(dAtA, i, uint64(m.Eidcfgdetails.Size()))
		n3, err := m.Eidcfgdetails.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Acls) > 0 {
		for _, msg := range m.Acls {
			dAtA[i] = 0x12
			i++
			i = encodeVarintNetwork(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ntoeid) > 0 {
		for _, msg := range m.Ntoeid {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintNetwork(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UnderlayNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnderlayNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Acls) > 0 {
		for _, msg := range m.Acls {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNetwork(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintNetwork(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ACEMatch) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *ACEAction) Size() (n int) {
	var l int
	_ = l
	if m.Drop {
		n += 2
	}
	if m.Limit {
		n += 2
	}
	if m.Limitrate != 0 {
		n += 1 + sovNetwork(uint64(m.Limitrate))
	}
	l = len(m.Limitunit)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Limitburst != 0 {
		n += 1 + sovNetwork(uint64(m.Limitburst))
	}
	if m.Allocate {
		n += 2
	}
	if m.Exportprivate {
		n += 2
	}
	l = len(m.Allocationprefix)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Allocationprefixlen != 0 {
		n += 1 + sovNetwork(uint64(m.Allocationprefixlen))
	}
	return n
}

func (m *ACE) Size() (n int) {
	var l int
	_ = l
	if len(m.Matches) > 0 {
		for _, e := range m.Matches {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	return n
}

func (m *NameToEid) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	if len(m.Eids) > 0 {
		for _, s := range m.Eids {
			l = len(s)
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	return n
}

func (m *AdditionInfoDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Underlayip)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Loc)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Org)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *OverlayNetwork) Size() (n int) {
	var l int
	_ = l
	if m.Iid != 0 {
		n += 1 + sovNetwork(uint64(m.Iid))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Lispsignature)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	if len(m.Acls) > 0 {
		for _, e := range m.Acls {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if len(m.Nmtoeid) > 0 {
		for _, e := range m.Nmtoeid {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if m.Addinfodev != nil {
		l = m.Addinfodev.Size()
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *EIDAllocation) Size() (n int) {
	var l int
	_ = l
	if m.Allocate {
		n += 2
	}
	if m.Exportprivate {
		n += 2
	}
	l = len(m.Allocationprefix)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Allocationprefixlen != 0 {
		n += 1 + sovNetwork(uint64(m.Allocationprefixlen))
	}
	return n
}

func (m *EIDConfigDetails) Size() (n int) {
	var l int
	_ = l
	if m.Iid != 0 {
		n += 1 + sovNetwork(uint64(m.Iid))
	}
	if m.Eidalloc != nil {
		l = m.Eidalloc.Size()
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Eid)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Lispsignature)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Pemcert)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	l = len(m.Pemprivatekey)
	if l > 0 {
		n += 1 + l + sovNetwork(uint64(l))
	}
	return n
}

func (m *EIDOverlayConfig) Size() (n int) {
	var l int
	_ = l
	if m.Eidcfgdetails != nil {
		l = m.Eidcfgdetails.Size()
		n += 1 + l + sovNetwork(uint64(l))
	}
	if len(m.Acls) > 0 {
		for _, e := range m.Acls {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if len(m.Ntoeid) > 0 {
		for _, e := range m.Ntoeid {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	return n
}

func (m *UnderlayNetwork) Size() (n int) {
	var l int
	_ = l
	if len(m.Acls) > 0 {
		for _, e := range m.Acls {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	return n
}

func sovNetwork(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNetwork(x uint64) (n int) {
	return sovNetwork(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ACEMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACEMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACEMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACEAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACEAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACEAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drop = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Limit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limitrate", wireType)
			}
			m.Limitrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limitrate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limitunit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limitunit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limitburst", wireType)
			}
			m.Limitburst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limitburst |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Allocate = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exportprivate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exportprivate = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocationprefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocationprefix = append(m.Allocationprefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Allocationprefix == nil {
				m.Allocationprefix = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocationprefixlen", wireType)
			}
			m.Allocationprefixlen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allocationprefixlen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matches = append(m.Matches, &ACEMatch{})
			if err := m.Matches[len(m.Matches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &ACEAction{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameToEid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameToEid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameToEid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Eids = append(m.Eids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdditionInfoDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdditionInfoDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdditionInfoDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Underlayip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Underlayip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Loc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Org", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Org = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OverlayNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverlayNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverlayNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
			}
			m.Iid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lispsignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lispsignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acls = append(m.Acls, &ACE{})
			if err := m.Acls[len(m.Acls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nmtoeid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nmtoeid = append(m.Nmtoeid, &NameToEid{})
			if err := m.Nmtoeid[len(m.Nmtoeid)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addinfodev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addinfodev == nil {
				m.Addinfodev = &AdditionInfoDevice{}
			}
			if err := m.Addinfodev.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EIDAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EIDAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EIDAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Allocate = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exportprivate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exportprivate = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocationprefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocationprefix = append(m.Allocationprefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Allocationprefix == nil {
				m.Allocationprefix = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocationprefixlen", wireType)
			}
			m.Allocationprefixlen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allocationprefixlen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EIDConfigDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EIDConfigDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EIDConfigDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iid", wireType)
			}
			m.Iid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eidalloc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Eidalloc == nil {
				m.Eidalloc = &EIDAllocation{}
			}
			if err := m.Eidalloc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Eid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lispsignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lispsignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pemcert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pemcert = append(m.Pemcert[:0], dAtA[iNdEx:postIndex]...)
			if m.Pemcert == nil {
				m.Pemcert = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pemprivatekey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pemprivatekey = append(m.Pemprivatekey[:0], dAtA[iNdEx:postIndex]...)
			if m.Pemprivatekey == nil {
				m.Pemprivatekey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EIDOverlayConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EIDOverlayConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EIDOverlayConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eidcfgdetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Eidcfgdetails == nil {
				m.Eidcfgdetails = &EIDConfigDetails{}
			}
			if err := m.Eidcfgdetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acls = append(m.Acls, &ACE{})
			if err := m.Acls[len(m.Acls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ntoeid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ntoeid = append(m.Ntoeid, &NameToEid{})
			if err := m.Ntoeid[len(m.Ntoeid)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnderlayNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnderlayNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnderlayNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acls = append(m.Acls, &ACE{})
			if err := m.Acls[len(m.Acls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetwork(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNetwork
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNetwork
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNetwork(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNetwork = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetwork   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("network.proto", fileDescriptorNetwork) }

var fileDescriptorNetwork = []byte{
	// 744 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x2e, 0x29, 0x59, 0x12, 0x47, 0x96, 0xeb, 0xae, 0x8b, 0x82, 0x28, 0x0a, 0x55, 0x60, 0x0d,
	0x54, 0x70, 0x01, 0xba, 0x90, 0x03, 0xe4, 0x90, 0x93, 0x22, 0xe9, 0xe0, 0x43, 0x9c, 0x60, 0x91,
	0x5c, 0x7c, 0xa3, 0xb9, 0x2b, 0x79, 0x61, 0x92, 0x4b, 0x2c, 0x97, 0x8a, 0xe5, 0x37, 0xc8, 0x1b,
	0xe4, 0x2d, 0x82, 0x5c, 0xf3, 0x04, 0xbe, 0x04, 0xc8, 0x23, 0x04, 0xce, 0x8b, 0x04, 0x3b, 0xfc,
	0xb1, 0x65, 0x39, 0x48, 0x72, 0x9b, 0xf9, 0xe6, 0x67, 0x67, 0xe6, 0xfb, 0x48, 0xe8, 0x25, 0x5c,
	0xbf, 0x96, 0xea, 0xc2, 0x4f, 0x95, 0xd4, 0xd2, 0x7b, 0x04, 0x9d, 0xf1, 0x64, 0xf6, 0x2c, 0xd0,
	0xe1, 0x39, 0x21, 0xd0, 0xd4, 0xab, 0x94, 0xbb, 0xd6, 0xc0, 0x1a, 0x3a, 0x14, 0x6d, 0xf2, 0x3b,
	0x6c, 0x2d, 0x83, 0x28, 0xe7, 0xae, 0x8d, 0x60, 0xe1, 0x78, 0xef, 0x6d, 0x70, 0xc6, 0x93, 0xd9,
	0x38, 0xd4, 0x42, 0x26, 0xa6, 0x8e, 0x29, 0x99, 0x62, 0x5d, 0x87, 0xa2, 0x6d, 0xea, 0x22, 0x11,
	0x0b, 0x8d, 0x75, 0x1d, 0x5a, 0x38, 0xe4, 0x2f, 0x70, 0xd0, 0x50, 0x81, 0xe6, 0x6e, 0x63, 0x60,
	0x0d, 0x7b, 0xf4, 0x16, 0xa8, 0xa3, 0x79, 0x22, 0xb4, 0xdb, 0xc4, 0xf7, 0x6e, 0x01, 0xd2, 0x07,
	0x40, 0xe7, 0x2c, 0x57, 0x99, 0x76, 0xb7, 0xb0, 0xf8, 0x0e, 0x42, 0xfe, 0x84, 0x4e, 0x10, 0x45,
	0x32, 0x34, 0xad, 0x5b, 0xf8, 0x68, 0xed, 0x93, 0x7d, 0xe8, 0xf1, 0xcb, 0x54, 0x2a, 0x9d, 0x2a,
	0xb1, 0x34, 0x09, 0x6d, 0x4c, 0x58, 0x07, 0xc9, 0x01, 0xec, 0x96, 0x15, 0x42, 0x26, 0xa9, 0xe2,
	0x73, 0x71, 0xe9, 0x76, 0x06, 0xd6, 0x70, 0x9b, 0x6e, 0xe0, 0xe4, 0x7f, 0xd8, 0xbb, 0x8f, 0x45,
	0x3c, 0x71, 0x1d, 0x1c, 0xeb, 0xa1, 0x90, 0xf7, 0x02, 0x1a, 0xe3, 0xc9, 0x8c, 0xfc, 0x03, 0xed,
	0xd8, 0x5c, 0x9b, 0x67, 0xae, 0x35, 0x68, 0x0c, 0xbb, 0x23, 0xc7, 0xaf, 0x08, 0xa0, 0x55, 0x84,
	0xec, 0x43, 0x3b, 0xc0, 0xdb, 0x66, 0xae, 0x8d, 0x49, 0xe0, 0xd7, 0xe7, 0xa6, 0x55, 0xc8, 0x7b,
	0x02, 0xce, 0x49, 0x10, 0xf3, 0x97, 0x72, 0x26, 0x98, 0x59, 0xff, 0x5c, 0x66, 0x3a, 0x09, 0xe2,
	0x8a, 0xc0, 0xda, 0x37, 0x04, 0x71, 0xc1, 0x8a, 0x5e, 0x0e, 0x45, 0xdb, 0xfb, 0x60, 0x01, 0x19,
	0x33, 0x26, 0x4c, 0xab, 0xe3, 0x64, 0x2e, 0xa7, 0x7c, 0x29, 0x42, 0x6e, 0xae, 0x9c, 0x27, 0x8c,
	0xab, 0x28, 0x58, 0x89, 0xb4, 0x6c, 0x74, 0x07, 0x59, 0x7b, 0xc6, 0xde, 0x7c, 0x26, 0x14, 0x7a,
	0x85, 0xc4, 0x3a, 0x14, 0x6d, 0xf2, 0x07, 0xb4, 0x14, 0x5f, 0x08, 0x99, 0x94, 0x84, 0x96, 0x1e,
	0x71, 0xa1, 0x1d, 0xca, 0x3c, 0xd1, 0x6a, 0x85, 0x54, 0x3a, 0xb4, 0x72, 0xc9, 0x2e, 0x34, 0x22,
	0x19, 0x22, 0x85, 0x0e, 0x35, 0xa6, 0x41, 0xa4, 0x5a, 0x20, 0x67, 0x0e, 0x35, 0xa6, 0xf7, 0xd1,
	0x82, 0x9d, 0xe7, 0x4b, 0x9c, 0xe9, 0xa4, 0x90, 0xb3, 0x49, 0x12, 0x82, 0xe1, 0xc4, 0x3d, 0x6a,
	0x4c, 0xb2, 0x03, 0xb6, 0x48, 0xcb, 0x21, 0x6d, 0x91, 0x1a, 0x11, 0x44, 0x22, 0x4b, 0x33, 0xb1,
	0x48, 0x02, 0x9d, 0x2b, 0x5e, 0xce, 0xb9, 0x0e, 0x12, 0x17, 0x9a, 0x41, 0x18, 0x65, 0x6e, 0x13,
	0xef, 0xde, 0x34, 0x77, 0xa7, 0x88, 0x18, 0x52, 0x92, 0x58, 0x4b, 0x2e, 0x98, 0xbb, 0x55, 0x92,
	0x52, 0x9f, 0x9f, 0x56, 0x21, 0x72, 0x04, 0x10, 0x30, 0x26, 0x92, 0xb9, 0x64, 0x7c, 0x89, 0x5b,
	0x74, 0x47, 0x7b, 0xfe, 0xe6, 0xa5, 0xe9, 0x9d, 0x34, 0xef, 0x9d, 0x05, 0xbd, 0xd9, 0xf1, 0x74,
	0x5c, 0xcb, 0x66, 0x4d, 0xcd, 0xd6, 0xf7, 0xd4, 0x6c, 0xff, 0xa8, 0x9a, 0x1b, 0x3f, 0xa7, 0xe6,
	0xe6, 0xb7, 0xd5, 0x7c, 0x6d, 0xc1, 0xee, 0xec, 0x78, 0x3a, 0x91, 0xc9, 0x5c, 0x2c, 0xa6, 0x5c,
	0x07, 0x22, 0xca, 0x1e, 0xe0, 0xe0, 0x00, 0x3a, 0x5c, 0x30, 0x6c, 0x80, 0x53, 0x76, 0x47, 0x3b,
	0xfe, 0xda, 0xa2, 0xb4, 0x8e, 0x9b, 0x6a, 0x73, 0xdb, 0x82, 0x15, 0x63, 0x6e, 0x32, 0xd6, 0x7c,
	0x98, 0xb1, 0x76, 0xca, 0xe3, 0x90, 0xab, 0xe2, 0xaf, 0xb0, 0x4d, 0x2b, 0xd7, 0xd4, 0xa7, 0x3c,
	0x2e, 0x0f, 0x72, 0xc1, 0x57, 0x48, 0xc7, 0x36, 0x5d, 0x07, 0xbd, 0x37, 0xc5, 0x2a, 0xa5, 0x9e,
	0x8a, 0x8d, 0xc8, 0x63, 0xe8, 0x71, 0xc1, 0xc2, 0xf9, 0x82, 0x15, 0xbb, 0xe1, 0x52, 0xdd, 0xd1,
	0x6f, 0xfe, 0xfd, 0xa5, 0xe9, 0x7a, 0x5e, 0xad, 0x1f, 0x7b, 0x43, 0x3f, 0x1e, 0xb4, 0x92, 0x42,
	0x3e, 0x8d, 0x0d, 0xf9, 0x94, 0x11, 0xef, 0x3f, 0xf8, 0xf5, 0x55, 0xf9, 0xb1, 0x55, 0xc2, 0xae,
	0x1a, 0x5a, 0xf7, 0x1b, 0x3e, 0x3d, 0xbd, 0xbe, 0xe9, 0x5b, 0x9f, 0x6e, 0xfa, 0xd6, 0xe7, 0x9b,
	0xbe, 0xf5, 0xf6, 0x4b, 0xff, 0x17, 0xf8, 0x3b, 0x94, 0xb1, 0x7f, 0xc5, 0x19, 0x67, 0x81, 0x1f,
	0x46, 0x32, 0x67, 0x7e, 0x9e, 0x71, 0x65, 0xe4, 0x56, 0xfc, 0xee, 0x4f, 0xff, 0x5d, 0x08, 0x7d,
	0x9e, 0x9f, 0xf9, 0xa1, 0x8c, 0x0f, 0x8b, 0xbc, 0xc3, 0x20, 0x15, 0x87, 0x8c, 0xa7, 0x8a, 0x1b,
	0x6d, 0xb1, 0xab, 0x10, 0x97, 0x3b, 0x6b, 0x61, 0xfe, 0xd1, 0xd7, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x5b, 0x9c, 0x87, 0x25, 0x2f, 0x06, 0x00, 0x00,
}
