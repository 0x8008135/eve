// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zmet.proto

/*
	Package zmet is a generated protocol buffer package.

	It is generated from these files:
		zmet.proto
		zregister.proto

	It has these top-level messages:
		ZInfoManufacturer
		ZInfoNetwork
		ZinfoPeripheral
		ZInfoSW
		ZInfoDevice
		ZInfoHypervisor
		ZInfoApp
		ZInfoMsg
		CpuMetric
		MemoryMetric
		NetworkMetric
		DeviceMetric
		ZMetricMsg
		ZRegisterResp
		ZRegisterMsg
*/
package zmet

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// Broadly there are two types
// Info : information that is discovered/rarely changes
// Metrics: information that gets updated periodically
// Protobuf definitions in this file follow the convention.
type ZInfoTypes int32

const (
	ZInfoTypes_ZiNop        ZInfoTypes = 0
	ZInfoTypes_ZiDevice     ZInfoTypes = 1
	ZInfoTypes_ZiHypervisor ZInfoTypes = 2
	ZInfoTypes_ZiApp        ZInfoTypes = 3
)

var ZInfoTypes_name = map[int32]string{
	0: "ZiNop",
	1: "ZiDevice",
	2: "ZiHypervisor",
	3: "ZiApp",
}
var ZInfoTypes_value = map[string]int32{
	"ZiNop":        0,
	"ZiDevice":     1,
	"ZiHypervisor": 2,
	"ZiApp":        3,
}

func (x ZInfoTypes) String() string {
	return proto.EnumName(ZInfoTypes_name, int32(x))
}
func (ZInfoTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorZmet, []int{0} }

type ZPeripheralTypes int32

const (
	ZPeripheralTypes_ZpNone    ZPeripheralTypes = 0
	ZPeripheralTypes_ZpStorage ZPeripheralTypes = 1
	ZPeripheralTypes_ZpNetwork ZPeripheralTypes = 2
)

var ZPeripheralTypes_name = map[int32]string{
	0: "ZpNone",
	1: "ZpStorage",
	2: "ZpNetwork",
}
var ZPeripheralTypes_value = map[string]int32{
	"ZpNone":    0,
	"ZpStorage": 1,
	"ZpNetwork": 2,
}

func (x ZPeripheralTypes) String() string {
	return proto.EnumName(ZPeripheralTypes_name, int32(x))
}
func (ZPeripheralTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorZmet, []int{1} }

type ZmetricTypes int32

const (
	ZmetricTypes_ZmNop    ZmetricTypes = 0
	ZmetricTypes_ZmDevice ZmetricTypes = 1
	ZmetricTypes_ZmApp    ZmetricTypes = 3
)

var ZmetricTypes_name = map[int32]string{
	0: "ZmNop",
	1: "ZmDevice",
	3: "ZmApp",
}
var ZmetricTypes_value = map[string]int32{
	"ZmNop":    0,
	"ZmDevice": 1,
	"ZmApp":    3,
}

func (x ZmetricTypes) String() string {
	return proto.EnumName(ZmetricTypes_name, int32(x))
}
func (ZmetricTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptorZmet, []int{2} }

// Manufacturing info, product name, model, version etc.
type ZInfoManufacturer struct {
	Manufacturer string `protobuf:"bytes,1,opt,name=manufacturer,proto3" json:"manufacturer,omitempty"`
	ProductName  string `protobuf:"bytes,2,opt,name=productName,proto3" json:"productName,omitempty"`
	Version      string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	SerialNumber string `protobuf:"bytes,4,opt,name=serialNumber,proto3" json:"serialNumber,omitempty"`
	UUID         string `protobuf:"bytes,5,opt,name=UUID,json=uUID,proto3" json:"UUID,omitempty"`
}

func (m *ZInfoManufacturer) Reset()                    { *m = ZInfoManufacturer{} }
func (m *ZInfoManufacturer) String() string            { return proto.CompactTextString(m) }
func (*ZInfoManufacturer) ProtoMessage()               {}
func (*ZInfoManufacturer) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{0} }

func (m *ZInfoManufacturer) GetManufacturer() string {
	if m != nil {
		return m.Manufacturer
	}
	return ""
}

func (m *ZInfoManufacturer) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *ZInfoManufacturer) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ZInfoManufacturer) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *ZInfoManufacturer) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

type ZInfoNetwork struct {
	IPAddr  string `protobuf:"bytes,1,opt,name=IPAddr,json=iPAddr,proto3" json:"IPAddr,omitempty"`
	GwAddr  string `protobuf:"bytes,2,opt,name=gwAddr,proto3" json:"gwAddr,omitempty"`
	MacAddr string `protobuf:"bytes,3,opt,name=macAddr,proto3" json:"macAddr,omitempty"`
	DevName string `protobuf:"bytes,4,opt,name=devName,proto3" json:"devName,omitempty"`
}

func (m *ZInfoNetwork) Reset()                    { *m = ZInfoNetwork{} }
func (m *ZInfoNetwork) String() string            { return proto.CompactTextString(m) }
func (*ZInfoNetwork) ProtoMessage()               {}
func (*ZInfoNetwork) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{1} }

func (m *ZInfoNetwork) GetIPAddr() string {
	if m != nil {
		return m.IPAddr
	}
	return ""
}

func (m *ZInfoNetwork) GetGwAddr() string {
	if m != nil {
		return m.GwAddr
	}
	return ""
}

func (m *ZInfoNetwork) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func (m *ZInfoNetwork) GetDevName() string {
	if m != nil {
		return m.DevName
	}
	return ""
}

type ZinfoPeripheral struct {
	Ztype     ZPeripheralTypes   `protobuf:"varint,1,opt,name=ztype,proto3,enum=ZPeripheralTypes" json:"ztype,omitempty"`
	Pluggable bool               `protobuf:"varint,2,opt,name=pluggable,proto3" json:"pluggable,omitempty"`
	Minfo     *ZInfoManufacturer `protobuf:"bytes,3,opt,name=minfo" json:"minfo,omitempty"`
}

func (m *ZinfoPeripheral) Reset()                    { *m = ZinfoPeripheral{} }
func (m *ZinfoPeripheral) String() string            { return proto.CompactTextString(m) }
func (*ZinfoPeripheral) ProtoMessage()               {}
func (*ZinfoPeripheral) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{2} }

func (m *ZinfoPeripheral) GetZtype() ZPeripheralTypes {
	if m != nil {
		return m.Ztype
	}
	return ZPeripheralTypes_ZpNone
}

func (m *ZinfoPeripheral) GetPluggable() bool {
	if m != nil {
		return m.Pluggable
	}
	return false
}

func (m *ZinfoPeripheral) GetMinfo() *ZInfoManufacturer {
	if m != nil {
		return m.Minfo
	}
	return nil
}

type ZInfoSW struct {
	SwVersion string `protobuf:"bytes,2,opt,name=swVersion,proto3" json:"swVersion,omitempty"`
	SwHash    string `protobuf:"bytes,3,opt,name=swHash,proto3" json:"swHash,omitempty"`
}

func (m *ZInfoSW) Reset()                    { *m = ZInfoSW{} }
func (m *ZInfoSW) String() string            { return proto.CompactTextString(m) }
func (*ZInfoSW) ProtoMessage()               {}
func (*ZInfoSW) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{3} }

func (m *ZInfoSW) GetSwVersion() string {
	if m != nil {
		return m.SwVersion
	}
	return ""
}

func (m *ZInfoSW) GetSwHash() string {
	if m != nil {
		return m.SwHash
	}
	return ""
}

// Base device info, as discovered by Xen (or OS on bare metal)
type ZInfoDevice struct {
	MachineArch string             `protobuf:"bytes,4,opt,name=machineArch,proto3" json:"machineArch,omitempty"`
	CpuArch     string             `protobuf:"bytes,5,opt,name=cpuArch,proto3" json:"cpuArch,omitempty"`
	Platform    string             `protobuf:"bytes,6,opt,name=platform,proto3" json:"platform,omitempty"`
	Ncpu        uint32             `protobuf:"varint,7,opt,name=ncpu,proto3" json:"ncpu,omitempty"`
	Memory      uint64             `protobuf:"varint,8,opt,name=memory,proto3" json:"memory,omitempty"`
	Storage     uint64             `protobuf:"varint,9,opt,name=storage,proto3" json:"storage,omitempty"`
	Devices     []*ZinfoPeripheral `protobuf:"bytes,10,rep,name=devices" json:"devices,omitempty"`
	Minfo       *ZInfoManufacturer `protobuf:"bytes,11,opt,name=minfo" json:"minfo,omitempty"`
	Software    *ZInfoSW           `protobuf:"bytes,12,opt,name=software" json:"software,omitempty"`
	Network     []*ZInfoNetwork    `protobuf:"bytes,13,rep,name=network" json:"network,omitempty"`
}

func (m *ZInfoDevice) Reset()                    { *m = ZInfoDevice{} }
func (m *ZInfoDevice) String() string            { return proto.CompactTextString(m) }
func (*ZInfoDevice) ProtoMessage()               {}
func (*ZInfoDevice) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{4} }

func (m *ZInfoDevice) GetMachineArch() string {
	if m != nil {
		return m.MachineArch
	}
	return ""
}

func (m *ZInfoDevice) GetCpuArch() string {
	if m != nil {
		return m.CpuArch
	}
	return ""
}

func (m *ZInfoDevice) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *ZInfoDevice) GetNcpu() uint32 {
	if m != nil {
		return m.Ncpu
	}
	return 0
}

func (m *ZInfoDevice) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ZInfoDevice) GetStorage() uint64 {
	if m != nil {
		return m.Storage
	}
	return 0
}

func (m *ZInfoDevice) GetDevices() []*ZinfoPeripheral {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *ZInfoDevice) GetMinfo() *ZInfoManufacturer {
	if m != nil {
		return m.Minfo
	}
	return nil
}

func (m *ZInfoDevice) GetSoftware() *ZInfoSW {
	if m != nil {
		return m.Software
	}
	return nil
}

func (m *ZInfoDevice) GetNetwork() []*ZInfoNetwork {
	if m != nil {
		return m.Network
	}
	return nil
}

// Device info from DOM0 perspective, if it exists.
type ZInfoHypervisor struct {
	Ncpu     uint32   `protobuf:"varint,3,opt,name=ncpu,proto3" json:"ncpu,omitempty"`
	Memory   uint64   `protobuf:"varint,4,opt,name=memory,proto3" json:"memory,omitempty"`
	Storage  uint64   `protobuf:"varint,5,opt,name=storage,proto3" json:"storage,omitempty"`
	Software *ZInfoSW `protobuf:"bytes,6,opt,name=software" json:"software,omitempty"`
}

func (m *ZInfoHypervisor) Reset()                    { *m = ZInfoHypervisor{} }
func (m *ZInfoHypervisor) String() string            { return proto.CompactTextString(m) }
func (*ZInfoHypervisor) ProtoMessage()               {}
func (*ZInfoHypervisor) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{5} }

func (m *ZInfoHypervisor) GetNcpu() uint32 {
	if m != nil {
		return m.Ncpu
	}
	return 0
}

func (m *ZInfoHypervisor) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ZInfoHypervisor) GetStorage() uint64 {
	if m != nil {
		return m.Storage
	}
	return 0
}

func (m *ZInfoHypervisor) GetSoftware() *ZInfoSW {
	if m != nil {
		return m.Software
	}
	return nil
}

type ZInfoApp struct {
	AppID    string   `protobuf:"bytes,1,opt,name=AppID,json=appID,proto3" json:"AppID,omitempty"`
	Ncpu     uint32   `protobuf:"varint,2,opt,name=ncpu,proto3" json:"ncpu,omitempty"`
	Memory   uint32   `protobuf:"varint,3,opt,name=memory,proto3" json:"memory,omitempty"`
	Storage  uint32   `protobuf:"varint,4,opt,name=storage,proto3" json:"storage,omitempty"`
	Software *ZInfoSW `protobuf:"bytes,5,opt,name=software" json:"software,omitempty"`
}

func (m *ZInfoApp) Reset()                    { *m = ZInfoApp{} }
func (m *ZInfoApp) String() string            { return proto.CompactTextString(m) }
func (*ZInfoApp) ProtoMessage()               {}
func (*ZInfoApp) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{6} }

func (m *ZInfoApp) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *ZInfoApp) GetNcpu() uint32 {
	if m != nil {
		return m.Ncpu
	}
	return 0
}

func (m *ZInfoApp) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ZInfoApp) GetStorage() uint32 {
	if m != nil {
		return m.Storage
	}
	return 0
}

func (m *ZInfoApp) GetSoftware() *ZInfoSW {
	if m != nil {
		return m.Software
	}
	return nil
}

type ZInfoMsg struct {
	Ztype ZInfoTypes `protobuf:"varint,1,opt,name=ztype,proto3,enum=ZInfoTypes" json:"ztype,omitempty"`
	DevId string     `protobuf:"bytes,2,opt,name=devId,proto3" json:"devId,omitempty"`
	// Types that are valid to be assigned to InfoContent:
	//	*ZInfoMsg_Dinfo
	//	*ZInfoMsg_Hinfo
	//	*ZInfoMsg_Ainfo
	InfoContent isZInfoMsg_InfoContent `protobuf_oneof:"InfoContent"`
}

func (m *ZInfoMsg) Reset()                    { *m = ZInfoMsg{} }
func (m *ZInfoMsg) String() string            { return proto.CompactTextString(m) }
func (*ZInfoMsg) ProtoMessage()               {}
func (*ZInfoMsg) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{7} }

type isZInfoMsg_InfoContent interface {
	isZInfoMsg_InfoContent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ZInfoMsg_Dinfo struct {
	Dinfo *ZInfoDevice `protobuf:"bytes,3,opt,name=dinfo,oneof"`
}
type ZInfoMsg_Hinfo struct {
	Hinfo *ZInfoHypervisor `protobuf:"bytes,4,opt,name=hinfo,oneof"`
}
type ZInfoMsg_Ainfo struct {
	Ainfo *ZInfoApp `protobuf:"bytes,5,opt,name=ainfo,oneof"`
}

func (*ZInfoMsg_Dinfo) isZInfoMsg_InfoContent() {}
func (*ZInfoMsg_Hinfo) isZInfoMsg_InfoContent() {}
func (*ZInfoMsg_Ainfo) isZInfoMsg_InfoContent() {}

func (m *ZInfoMsg) GetInfoContent() isZInfoMsg_InfoContent {
	if m != nil {
		return m.InfoContent
	}
	return nil
}

func (m *ZInfoMsg) GetZtype() ZInfoTypes {
	if m != nil {
		return m.Ztype
	}
	return ZInfoTypes_ZiNop
}

func (m *ZInfoMsg) GetDevId() string {
	if m != nil {
		return m.DevId
	}
	return ""
}

func (m *ZInfoMsg) GetDinfo() *ZInfoDevice {
	if x, ok := m.GetInfoContent().(*ZInfoMsg_Dinfo); ok {
		return x.Dinfo
	}
	return nil
}

func (m *ZInfoMsg) GetHinfo() *ZInfoHypervisor {
	if x, ok := m.GetInfoContent().(*ZInfoMsg_Hinfo); ok {
		return x.Hinfo
	}
	return nil
}

func (m *ZInfoMsg) GetAinfo() *ZInfoApp {
	if x, ok := m.GetInfoContent().(*ZInfoMsg_Ainfo); ok {
		return x.Ainfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZInfoMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZInfoMsg_OneofMarshaler, _ZInfoMsg_OneofUnmarshaler, _ZInfoMsg_OneofSizer, []interface{}{
		(*ZInfoMsg_Dinfo)(nil),
		(*ZInfoMsg_Hinfo)(nil),
		(*ZInfoMsg_Ainfo)(nil),
	}
}

func _ZInfoMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZInfoMsg)
	// InfoContent
	switch x := m.InfoContent.(type) {
	case *ZInfoMsg_Dinfo:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dinfo); err != nil {
			return err
		}
	case *ZInfoMsg_Hinfo:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Hinfo); err != nil {
			return err
		}
	case *ZInfoMsg_Ainfo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ainfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ZInfoMsg.InfoContent has unexpected type %T", x)
	}
	return nil
}

func _ZInfoMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZInfoMsg)
	switch tag {
	case 3: // InfoContent.dinfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoDevice)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoMsg_Dinfo{msg}
		return true, err
	case 4: // InfoContent.hinfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoHypervisor)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoMsg_Hinfo{msg}
		return true, err
	case 5: // InfoContent.ainfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoApp)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoMsg_Ainfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ZInfoMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZInfoMsg)
	// InfoContent
	switch x := m.InfoContent.(type) {
	case *ZInfoMsg_Dinfo:
		s := proto.Size(x.Dinfo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ZInfoMsg_Hinfo:
		s := proto.Size(x.Hinfo)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ZInfoMsg_Ainfo:
		s := proto.Size(x.Ainfo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CpuMetric struct {
	UpTime         uint32  `protobuf:"varint,2,opt,name=upTime,proto3" json:"upTime,omitempty"`
	CpuUtilization float64 `protobuf:"fixed64,3,opt,name=cpuUtilization,proto3" json:"cpuUtilization,omitempty"`
	Usr            float64 `protobuf:"fixed64,4,opt,name=usr,proto3" json:"usr,omitempty"`
	Nice           float64 `protobuf:"fixed64,5,opt,name=nice,proto3" json:"nice,omitempty"`
	System         float64 `protobuf:"fixed64,6,opt,name=system,proto3" json:"system,omitempty"`
	Io             float64 `protobuf:"fixed64,7,opt,name=io,proto3" json:"io,omitempty"`
	Irq            float64 `protobuf:"fixed64,8,opt,name=irq,proto3" json:"irq,omitempty"`
	Soft           float64 `protobuf:"fixed64,9,opt,name=soft,proto3" json:"soft,omitempty"`
	Steal          float64 `protobuf:"fixed64,10,opt,name=steal,proto3" json:"steal,omitempty"`
	Guest          float64 `protobuf:"fixed64,11,opt,name=guest,proto3" json:"guest,omitempty"`
	Idle           float64 `protobuf:"fixed64,12,opt,name=idle,proto3" json:"idle,omitempty"`
}

func (m *CpuMetric) Reset()                    { *m = CpuMetric{} }
func (m *CpuMetric) String() string            { return proto.CompactTextString(m) }
func (*CpuMetric) ProtoMessage()               {}
func (*CpuMetric) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{8} }

func (m *CpuMetric) GetUpTime() uint32 {
	if m != nil {
		return m.UpTime
	}
	return 0
}

func (m *CpuMetric) GetCpuUtilization() float64 {
	if m != nil {
		return m.CpuUtilization
	}
	return 0
}

func (m *CpuMetric) GetUsr() float64 {
	if m != nil {
		return m.Usr
	}
	return 0
}

func (m *CpuMetric) GetNice() float64 {
	if m != nil {
		return m.Nice
	}
	return 0
}

func (m *CpuMetric) GetSystem() float64 {
	if m != nil {
		return m.System
	}
	return 0
}

func (m *CpuMetric) GetIo() float64 {
	if m != nil {
		return m.Io
	}
	return 0
}

func (m *CpuMetric) GetIrq() float64 {
	if m != nil {
		return m.Irq
	}
	return 0
}

func (m *CpuMetric) GetSoft() float64 {
	if m != nil {
		return m.Soft
	}
	return 0
}

func (m *CpuMetric) GetSteal() float64 {
	if m != nil {
		return m.Steal
	}
	return 0
}

func (m *CpuMetric) GetGuest() float64 {
	if m != nil {
		return m.Guest
	}
	return 0
}

func (m *CpuMetric) GetIdle() float64 {
	if m != nil {
		return m.Idle
	}
	return 0
}

type MemoryMetric struct {
	UsedMem         uint32  `protobuf:"varint,2,opt,name=usedMem,proto3" json:"usedMem,omitempty"`
	AvailMem        uint32  `protobuf:"varint,3,opt,name=availMem,proto3" json:"availMem,omitempty"`
	UsedPercentage  float64 `protobuf:"fixed64,4,opt,name=usedPercentage,proto3" json:"usedPercentage,omitempty"`
	AvailPercentage float64 `protobuf:"fixed64,5,opt,name=availPercentage,proto3" json:"availPercentage,omitempty"`
}

func (m *MemoryMetric) Reset()                    { *m = MemoryMetric{} }
func (m *MemoryMetric) String() string            { return proto.CompactTextString(m) }
func (*MemoryMetric) ProtoMessage()               {}
func (*MemoryMetric) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{9} }

func (m *MemoryMetric) GetUsedMem() uint32 {
	if m != nil {
		return m.UsedMem
	}
	return 0
}

func (m *MemoryMetric) GetAvailMem() uint32 {
	if m != nil {
		return m.AvailMem
	}
	return 0
}

func (m *MemoryMetric) GetUsedPercentage() float64 {
	if m != nil {
		return m.UsedPercentage
	}
	return 0
}

func (m *MemoryMetric) GetAvailPercentage() float64 {
	if m != nil {
		return m.AvailPercentage
	}
	return 0
}

type NetworkMetric struct {
	IName   string `protobuf:"bytes,1,opt,name=iName,proto3" json:"iName,omitempty"`
	TxBytes uint64 `protobuf:"varint,2,opt,name=txBytes,proto3" json:"txBytes,omitempty"`
	RxBytes uint64 `protobuf:"varint,3,opt,name=rxBytes,proto3" json:"rxBytes,omitempty"`
	TxDrops uint64 `protobuf:"varint,4,opt,name=txDrops,proto3" json:"txDrops,omitempty"`
	RxDrops uint64 `protobuf:"varint,5,opt,name=rxDrops,proto3" json:"rxDrops,omitempty"`
	TxRate  uint64 `protobuf:"varint,6,opt,name=txRate,proto3" json:"txRate,omitempty"`
	RxRate  uint64 `protobuf:"varint,7,opt,name=rxRate,proto3" json:"rxRate,omitempty"`
}

func (m *NetworkMetric) Reset()                    { *m = NetworkMetric{} }
func (m *NetworkMetric) String() string            { return proto.CompactTextString(m) }
func (*NetworkMetric) ProtoMessage()               {}
func (*NetworkMetric) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{10} }

func (m *NetworkMetric) GetIName() string {
	if m != nil {
		return m.IName
	}
	return ""
}

func (m *NetworkMetric) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

func (m *NetworkMetric) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *NetworkMetric) GetTxDrops() uint64 {
	if m != nil {
		return m.TxDrops
	}
	return 0
}

func (m *NetworkMetric) GetRxDrops() uint64 {
	if m != nil {
		return m.RxDrops
	}
	return 0
}

func (m *NetworkMetric) GetTxRate() uint64 {
	if m != nil {
		return m.TxRate
	}
	return 0
}

func (m *NetworkMetric) GetRxRate() uint64 {
	if m != nil {
		return m.RxRate
	}
	return 0
}

type DeviceMetric struct {
	Cpu     *CpuMetric       `protobuf:"bytes,1,opt,name=cpu" json:"cpu,omitempty"`
	Memory  *MemoryMetric    `protobuf:"bytes,2,opt,name=memory" json:"memory,omitempty"`
	Network []*NetworkMetric `protobuf:"bytes,3,rep,name=network" json:"network,omitempty"`
}

func (m *DeviceMetric) Reset()                    { *m = DeviceMetric{} }
func (m *DeviceMetric) String() string            { return proto.CompactTextString(m) }
func (*DeviceMetric) ProtoMessage()               {}
func (*DeviceMetric) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{11} }

func (m *DeviceMetric) GetCpu() *CpuMetric {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *DeviceMetric) GetMemory() *MemoryMetric {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *DeviceMetric) GetNetwork() []*NetworkMetric {
	if m != nil {
		return m.Network
	}
	return nil
}

type ZMetricMsg struct {
	DevID string       `protobuf:"bytes,1,opt,name=devID,proto3" json:"devID,omitempty"`
	Ztype ZmetricTypes `protobuf:"varint,2,opt,name=ztype,proto3,enum=ZmetricTypes" json:"ztype,omitempty"`
	// Types that are valid to be assigned to MetricContent:
	//	*ZMetricMsg_Dm
	MetricContent isZMetricMsg_MetricContent `protobuf_oneof:"MetricContent"`
}

func (m *ZMetricMsg) Reset()                    { *m = ZMetricMsg{} }
func (m *ZMetricMsg) String() string            { return proto.CompactTextString(m) }
func (*ZMetricMsg) ProtoMessage()               {}
func (*ZMetricMsg) Descriptor() ([]byte, []int) { return fileDescriptorZmet, []int{12} }

type isZMetricMsg_MetricContent interface {
	isZMetricMsg_MetricContent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ZMetricMsg_Dm struct {
	Dm *DeviceMetric `protobuf:"bytes,4,opt,name=dm,oneof"`
}

func (*ZMetricMsg_Dm) isZMetricMsg_MetricContent() {}

func (m *ZMetricMsg) GetMetricContent() isZMetricMsg_MetricContent {
	if m != nil {
		return m.MetricContent
	}
	return nil
}

func (m *ZMetricMsg) GetDevID() string {
	if m != nil {
		return m.DevID
	}
	return ""
}

func (m *ZMetricMsg) GetZtype() ZmetricTypes {
	if m != nil {
		return m.Ztype
	}
	return ZmetricTypes_ZmNop
}

func (m *ZMetricMsg) GetDm() *DeviceMetric {
	if x, ok := m.GetMetricContent().(*ZMetricMsg_Dm); ok {
		return x.Dm
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZMetricMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZMetricMsg_OneofMarshaler, _ZMetricMsg_OneofUnmarshaler, _ZMetricMsg_OneofSizer, []interface{}{
		(*ZMetricMsg_Dm)(nil),
	}
}

func _ZMetricMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZMetricMsg)
	// MetricContent
	switch x := m.MetricContent.(type) {
	case *ZMetricMsg_Dm:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dm); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ZMetricMsg.MetricContent has unexpected type %T", x)
	}
	return nil
}

func _ZMetricMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZMetricMsg)
	switch tag {
	case 4: // MetricContent.dm
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeviceMetric)
		err := b.DecodeMessage(msg)
		m.MetricContent = &ZMetricMsg_Dm{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ZMetricMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZMetricMsg)
	// MetricContent
	switch x := m.MetricContent.(type) {
	case *ZMetricMsg_Dm:
		s := proto.Size(x.Dm)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ZInfoManufacturer)(nil), "ZInfoManufacturer")
	proto.RegisterType((*ZInfoNetwork)(nil), "ZInfoNetwork")
	proto.RegisterType((*ZinfoPeripheral)(nil), "ZinfoPeripheral")
	proto.RegisterType((*ZInfoSW)(nil), "ZInfoSW")
	proto.RegisterType((*ZInfoDevice)(nil), "ZInfoDevice")
	proto.RegisterType((*ZInfoHypervisor)(nil), "ZInfoHypervisor")
	proto.RegisterType((*ZInfoApp)(nil), "ZInfoApp")
	proto.RegisterType((*ZInfoMsg)(nil), "ZInfoMsg")
	proto.RegisterType((*CpuMetric)(nil), "cpuMetric")
	proto.RegisterType((*MemoryMetric)(nil), "memoryMetric")
	proto.RegisterType((*NetworkMetric)(nil), "networkMetric")
	proto.RegisterType((*DeviceMetric)(nil), "deviceMetric")
	proto.RegisterType((*ZMetricMsg)(nil), "ZMetricMsg")
	proto.RegisterEnum("ZInfoTypes", ZInfoTypes_name, ZInfoTypes_value)
	proto.RegisterEnum("ZPeripheralTypes", ZPeripheralTypes_name, ZPeripheralTypes_value)
	proto.RegisterEnum("ZmetricTypes", ZmetricTypes_name, ZmetricTypes_value)
}
func (m *ZInfoManufacturer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZInfoManufacturer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Manufacturer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.Manufacturer)))
		i += copy(dAtA[i:], m.Manufacturer)
	}
	if len(m.ProductName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.ProductName)))
		i += copy(dAtA[i:], m.ProductName)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.SerialNumber) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.SerialNumber)))
		i += copy(dAtA[i:], m.SerialNumber)
	}
	if len(m.UUID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.UUID)))
		i += copy(dAtA[i:], m.UUID)
	}
	return i, nil
}

func (m *ZInfoNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZInfoNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.IPAddr)))
		i += copy(dAtA[i:], m.IPAddr)
	}
	if len(m.GwAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.GwAddr)))
		i += copy(dAtA[i:], m.GwAddr)
	}
	if len(m.MacAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.MacAddr)))
		i += copy(dAtA[i:], m.MacAddr)
	}
	if len(m.DevName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.DevName)))
		i += copy(dAtA[i:], m.DevName)
	}
	return i, nil
}

func (m *ZinfoPeripheral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZinfoPeripheral) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ztype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Ztype))
	}
	if m.Pluggable {
		dAtA[i] = 0x10
		i++
		if m.Pluggable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Minfo.Size()))
		n1, err := m.Minfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ZInfoSW) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZInfoSW) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SwVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.SwVersion)))
		i += copy(dAtA[i:], m.SwVersion)
	}
	if len(m.SwHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.SwHash)))
		i += copy(dAtA[i:], m.SwHash)
	}
	return i, nil
}

func (m *ZInfoDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZInfoDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MachineArch) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.MachineArch)))
		i += copy(dAtA[i:], m.MachineArch)
	}
	if len(m.CpuArch) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.CpuArch)))
		i += copy(dAtA[i:], m.CpuArch)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.Ncpu != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Ncpu))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Memory))
	}
	if m.Storage != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Storage))
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x52
			i++
			i = encodeVarintZmet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Minfo != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Minfo.Size()))
		n2, err := m.Minfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Software != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Software.Size()))
		n3, err := m.Software.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Network) > 0 {
		for _, msg := range m.Network {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintZmet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ZInfoHypervisor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZInfoHypervisor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ncpu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Ncpu))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Memory))
	}
	if m.Storage != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Storage))
	}
	if m.Software != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Software.Size()))
		n4, err := m.Software.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ZInfoApp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZInfoApp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if m.Ncpu != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Ncpu))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Memory))
	}
	if m.Storage != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Storage))
	}
	if m.Software != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Software.Size()))
		n5, err := m.Software.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *ZInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ztype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Ztype))
	}
	if len(m.DevId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.DevId)))
		i += copy(dAtA[i:], m.DevId)
	}
	if m.InfoContent != nil {
		nn6, err := m.InfoContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	return i, nil
}

func (m *ZInfoMsg_Dinfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dinfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Dinfo.Size()))
		n7, err := m.Dinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ZInfoMsg_Hinfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Hinfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Hinfo.Size()))
		n8, err := m.Hinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ZInfoMsg_Ainfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ainfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Ainfo.Size()))
		n9, err := m.Ainfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *CpuMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.UpTime))
	}
	if m.CpuUtilization != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUtilization))))
		i += 8
	}
	if m.Usr != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Usr))))
		i += 8
	}
	if m.Nice != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Nice))))
		i += 8
	}
	if m.System != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.System))))
		i += 8
	}
	if m.Io != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Io))))
		i += 8
	}
	if m.Irq != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Irq))))
		i += 8
	}
	if m.Soft != 0 {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Soft))))
		i += 8
	}
	if m.Steal != 0 {
		dAtA[i] = 0x51
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Steal))))
		i += 8
	}
	if m.Guest != 0 {
		dAtA[i] = 0x59
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Guest))))
		i += 8
	}
	if m.Idle != 0 {
		dAtA[i] = 0x61
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Idle))))
		i += 8
	}
	return i, nil
}

func (m *MemoryMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UsedMem != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.UsedMem))
	}
	if m.AvailMem != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.AvailMem))
	}
	if m.UsedPercentage != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercentage))))
		i += 8
	}
	if m.AvailPercentage != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvailPercentage))))
		i += 8
	}
	return i, nil
}

func (m *NetworkMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.IName)))
		i += copy(dAtA[i:], m.IName)
	}
	if m.TxBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.TxBytes))
	}
	if m.RxBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.RxBytes))
	}
	if m.TxDrops != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.TxDrops))
	}
	if m.RxDrops != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.RxDrops))
	}
	if m.TxRate != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.TxRate))
	}
	if m.RxRate != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.RxRate))
	}
	return i, nil
}

func (m *DeviceMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cpu != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Cpu.Size()))
		n10, err := m.Cpu.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Memory != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Memory.Size()))
		n11, err := m.Memory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Network) > 0 {
		for _, msg := range m.Network {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintZmet(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ZMetricMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZMetricMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DevID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZmet(dAtA, i, uint64(len(m.DevID)))
		i += copy(dAtA[i:], m.DevID)
	}
	if m.Ztype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Ztype))
	}
	if m.MetricContent != nil {
		nn12, err := m.MetricContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *ZMetricMsg_Dm) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dm != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZmet(dAtA, i, uint64(m.Dm.Size()))
		n13, err := m.Dm.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func encodeVarintZmet(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ZInfoManufacturer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Manufacturer)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.UUID)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}

func (m *ZInfoNetwork) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPAddr)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.GwAddr)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.DevName)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}

func (m *ZinfoPeripheral) Size() (n int) {
	var l int
	_ = l
	if m.Ztype != 0 {
		n += 1 + sovZmet(uint64(m.Ztype))
	}
	if m.Pluggable {
		n += 2
	}
	if m.Minfo != nil {
		l = m.Minfo.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}

func (m *ZInfoSW) Size() (n int) {
	var l int
	_ = l
	l = len(m.SwVersion)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.SwHash)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}

func (m *ZInfoDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.MachineArch)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.CpuArch)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	if m.Ncpu != 0 {
		n += 1 + sovZmet(uint64(m.Ncpu))
	}
	if m.Memory != 0 {
		n += 1 + sovZmet(uint64(m.Memory))
	}
	if m.Storage != 0 {
		n += 1 + sovZmet(uint64(m.Storage))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovZmet(uint64(l))
		}
	}
	if m.Minfo != nil {
		l = m.Minfo.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	if m.Software != nil {
		l = m.Software.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovZmet(uint64(l))
		}
	}
	return n
}

func (m *ZInfoHypervisor) Size() (n int) {
	var l int
	_ = l
	if m.Ncpu != 0 {
		n += 1 + sovZmet(uint64(m.Ncpu))
	}
	if m.Memory != 0 {
		n += 1 + sovZmet(uint64(m.Memory))
	}
	if m.Storage != 0 {
		n += 1 + sovZmet(uint64(m.Storage))
	}
	if m.Software != nil {
		l = m.Software.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}

func (m *ZInfoApp) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	if m.Ncpu != 0 {
		n += 1 + sovZmet(uint64(m.Ncpu))
	}
	if m.Memory != 0 {
		n += 1 + sovZmet(uint64(m.Memory))
	}
	if m.Storage != 0 {
		n += 1 + sovZmet(uint64(m.Storage))
	}
	if m.Software != nil {
		l = m.Software.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}

func (m *ZInfoMsg) Size() (n int) {
	var l int
	_ = l
	if m.Ztype != 0 {
		n += 1 + sovZmet(uint64(m.Ztype))
	}
	l = len(m.DevId)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	if m.InfoContent != nil {
		n += m.InfoContent.Size()
	}
	return n
}

func (m *ZInfoMsg_Dinfo) Size() (n int) {
	var l int
	_ = l
	if m.Dinfo != nil {
		l = m.Dinfo.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}
func (m *ZInfoMsg_Hinfo) Size() (n int) {
	var l int
	_ = l
	if m.Hinfo != nil {
		l = m.Hinfo.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}
func (m *ZInfoMsg_Ainfo) Size() (n int) {
	var l int
	_ = l
	if m.Ainfo != nil {
		l = m.Ainfo.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}
func (m *CpuMetric) Size() (n int) {
	var l int
	_ = l
	if m.UpTime != 0 {
		n += 1 + sovZmet(uint64(m.UpTime))
	}
	if m.CpuUtilization != 0 {
		n += 9
	}
	if m.Usr != 0 {
		n += 9
	}
	if m.Nice != 0 {
		n += 9
	}
	if m.System != 0 {
		n += 9
	}
	if m.Io != 0 {
		n += 9
	}
	if m.Irq != 0 {
		n += 9
	}
	if m.Soft != 0 {
		n += 9
	}
	if m.Steal != 0 {
		n += 9
	}
	if m.Guest != 0 {
		n += 9
	}
	if m.Idle != 0 {
		n += 9
	}
	return n
}

func (m *MemoryMetric) Size() (n int) {
	var l int
	_ = l
	if m.UsedMem != 0 {
		n += 1 + sovZmet(uint64(m.UsedMem))
	}
	if m.AvailMem != 0 {
		n += 1 + sovZmet(uint64(m.AvailMem))
	}
	if m.UsedPercentage != 0 {
		n += 9
	}
	if m.AvailPercentage != 0 {
		n += 9
	}
	return n
}

func (m *NetworkMetric) Size() (n int) {
	var l int
	_ = l
	l = len(m.IName)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	if m.TxBytes != 0 {
		n += 1 + sovZmet(uint64(m.TxBytes))
	}
	if m.RxBytes != 0 {
		n += 1 + sovZmet(uint64(m.RxBytes))
	}
	if m.TxDrops != 0 {
		n += 1 + sovZmet(uint64(m.TxDrops))
	}
	if m.RxDrops != 0 {
		n += 1 + sovZmet(uint64(m.RxDrops))
	}
	if m.TxRate != 0 {
		n += 1 + sovZmet(uint64(m.TxRate))
	}
	if m.RxRate != 0 {
		n += 1 + sovZmet(uint64(m.RxRate))
	}
	return n
}

func (m *DeviceMetric) Size() (n int) {
	var l int
	_ = l
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovZmet(uint64(l))
		}
	}
	return n
}

func (m *ZMetricMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.DevID)
	if l > 0 {
		n += 1 + l + sovZmet(uint64(l))
	}
	if m.Ztype != 0 {
		n += 1 + sovZmet(uint64(m.Ztype))
	}
	if m.MetricContent != nil {
		n += m.MetricContent.Size()
	}
	return n
}

func (m *ZMetricMsg_Dm) Size() (n int) {
	var l int
	_ = l
	if m.Dm != nil {
		l = m.Dm.Size()
		n += 1 + l + sovZmet(uint64(l))
	}
	return n
}

func sovZmet(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozZmet(x uint64) (n int) {
	return sovZmet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ZInfoManufacturer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZInfoManufacturer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZInfoManufacturer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manufacturer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manufacturer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZInfoNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZInfoNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZInfoNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GwAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GwAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZinfoPeripheral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZinfoPeripheral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZinfoPeripheral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ztype", wireType)
			}
			m.Ztype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ztype |= (ZPeripheralTypes(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pluggable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pluggable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Minfo == nil {
				m.Minfo = &ZInfoManufacturer{}
			}
			if err := m.Minfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZInfoSW) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZInfoSW: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZInfoSW: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZInfoDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZInfoDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZInfoDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineArch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineArch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuArch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuArch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ncpu", wireType)
			}
			m.Ncpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ncpu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			m.Storage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Storage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &ZinfoPeripheral{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Minfo == nil {
				m.Minfo = &ZInfoManufacturer{}
			}
			if err := m.Minfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Software", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Software == nil {
				m.Software = &ZInfoSW{}
			}
			if err := m.Software.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &ZInfoNetwork{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZInfoHypervisor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZInfoHypervisor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZInfoHypervisor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ncpu", wireType)
			}
			m.Ncpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ncpu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			m.Storage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Storage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Software", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Software == nil {
				m.Software = &ZInfoSW{}
			}
			if err := m.Software.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZInfoApp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZInfoApp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZInfoApp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ncpu", wireType)
			}
			m.Ncpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ncpu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			m.Storage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Storage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Software", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Software == nil {
				m.Software = &ZInfoSW{}
			}
			if err := m.Software.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ztype", wireType)
			}
			m.Ztype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ztype |= (ZInfoTypes(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ZInfoDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InfoContent = &ZInfoMsg_Dinfo{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ZInfoHypervisor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InfoContent = &ZInfoMsg_Hinfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ainfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ZInfoApp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InfoContent = &ZInfoMsg_Ainfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cpuMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cpuMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpTime", wireType)
			}
			m.UpTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUtilization = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Usr = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Nice = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.System = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Io", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Io = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irq", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Irq = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soft", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Soft = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Steal = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Guest = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Idle = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: memoryMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: memoryMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedMem", wireType)
			}
			m.UsedMem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedMem |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailMem", wireType)
			}
			m.AvailMem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailMem |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercentage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercentage = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailPercentage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvailPercentage = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: networkMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: networkMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBytes", wireType)
			}
			m.TxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxBytes", wireType)
			}
			m.RxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDrops", wireType)
			}
			m.TxDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDrops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDrops", wireType)
			}
			m.RxDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDrops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxRate", wireType)
			}
			m.TxRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxRate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxRate", wireType)
			}
			m.RxRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxRate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deviceMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deviceMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CpuMetric{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryMetric{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &NetworkMetric{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZMetricMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZMetricMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZMetricMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ztype", wireType)
			}
			m.Ztype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ztype |= (ZmetricTypes(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZmet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeviceMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MetricContent = &ZMetricMsg_Dm{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZmet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZmet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipZmet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowZmet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZmet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthZmet
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowZmet
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipZmet(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthZmet = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowZmet   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("zmet.proto", fileDescriptorZmet) }

var fileDescriptorZmet = []byte{
	// 1099 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x56, 0xbd, 0x6e, 0xe3, 0x46,
	0x10, 0xf6, 0x4a, 0xa2, 0x7e, 0x46, 0x92, 0xcd, 0x5b, 0x1c, 0x0e, 0x44, 0x70, 0xf0, 0x39, 0xcc,
	0x25, 0x27, 0xb8, 0x60, 0xe1, 0x14, 0x69, 0x02, 0x04, 0x76, 0x5c, 0x58, 0x85, 0x8d, 0xc3, 0xde,
	0x39, 0x01, 0xd4, 0xd1, 0xe4, 0x5a, 0x5e, 0x44, 0x14, 0x37, 0xcb, 0xa5, 0x6c, 0x19, 0xb8, 0x26,
	0x75, 0xea, 0x20, 0xef, 0x90, 0x67, 0x48, 0x19, 0x20, 0xe5, 0x3d, 0x42, 0xe0, 0x3c, 0x48, 0x82,
	0x9d, 0x5d, 0x4a, 0x94, 0x62, 0x23, 0x1d, 0xbf, 0xf9, 0x86, 0xcb, 0x6f, 0x66, 0xf6, 0x1b, 0x09,
	0xe0, 0x3e, 0xe3, 0x3a, 0x92, 0x2a, 0xd7, 0x79, 0xf8, 0x1b, 0x81, 0x67, 0x93, 0xf1, 0xfc, 0x3a,
	0x3f, 0x8f, 0xe7, 0xe5, 0x75, 0x9c, 0xe8, 0x52, 0x71, 0x45, 0x43, 0x18, 0x64, 0x35, 0x1c, 0x90,
	0x03, 0x32, 0xea, 0xb1, 0x8d, 0x18, 0x3d, 0x80, 0xbe, 0x54, 0x79, 0x5a, 0x26, 0xfa, 0x22, 0xce,
	0x78, 0xd0, 0xc0, 0x94, 0x7a, 0x88, 0x06, 0xd0, 0x59, 0x70, 0x55, 0x88, 0x7c, 0x1e, 0x34, 0x91,
	0xad, 0xa0, 0x39, 0xbf, 0xe0, 0x4a, 0xc4, 0xb3, 0x8b, 0x32, 0xbb, 0xe2, 0x2a, 0x68, 0xd9, 0xf3,
	0xeb, 0x31, 0x4a, 0xa1, 0x75, 0x79, 0x39, 0x3e, 0x0d, 0x3c, 0xe4, 0x5a, 0xe5, 0xe5, 0xf8, 0x34,
	0x54, 0x30, 0x40, 0xb1, 0x17, 0x5c, 0xdf, 0xe6, 0xea, 0x07, 0xfa, 0x02, 0xda, 0xe3, 0xb7, 0xc7,
	0x69, 0x5a, 0x29, 0x6c, 0x0b, 0x44, 0x26, 0x3e, 0xbd, 0xc5, 0xb8, 0x95, 0xe5, 0x90, 0x51, 0x94,
	0xc5, 0x09, 0x12, 0x4e, 0x91, 0x83, 0x86, 0x49, 0xf9, 0x02, 0x2b, 0xb1, 0x62, 0x2a, 0x18, 0xfe,
	0x44, 0x60, 0x6f, 0x22, 0xe6, 0xd7, 0xf9, 0x5b, 0xae, 0x84, 0xbc, 0xe1, 0x2a, 0x9e, 0xd1, 0x37,
	0xe0, 0xdd, 0xeb, 0xa5, 0xe4, 0xf8, 0xd9, 0xdd, 0xa3, 0x67, 0xd1, 0x64, 0x4d, 0xbe, 0x5f, 0x4a,
	0x5e, 0x30, 0xcb, 0xd3, 0x97, 0xd0, 0x93, 0xb3, 0x72, 0x3a, 0x8d, 0xaf, 0x66, 0xb6, 0x45, 0x5d,
	0xb6, 0x0e, 0xd0, 0x11, 0x78, 0x99, 0x39, 0x19, 0xc5, 0xf4, 0x8f, 0x68, 0xf4, 0x9f, 0x49, 0x30,
	0x9b, 0x10, 0x7e, 0x03, 0x1d, 0xe4, 0xde, 0x7d, 0x6f, 0x8e, 0x2c, 0x6e, 0xbf, 0x73, 0x7d, 0xb5,
	0xe5, 0xad, 0x03, 0xa6, 0xf2, 0xe2, 0xf6, 0x2c, 0x2e, 0x6e, 0x5c, 0x81, 0x0e, 0x85, 0x1f, 0x1b,
	0xd0, 0xc7, 0x13, 0x4e, 0xf9, 0x42, 0x24, 0xdc, 0x4c, 0x2f, 0x8b, 0x93, 0x1b, 0x31, 0xe7, 0xc7,
	0x2a, 0xb9, 0x71, 0x35, 0xd7, 0x43, 0xa6, 0x23, 0x89, 0x2c, 0x91, 0xb5, 0x23, 0xa8, 0x20, 0xfd,
	0x04, 0xba, 0x72, 0x16, 0xeb, 0xeb, 0x5c, 0x65, 0x41, 0x1b, 0xa9, 0x15, 0x36, 0x53, 0x9b, 0x27,
	0xb2, 0x0c, 0x3a, 0x07, 0x64, 0x34, 0x64, 0xf8, 0x6c, 0x34, 0x65, 0x3c, 0xcb, 0xd5, 0x32, 0xe8,
	0x1e, 0x90, 0x51, 0x8b, 0x39, 0x64, 0xbe, 0x50, 0xe8, 0x5c, 0xc5, 0x53, 0x1e, 0xf4, 0x90, 0xa8,
	0x20, 0x3d, 0xc4, 0x69, 0x88, 0x84, 0x17, 0x01, 0x1c, 0x34, 0x47, 0xfd, 0x23, 0x3f, 0xda, 0x1a,
	0x01, 0xab, 0x12, 0xd6, 0x4d, 0xec, 0xff, 0x4f, 0x13, 0xe9, 0x6b, 0xe8, 0x16, 0xf9, 0xb5, 0xbe,
	0x8d, 0x15, 0x0f, 0x06, 0x98, 0xdc, 0x8d, 0x5c, 0x57, 0xd9, 0x8a, 0xa1, 0x6f, 0xa0, 0x33, 0xb7,
	0xd7, 0x2b, 0x18, 0xe2, 0xb7, 0x87, 0x51, 0xfd, 0xce, 0xb1, 0x8a, 0x0d, 0x3f, 0xc0, 0x1e, 0x12,
	0x67, 0x4b, 0xc9, 0xd5, 0x42, 0x14, 0xb9, 0x5a, 0x55, 0xdf, 0x7c, 0xb4, 0xfa, 0xd6, 0x53, 0xd5,
	0x7b, 0x9b, 0xd5, 0xd7, 0x75, 0xb6, 0x9f, 0xd2, 0x19, 0xfe, 0x4c, 0xa0, 0x8b, 0xd1, 0x63, 0x29,
	0xe9, 0x73, 0xf0, 0x8e, 0xa5, 0x1c, 0x9f, 0x3a, 0x1f, 0x78, 0xb1, 0x01, 0x2b, 0x39, 0x8d, 0x47,
	0xe5, 0x58, 0x91, 0x8f, 0xc8, 0x69, 0x21, 0xf1, 0xa8, 0x1c, 0xef, 0x49, 0x39, 0x7f, 0x54, 0x72,
	0xce, 0x8b, 0x29, 0xfd, 0x74, 0xd3, 0x1f, 0x7d, 0x9b, 0xbf, 0xe1, 0x8c, 0xe7, 0xe0, 0xa5, 0x7c,
	0x31, 0x4e, 0xdd, 0x15, 0xb6, 0x80, 0xbe, 0x06, 0x2f, 0xad, 0x39, 0x62, 0x10, 0xd5, 0xee, 0xec,
	0xd9, 0x0e, 0xb3, 0xa4, 0x19, 0xf9, 0x0d, 0x66, 0xb5, 0x30, 0xcb, 0x8f, 0xb6, 0xe6, 0x60, 0x32,
	0x31, 0xc1, 0x08, 0x89, 0x31, 0xd3, 0x0a, 0xef, 0x45, 0x55, 0xc7, 0x4c, 0x0a, 0x32, 0x27, 0x43,
	0xe8, 0x9b, 0xd8, 0xb7, 0xf9, 0x5c, 0xf3, 0xb9, 0x0e, 0xff, 0x21, 0xd0, 0x4b, 0x64, 0x79, 0xce,
	0xb5, 0x12, 0x89, 0xe9, 0x56, 0x29, 0xdf, 0x0b, 0xb7, 0xdf, 0x86, 0xcc, 0x21, 0xfa, 0x05, 0xec,
	0x26, 0xb2, 0xbc, 0xd4, 0x62, 0x26, 0xee, 0x63, 0x5d, 0x6d, 0x38, 0xc2, 0xb6, 0xa2, 0xd4, 0x87,
	0x66, 0x59, 0xd8, 0xfd, 0x46, 0x98, 0x79, 0xc4, 0x99, 0x88, 0xc4, 0x76, 0x92, 0x30, 0x7c, 0x46,
	0xd3, 0x2e, 0x0b, 0xcd, 0xad, 0x9d, 0x08, 0x73, 0x88, 0xee, 0x42, 0x43, 0xe4, 0x68, 0x25, 0xc2,
	0x1a, 0x22, 0x37, 0xa7, 0x09, 0xf5, 0x23, 0xba, 0x88, 0x30, 0xf3, 0x68, 0x4e, 0x33, 0x13, 0x40,
	0xff, 0x10, 0x86, 0xcf, 0xa6, 0xb3, 0x85, 0xe6, 0xf1, 0x2c, 0x00, 0x0c, 0x5a, 0x60, 0xa2, 0xd3,
	0x92, 0x17, 0x1a, 0x6d, 0x42, 0x98, 0x05, 0xe6, 0x7d, 0x91, 0xce, 0xac, 0x1d, 0x08, 0xc3, 0xe7,
	0xf0, 0x17, 0x02, 0x03, 0x7b, 0x29, 0x5c, 0x13, 0x02, 0xe8, 0x94, 0x05, 0x4f, 0xcf, 0x79, 0xe6,
	0xba, 0x50, 0x41, 0xb3, 0x09, 0xe2, 0x45, 0x2c, 0x66, 0x86, 0xb2, 0xd7, 0x69, 0x85, 0x4d, 0x8b,
	0x4c, 0xda, 0x5b, 0xae, 0x12, 0x3e, 0xd7, 0xd5, 0xbd, 0x22, 0x6c, 0x2b, 0x4a, 0x47, 0xb0, 0x87,
	0xef, 0xd4, 0x12, 0x6d, 0x6f, 0xb6, 0xc3, 0xe1, 0xef, 0x04, 0x86, 0xce, 0x7c, 0x4e, 0xd9, 0x73,
	0xf0, 0x04, 0xee, 0x6c, 0x77, 0xed, 0x45, 0xf5, 0xbb, 0xa3, 0xef, 0x4e, 0x96, 0x9a, 0x17, 0xa8,
	0xb7, 0xc5, 0x2a, 0x68, 0x18, 0xe5, 0x98, 0xa6, 0x65, 0xd4, 0x9a, 0xd1, 0x77, 0xa7, 0x2a, 0x97,
	0x85, 0xb3, 0x69, 0x05, 0xed, 0x3b, 0x96, 0xf1, 0xaa, 0x77, 0x2c, 0xf3, 0x02, 0xda, 0xfa, 0x8e,
	0xc5, 0xda, 0xba, 0xb4, 0xc5, 0x1c, 0x32, 0x71, 0x65, 0xe3, 0x1d, 0x1b, 0xb7, 0x28, 0xfc, 0x00,
	0x03, 0xbb, 0xb4, 0x9c, 0xfa, 0x97, 0xd0, 0x34, 0xee, 0x24, 0x78, 0x35, 0x21, 0x5a, 0xdd, 0x3a,
	0x66, 0xc2, 0xf4, 0xf3, 0x95, 0x51, 0x1b, 0x98, 0x30, 0x8c, 0xea, 0x43, 0x59, 0xf9, 0x76, 0xb4,
	0x5e, 0x57, 0x4d, 0x5c, 0x57, 0xbb, 0xd1, 0x46, 0x8f, 0xd6, 0xfb, 0x6a, 0x09, 0x30, 0xb1, 0x31,
	0x63, 0x51, 0xe7, 0xbf, 0xd5, 0xc6, 0x40, 0x40, 0x3f, 0xab, 0x8c, 0xdb, 0x40, 0xe3, 0x0e, 0xa3,
	0x49, 0x86, 0x6f, 0x6c, 0x58, 0xf7, 0x15, 0x34, 0xd2, 0xcc, 0x79, 0x6f, 0x18, 0xd5, 0x4b, 0x3a,
	0xdb, 0x61, 0x8d, 0x34, 0x3b, 0xd9, 0x83, 0xa1, 0xc5, 0xce, 0x54, 0x87, 0x27, 0x00, 0xeb, 0x0d,
	0x40, 0x7b, 0xe0, 0x4d, 0xc4, 0x45, 0x2e, 0xfd, 0x1d, 0x3a, 0x80, 0xee, 0x44, 0x58, 0x7b, 0xfb,
	0x84, 0xfa, 0x30, 0x98, 0x88, 0xb5, 0x8d, 0xfd, 0x86, 0x4d, 0x3d, 0x96, 0xd2, 0x6f, 0x1e, 0x7e,
	0x0d, 0xfe, 0xf6, 0xaf, 0x2c, 0x05, 0x68, 0x4f, 0xe4, 0x45, 0x3e, 0xe7, 0xfe, 0x0e, 0x1d, 0x42,
	0x6f, 0x22, 0xdf, 0xd9, 0x9d, 0xe5, 0x13, 0x0b, 0xdd, 0xce, 0xf6, 0x1b, 0x87, 0x47, 0x30, 0xa8,
	0x97, 0x82, 0x07, 0x67, 0x6b, 0x0d, 0xd9, 0x4a, 0x03, 0x12, 0xf8, 0xc5, 0x93, 0xaf, 0xfe, 0x7c,
	0xd8, 0x27, 0x1f, 0x1f, 0xf6, 0xc9, 0x5f, 0x0f, 0xfb, 0xe4, 0xd7, 0xbf, 0xf7, 0x77, 0xe0, 0x55,
	0x92, 0x67, 0xd1, 0x3d, 0x4f, 0x79, 0x1a, 0x47, 0xc9, 0x2c, 0x2f, 0xd3, 0xa8, 0x2c, 0x8c, 0xd8,
	0x84, 0xdb, 0xbf, 0x53, 0x93, 0x96, 0xf9, 0x6b, 0x75, 0xd5, 0x46, 0xf0, 0xe5, 0xbf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x70, 0x3b, 0x52, 0x9c, 0x69, 0x09, 0x00, 0x00,
}
