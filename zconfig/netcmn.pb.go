// Code generated by protoc-gen-go. DO NOT EDIT.
// source: netcmn.proto

package zconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DHCPType int32

const (
	DHCPType_DHCPNoop DHCPType = 0
	// used for device adapter
	DHCPType_Static DHCPType = 1
	// used for application simulation
	DHCPType_PassThrough DHCPType = 2
	// used for application simulation
	DHCPType_Server DHCPType = 3
	// used for device adapter
	DHCPType_Client DHCPType = 4
)

var DHCPType_name = map[int32]string{
	0: "DHCPNoop",
	1: "Static",
	2: "PassThrough",
	3: "Server",
	4: "Client",
}
var DHCPType_value = map[string]int32{
	"DHCPNoop":    0,
	"Static":      1,
	"PassThrough": 2,
	"Server":      3,
	"Client":      4,
}

func (x DHCPType) String() string {
	return proto.EnumName(DHCPType_name, int32(x))
}
func (DHCPType) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

type NetworkType int32

const (
	NetworkType_NETWORKTYPENOOP NetworkType = 0
	NetworkType_V4              NetworkType = 4
	NetworkType_V6              NetworkType = 6
	NetworkType_LISP            NetworkType = 10
)

var NetworkType_name = map[int32]string{
	0:  "NETWORKTYPENOOP",
	4:  "V4",
	6:  "V6",
	10: "LISP",
}
var NetworkType_value = map[string]int32{
	"NETWORKTYPENOOP": 0,
	"V4":              4,
	"V6":              6,
	"LISP":            10,
}

func (x NetworkType) String() string {
	return proto.EnumName(NetworkType_name, int32(x))
}
func (NetworkType) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

type IpRange struct {
	Start string `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   string `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *IpRange) Reset()                    { *m = IpRange{} }
func (m *IpRange) String() string            { return proto.CompactTextString(m) }
func (*IpRange) ProtoMessage()               {}
func (*IpRange) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *IpRange) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *IpRange) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

type Ipv4Spec struct {
	Dhcp DHCPType `protobuf:"varint,2,opt,name=dhcp,enum=DHCPType" json:"dhcp,omitempty"`
	// subnet is CIDR format...x.y.z.l/nn
	Subnet  string   `protobuf:"bytes,3,opt,name=subnet" json:"subnet,omitempty"`
	Gateway string   `protobuf:"bytes,5,opt,name=gateway" json:"gateway,omitempty"`
	Domain  string   `protobuf:"bytes,6,opt,name=domain" json:"domain,omitempty"`
	Ntp     string   `protobuf:"bytes,7,opt,name=ntp" json:"ntp,omitempty"`
	Dns     []string `protobuf:"bytes,8,rep,name=dns" json:"dns,omitempty"`
	// for IPAM management when dhcp is turned on.
	// If none provided, system will default pool.
	DhcpRange *IpRange `protobuf:"bytes,9,opt,name=dhcpRange" json:"dhcpRange,omitempty"`
}

func (m *Ipv4Spec) Reset()                    { *m = Ipv4Spec{} }
func (m *Ipv4Spec) String() string            { return proto.CompactTextString(m) }
func (*Ipv4Spec) ProtoMessage()               {}
func (*Ipv4Spec) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *Ipv4Spec) GetDhcp() DHCPType {
	if m != nil {
		return m.Dhcp
	}
	return DHCPType_DHCPNoop
}

func (m *Ipv4Spec) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *Ipv4Spec) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *Ipv4Spec) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Ipv4Spec) GetNtp() string {
	if m != nil {
		return m.Ntp
	}
	return ""
}

func (m *Ipv4Spec) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *Ipv4Spec) GetDhcpRange() *IpRange {
	if m != nil {
		return m.DhcpRange
	}
	return nil
}

type Ipv6Spec struct {
	Dhcp DHCPType `protobuf:"varint,2,opt,name=dhcp,enum=DHCPType" json:"dhcp,omitempty"`
	// subnet is CIDR format...x.y.z.l/nn
	Subnet  string   `protobuf:"bytes,3,opt,name=subnet" json:"subnet,omitempty"`
	Gateway string   `protobuf:"bytes,5,opt,name=gateway" json:"gateway,omitempty"`
	Domain  string   `protobuf:"bytes,6,opt,name=domain" json:"domain,omitempty"`
	Ntp     string   `protobuf:"bytes,7,opt,name=ntp" json:"ntp,omitempty"`
	Dns     []string `protobuf:"bytes,8,rep,name=dns" json:"dns,omitempty"`
	// for IPAM management when dhcp is turned on.
	// If none provided, system will default pool.
	DhcpRange *IpRange `protobuf:"bytes,9,opt,name=dhcpRange" json:"dhcpRange,omitempty"`
}

func (m *Ipv6Spec) Reset()                    { *m = Ipv6Spec{} }
func (m *Ipv6Spec) String() string            { return proto.CompactTextString(m) }
func (*Ipv6Spec) ProtoMessage()               {}
func (*Ipv6Spec) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

func (m *Ipv6Spec) GetDhcp() DHCPType {
	if m != nil {
		return m.Dhcp
	}
	return DHCPType_DHCPNoop
}

func (m *Ipv6Spec) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *Ipv6Spec) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *Ipv6Spec) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Ipv6Spec) GetNtp() string {
	if m != nil {
		return m.Ntp
	}
	return ""
}

func (m *Ipv6Spec) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *Ipv6Spec) GetDhcpRange() *IpRange {
	if m != nil {
		return m.DhcpRange
	}
	return nil
}

// FIXME: This will all move to network service rather than lispspec in
// network common
type NameToEid struct {
	Hostname string   `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	Eids     []string `protobuf:"bytes,2,rep,name=eids" json:"eids,omitempty"`
}

func (m *NameToEid) Reset()                    { *m = NameToEid{} }
func (m *NameToEid) String() string            { return proto.CompactTextString(m) }
func (*NameToEid) ProtoMessage()               {}
func (*NameToEid) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *NameToEid) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *NameToEid) GetEids() []string {
	if m != nil {
		return m.Eids
	}
	return nil
}

type EIDAllocation struct {
	Allocate            bool   `protobuf:"varint,1,opt,name=allocate" json:"allocate,omitempty"`
	Exportprivate       bool   `protobuf:"varint,2,opt,name=exportprivate" json:"exportprivate,omitempty"`
	Allocationprefix    []byte `protobuf:"bytes,3,opt,name=allocationprefix,proto3" json:"allocationprefix,omitempty"`
	Allocationprefixlen uint32 `protobuf:"varint,4,opt,name=allocationprefixlen" json:"allocationprefixlen,omitempty"`
}

func (m *EIDAllocation) Reset()                    { *m = EIDAllocation{} }
func (m *EIDAllocation) String() string            { return proto.CompactTextString(m) }
func (*EIDAllocation) ProtoMessage()               {}
func (*EIDAllocation) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{4} }

func (m *EIDAllocation) GetAllocate() bool {
	if m != nil {
		return m.Allocate
	}
	return false
}

func (m *EIDAllocation) GetExportprivate() bool {
	if m != nil {
		return m.Exportprivate
	}
	return false
}

func (m *EIDAllocation) GetAllocationprefix() []byte {
	if m != nil {
		return m.Allocationprefix
	}
	return nil
}

func (m *EIDAllocation) GetAllocationprefixlen() uint32 {
	if m != nil {
		return m.Allocationprefixlen
	}
	return 0
}

type Lispspec struct {
	Iid      uint32         `protobuf:"varint,1,opt,name=iid" json:"iid,omitempty"`
	Eidalloc *EIDAllocation `protobuf:"bytes,2,opt,name=eidalloc" json:"eidalloc,omitempty"`
	Nmtoeid  []*NameToEid   `protobuf:"bytes,3,rep,name=nmtoeid" json:"nmtoeid,omitempty"`
}

func (m *Lispspec) Reset()                    { *m = Lispspec{} }
func (m *Lispspec) String() string            { return proto.CompactTextString(m) }
func (*Lispspec) ProtoMessage()               {}
func (*Lispspec) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

func (m *Lispspec) GetIid() uint32 {
	if m != nil {
		return m.Iid
	}
	return 0
}

func (m *Lispspec) GetEidalloc() *EIDAllocation {
	if m != nil {
		return m.Eidalloc
	}
	return nil
}

func (m *Lispspec) GetNmtoeid() []*NameToEid {
	if m != nil {
		return m.Nmtoeid
	}
	return nil
}

func init() {
	proto.RegisterType((*IpRange)(nil), "ipRange")
	proto.RegisterType((*Ipv4Spec)(nil), "ipv4spec")
	proto.RegisterType((*Ipv6Spec)(nil), "ipv6spec")
	proto.RegisterType((*NameToEid)(nil), "NameToEid")
	proto.RegisterType((*EIDAllocation)(nil), "EIDAllocation")
	proto.RegisterType((*Lispspec)(nil), "lispspec")
	proto.RegisterEnum("DHCPType", DHCPType_name, DHCPType_value)
	proto.RegisterEnum("NetworkType", NetworkType_name, NetworkType_value)
}

func init() { proto.RegisterFile("netcmn.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 537 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x53, 0x5d, 0x6f, 0xd3, 0x30,
	0x14, 0x5d, 0x9a, 0x2c, 0x4d, 0x6f, 0xd7, 0xcd, 0xf2, 0x10, 0xb2, 0x90, 0x26, 0xaa, 0x6a, 0x42,
	0x55, 0x1f, 0x32, 0x28, 0xd3, 0x5e, 0xe0, 0x01, 0xd8, 0x2a, 0x31, 0x01, 0x5d, 0x95, 0x55, 0x20,
	0x78, 0xf3, 0xe2, 0xbb, 0xd6, 0x22, 0xb1, 0xad, 0xc4, 0xed, 0x3e, 0xfe, 0x14, 0x3f, 0x81, 0xbf,
	0x86, 0xe2, 0xb4, 0x45, 0x03, 0xfe, 0x00, 0x4f, 0xbd, 0xe7, 0x9c, 0x7b, 0x8f, 0xef, 0xb1, 0x1b,
	0xd8, 0x51, 0x68, 0xd3, 0x5c, 0xc5, 0xa6, 0xd0, 0x56, 0xf7, 0x5e, 0x40, 0x53, 0x9a, 0x84, 0xab,
	0x19, 0xd2, 0x47, 0xb0, 0x5d, 0x5a, 0x5e, 0x58, 0xe6, 0x75, 0xbd, 0x7e, 0x2b, 0xa9, 0x01, 0x25,
	0xe0, 0xa3, 0x12, 0xac, 0xe1, 0xb8, 0xaa, 0xec, 0xfd, 0xf4, 0x20, 0x92, 0x66, 0x79, 0x5c, 0x1a,
	0x4c, 0xe9, 0x01, 0x04, 0x62, 0x9e, 0x1a, 0xa7, 0xef, 0x0e, 0x5b, 0xf1, 0xd9, 0xfb, 0xd3, 0xc9,
	0xf4, 0xce, 0x60, 0xe2, 0x68, 0xfa, 0x18, 0xc2, 0x72, 0x71, 0xa5, 0xd0, 0x32, 0xdf, 0x19, 0xac,
	0x10, 0x65, 0xd0, 0x9c, 0x71, 0x8b, 0x37, 0xfc, 0x8e, 0x6d, 0x3b, 0x61, 0x0d, 0xab, 0x09, 0xa1,
	0x73, 0x2e, 0x15, 0x0b, 0xeb, 0x89, 0x1a, 0x55, 0x7b, 0x28, 0x6b, 0x58, 0xb3, 0xde, 0x43, 0x59,
	0x53, 0x31, 0x42, 0x95, 0x2c, 0xea, 0xfa, 0x15, 0x23, 0x54, 0x49, 0x9f, 0x41, 0xab, 0x3a, 0xd5,
	0xc5, 0x61, 0xad, 0xae, 0xd7, 0x6f, 0x0f, 0xa3, 0x78, 0x15, 0x2f, 0xf9, 0x2d, 0xad, 0x13, 0x9c,
	0xfc, 0xbf, 0x09, 0x5e, 0x41, 0x6b, 0xcc, 0x73, 0x9c, 0xea, 0x91, 0x14, 0xf4, 0x09, 0x44, 0x73,
	0x5d, 0x5a, 0xc5, 0x73, 0x5c, 0xbd, 0xdd, 0x06, 0x53, 0x0a, 0x01, 0x4a, 0x51, 0xb2, 0x86, 0x3b,
	0xc3, 0xd5, 0xbd, 0x1f, 0x1e, 0x74, 0x46, 0xe7, 0x67, 0x6f, 0xb3, 0x4c, 0xa7, 0xdc, 0x4a, 0xad,
	0x2a, 0x07, 0x5e, 0xa3, 0xda, 0x21, 0x4a, 0x36, 0x98, 0x1e, 0x42, 0x07, 0x6f, 0x8d, 0x2e, 0xac,
	0x29, 0xe4, 0xb2, 0x6a, 0x68, 0xb8, 0x86, 0x87, 0x24, 0x1d, 0x00, 0xe1, 0x1b, 0x3f, 0x53, 0xe0,
	0xb5, 0xbc, 0x75, 0x17, 0xb6, 0x93, 0xfc, 0xc5, 0xd3, 0xe7, 0xb0, 0xff, 0x27, 0x97, 0xa1, 0x62,
	0x41, 0xd7, 0xeb, 0x77, 0x92, 0x7f, 0x49, 0x3d, 0x05, 0x51, 0x26, 0x4b, 0xe3, 0xde, 0x8b, 0x80,
	0x2f, 0xa5, 0x70, 0x6b, 0x76, 0x92, 0xaa, 0xa4, 0x03, 0x88, 0x50, 0x0a, 0x37, 0xe7, 0x96, 0x6b,
	0x0f, 0x77, 0xe3, 0x07, 0xf9, 0x92, 0x8d, 0x4e, 0x0f, 0xa1, 0xa9, 0x72, 0xab, 0x51, 0x0a, 0xe6,
	0x77, 0xfd, 0x7e, 0x7b, 0x08, 0xf1, 0xe6, 0x22, 0x93, 0xb5, 0x34, 0xf8, 0x04, 0xd1, 0xfa, 0x6f,
	0x40, 0x77, 0xea, 0x7a, 0xac, 0xb5, 0x21, 0x5b, 0x14, 0x20, 0xbc, 0xb4, 0xdc, 0xca, 0x94, 0x78,
	0x74, 0x0f, 0xda, 0x13, 0x5e, 0x96, 0xd3, 0x79, 0xa1, 0x17, 0xb3, 0x39, 0x69, 0x38, 0x11, 0x8b,
	0x25, 0x16, 0xc4, 0xaf, 0xea, 0xd3, 0x4c, 0xa2, 0xb2, 0x24, 0x18, 0xbc, 0x86, 0xf6, 0x18, 0xed,
	0x8d, 0x2e, 0xbe, 0x3b, 0xc7, 0x7d, 0xd8, 0x1b, 0x8f, 0xa6, 0x5f, 0x2e, 0x92, 0x0f, 0xd3, 0xaf,
	0x93, 0xd1, 0xf8, 0xe2, 0x62, 0x42, 0xb6, 0x68, 0x08, 0x8d, 0xcf, 0xc7, 0x24, 0x70, 0xbf, 0x27,
	0x24, 0xa4, 0x11, 0x04, 0x1f, 0xcf, 0x2f, 0x27, 0x04, 0xde, 0xbd, 0x81, 0xa7, 0xa9, 0xce, 0xe3,
	0x7b, 0x14, 0x28, 0x78, 0x9c, 0x66, 0x7a, 0x21, 0xe2, 0x45, 0x89, 0xc5, 0x52, 0xa6, 0x58, 0x7f,
	0xc5, 0xdf, 0x0e, 0x66, 0xd2, 0xce, 0x17, 0x57, 0x71, 0xaa, 0xf3, 0xa3, 0xba, 0xef, 0x88, 0x1b,
	0x79, 0x74, 0x9f, 0x6a, 0x75, 0x2d, 0x67, 0x57, 0xa1, 0xeb, 0x7a, 0xf9, 0x2b, 0x00, 0x00, 0xff,
	0xff, 0x94, 0x8e, 0x12, 0x31, 0xfb, 0x03, 0x00, 0x00,
}
