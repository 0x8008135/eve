// Code generated by protoc-gen-go. DO NOT EDIT.
// source: netinst.proto

package zconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ZNetworkInstType int32

const (
	ZNetworkInstType_ZNetInstFirst       ZNetworkInstType = 0
	ZNetworkInstType_ZnetInstSwitch      ZNetworkInstType = 1
	ZNetworkInstType_ZnetInstLocal       ZNetworkInstType = 2
	ZNetworkInstType_ZnetInstCloud       ZNetworkInstType = 3
	ZNetworkInstType_ZnetInstMesh        ZNetworkInstType = 4
	ZNetworkInstType_ZnetInstHoneyPot    ZNetworkInstType = 5
	ZNetworkInstType_ZnetInstTransparent ZNetworkInstType = 6
	ZNetworkInstType_ZNetInstLast        ZNetworkInstType = 255
)

var ZNetworkInstType_name = map[int32]string{
	0:   "ZNetInstFirst",
	1:   "ZnetInstSwitch",
	2:   "ZnetInstLocal",
	3:   "ZnetInstCloud",
	4:   "ZnetInstMesh",
	5:   "ZnetInstHoneyPot",
	6:   "ZnetInstTransparent",
	255: "ZNetInstLast",
}
var ZNetworkInstType_value = map[string]int32{
	"ZNetInstFirst":       0,
	"ZnetInstSwitch":      1,
	"ZnetInstLocal":       2,
	"ZnetInstCloud":       3,
	"ZnetInstMesh":        4,
	"ZnetInstHoneyPot":    5,
	"ZnetInstTransparent": 6,
	"ZNetInstLast":        255,
}

func (x ZNetworkInstType) String() string {
	return proto.EnumName(ZNetworkInstType_name, int32(x))
}
func (ZNetworkInstType) EnumDescriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

type AddressType int32

const (
	AddressType_AddressTypeFirst    AddressType = 0
	AddressType_AddressTypeIPV4     AddressType = 1
	AddressType_AddressTypeIPV6     AddressType = 2
	AddressType_AddressTypeCryptoV4 AddressType = 3
	AddressType_AddressTypeCryptoV6 AddressType = 4
	AddressType_AddressTypeLast     AddressType = 255
)

var AddressType_name = map[int32]string{
	0:   "AddressTypeFirst",
	1:   "AddressTypeIPV4",
	2:   "AddressTypeIPV6",
	3:   "AddressTypeCryptoV4",
	4:   "AddressTypeCryptoV6",
	255: "AddressTypeLast",
}
var AddressType_value = map[string]int32{
	"AddressTypeFirst":    0,
	"AddressTypeIPV4":     1,
	"AddressTypeIPV6":     2,
	"AddressTypeCryptoV4": 3,
	"AddressTypeCryptoV6": 4,
	"AddressTypeLast":     255,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}
func (AddressType) EnumDescriptor() ([]byte, []int) { return fileDescriptor7, []int{1} }

// Network Instance Opaque config. In future we might add more fields here
// but idea is here. This is service specific configuration.
type NetworkInstanceOpaqueConfig struct {
	Oconfig string `protobuf:"bytes,1,opt,name=oconfig" json:"oconfig,omitempty"`
}

func (m *NetworkInstanceOpaqueConfig) Reset()                    { *m = NetworkInstanceOpaqueConfig{} }
func (m *NetworkInstanceOpaqueConfig) String() string            { return proto.CompactTextString(m) }
func (*NetworkInstanceOpaqueConfig) ProtoMessage()               {}
func (*NetworkInstanceOpaqueConfig) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

func (m *NetworkInstanceOpaqueConfig) GetOconfig() string {
	if m != nil {
		return m.Oconfig
	}
	return ""
}

// Lisp NetworkInstance config
type NetworkInstanceLispConfig struct {
	LispMSs             []*ZcServicePoint `protobuf:"bytes,1,rep,name=LispMSs" json:"LispMSs,omitempty"`
	LispInstanceId      uint32            `protobuf:"varint,2,opt,name=LispInstanceId" json:"LispInstanceId,omitempty"`
	Allocate            bool              `protobuf:"varint,3,opt,name=allocate" json:"allocate,omitempty"`
	Exportprivate       bool              `protobuf:"varint,4,opt,name=exportprivate" json:"exportprivate,omitempty"`
	Allocationprefix    []byte            `protobuf:"bytes,5,opt,name=allocationprefix,proto3" json:"allocationprefix,omitempty"`
	Allocationprefixlen uint32            `protobuf:"varint,6,opt,name=allocationprefixlen" json:"allocationprefixlen,omitempty"`
	// various configuration to dataPlane, lispers.net vs Zededa
	Experimental bool `protobuf:"varint,20,opt,name=experimental" json:"experimental,omitempty"`
}

func (m *NetworkInstanceLispConfig) Reset()                    { *m = NetworkInstanceLispConfig{} }
func (m *NetworkInstanceLispConfig) String() string            { return proto.CompactTextString(m) }
func (*NetworkInstanceLispConfig) ProtoMessage()               {}
func (*NetworkInstanceLispConfig) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{1} }

func (m *NetworkInstanceLispConfig) GetLispMSs() []*ZcServicePoint {
	if m != nil {
		return m.LispMSs
	}
	return nil
}

func (m *NetworkInstanceLispConfig) GetLispInstanceId() uint32 {
	if m != nil {
		return m.LispInstanceId
	}
	return 0
}

func (m *NetworkInstanceLispConfig) GetAllocate() bool {
	if m != nil {
		return m.Allocate
	}
	return false
}

func (m *NetworkInstanceLispConfig) GetExportprivate() bool {
	if m != nil {
		return m.Exportprivate
	}
	return false
}

func (m *NetworkInstanceLispConfig) GetAllocationprefix() []byte {
	if m != nil {
		return m.Allocationprefix
	}
	return nil
}

func (m *NetworkInstanceLispConfig) GetAllocationprefixlen() uint32 {
	if m != nil {
		return m.Allocationprefixlen
	}
	return 0
}

func (m *NetworkInstanceLispConfig) GetExperimental() bool {
	if m != nil {
		return m.Experimental
	}
	return false
}

type NetworkInstanceConfig struct {
	Uuidandversion *UUIDandVersion `protobuf:"bytes,1,opt,name=uuidandversion" json:"uuidandversion,omitempty"`
	Displayname    string          `protobuf:"bytes,2,opt,name=displayname" json:"displayname,omitempty"`
	// instType - Type of network instance ( local, bridge etc )
	InstType ZNetworkInstType `protobuf:"varint,4,opt,name=instType,enum=ZNetworkInstType" json:"instType,omitempty"`
	// activate
	//  - True by default. If set to false ( inactivate), the network instance
	//    configuration is downloaded to the device, but the network instance
	//    itself is not created on the device.
	Activate bool `protobuf:"varint,5,opt,name=activate" json:"activate,omitempty"`
	// port - Only a single port is supported.
	//    This is used as the external connection for the network instance.
	//    This can be a physical (eth0 ) or logical port (vlan 0).
	//    The port name comes from DeviceConfig ( When it is supported in future).
	//    If the user needs multiple physical ports, Device config should be
	//    used to create a label for multiple physical ports.
	Port *Adapter `protobuf:"bytes,20,opt,name=port" json:"port,omitempty"`
	// cfg - Used to pass some feature-specific configuration to the
	//       network instance. For Ex: Lisp, StriongSwan etc
	Cfg *NetworkInstanceOpaqueConfig `protobuf:"bytes,30,opt,name=cfg" json:"cfg,omitempty"`
	// type of ipSpec
	IpType AddressType `protobuf:"varint,39,opt,name=ipType,enum=AddressType" json:"ipType,omitempty"`
	// network ip specification
	Ip *Ipspec `protobuf:"bytes,40,opt,name=ip" json:"ip,omitempty"`
	// static DNS entry, if we are running DNS/DHCP service
	Dns []*ZnetStaticDNSEntry `protobuf:"bytes,41,rep,name=dns" json:"dns,omitempty"`
}

func (m *NetworkInstanceConfig) Reset()                    { *m = NetworkInstanceConfig{} }
func (m *NetworkInstanceConfig) String() string            { return proto.CompactTextString(m) }
func (*NetworkInstanceConfig) ProtoMessage()               {}
func (*NetworkInstanceConfig) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{2} }

func (m *NetworkInstanceConfig) GetUuidandversion() *UUIDandVersion {
	if m != nil {
		return m.Uuidandversion
	}
	return nil
}

func (m *NetworkInstanceConfig) GetDisplayname() string {
	if m != nil {
		return m.Displayname
	}
	return ""
}

func (m *NetworkInstanceConfig) GetInstType() ZNetworkInstType {
	if m != nil {
		return m.InstType
	}
	return ZNetworkInstType_ZNetInstFirst
}

func (m *NetworkInstanceConfig) GetActivate() bool {
	if m != nil {
		return m.Activate
	}
	return false
}

func (m *NetworkInstanceConfig) GetPort() *Adapter {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *NetworkInstanceConfig) GetCfg() *NetworkInstanceOpaqueConfig {
	if m != nil {
		return m.Cfg
	}
	return nil
}

func (m *NetworkInstanceConfig) GetIpType() AddressType {
	if m != nil {
		return m.IpType
	}
	return AddressType_AddressTypeFirst
}

func (m *NetworkInstanceConfig) GetIp() *Ipspec {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *NetworkInstanceConfig) GetDns() []*ZnetStaticDNSEntry {
	if m != nil {
		return m.Dns
	}
	return nil
}

func init() {
	proto.RegisterType((*NetworkInstanceOpaqueConfig)(nil), "NetworkInstanceOpaqueConfig")
	proto.RegisterType((*NetworkInstanceLispConfig)(nil), "NetworkInstanceLispConfig")
	proto.RegisterType((*NetworkInstanceConfig)(nil), "NetworkInstanceConfig")
	proto.RegisterEnum("ZNetworkInstType", ZNetworkInstType_name, ZNetworkInstType_value)
	proto.RegisterEnum("AddressType", AddressType_name, AddressType_value)
}

func init() { proto.RegisterFile("netinst.proto", fileDescriptor7) }

var fileDescriptor7 = []byte{
	// 647 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xdd, 0x4e, 0x1b, 0x3b,
	0x14, 0x85, 0xcf, 0x24, 0x10, 0xc2, 0xce, 0x0f, 0xc6, 0xe1, 0x88, 0x39, 0x1c, 0xda, 0x46, 0x11,
	0x6d, 0x03, 0x52, 0x87, 0x8a, 0x22, 0xb8, 0x2d, 0x85, 0x56, 0x8d, 0x04, 0x14, 0x4d, 0x80, 0x8b,
	0xdc, 0x19, 0x8f, 0x01, 0xab, 0x89, 0xed, 0xda, 0x4e, 0x20, 0xbc, 0x47, 0x5f, 0xa4, 0x7d, 0xb2,
	0x3e, 0x41, 0x2b, 0x3b, 0x33, 0x68, 0x08, 0xa8, 0x77, 0xde, 0xdf, 0x5e, 0xde, 0xb3, 0xbc, 0xe4,
	0x31, 0xd4, 0x04, 0xb3, 0x5c, 0x18, 0x1b, 0x29, 0x2d, 0xad, 0x5c, 0x59, 0x48, 0xd8, 0x88, 0xca,
	0xc1, 0x40, 0x8a, 0x14, 0x54, 0x05, 0xb3, 0x74, 0x90, 0x56, 0xad, 0x5d, 0xf8, 0xff, 0x98, 0xd9,
	0x1b, 0xa9, 0xbf, 0x76, 0x84, 0xb1, 0x44, 0x50, 0xf6, 0x45, 0x91, 0x6f, 0x43, 0xb6, 0x2f, 0xc5,
	0x25, 0xbf, 0xc2, 0x21, 0xcc, 0x49, 0xea, 0x97, 0x61, 0xd0, 0x0c, 0xda, 0xf3, 0x71, 0x56, 0xb6,
	0x7e, 0x14, 0xe0, 0xbf, 0xa9, 0x9d, 0x87, 0xdc, 0xa8, 0x74, 0xdf, 0x3a, 0xcc, 0xb9, 0xea, 0xa8,
	0x6b, 0xc2, 0xa0, 0x59, 0x6c, 0x57, 0xb6, 0x16, 0xa2, 0x1e, 0xed, 0x32, 0x3d, 0xe2, 0x94, 0x9d,
	0x48, 0x2e, 0x6c, 0x9c, 0xf5, 0xf1, 0x2b, 0xa8, 0xbb, 0x65, 0x36, 0xa4, 0x93, 0x84, 0x85, 0x66,
	0xd0, 0xae, 0xc5, 0x53, 0x14, 0xaf, 0x40, 0x99, 0xf4, 0xfb, 0x92, 0x12, 0xcb, 0xc2, 0x62, 0x33,
	0x68, 0x97, 0xe3, 0xfb, 0x1a, 0xaf, 0x41, 0x8d, 0xdd, 0x2a, 0xa9, 0xad, 0xd2, 0x7c, 0xe4, 0x04,
	0x33, 0x5e, 0xf0, 0x10, 0xe2, 0x0d, 0x40, 0xe9, 0x0e, 0x2e, 0x85, 0xd2, 0xec, 0x92, 0xdf, 0x86,
	0xb3, 0xcd, 0xa0, 0x5d, 0x8d, 0x1f, 0x71, 0xfc, 0x16, 0x1a, 0xd3, 0xac, 0xcf, 0x44, 0x58, 0xf2,
	0xd6, 0x9e, 0x6a, 0xe1, 0x16, 0x54, 0xd9, 0xad, 0x62, 0x9a, 0x0f, 0x98, 0xb0, 0xa4, 0x1f, 0x2e,
	0x79, 0x0b, 0x0f, 0x58, 0xeb, 0x57, 0x01, 0xfe, 0x9d, 0x0a, 0x2d, 0x0d, 0x6c, 0x17, 0xea, 0xc3,
	0x21, 0x4f, 0x88, 0x48, 0x46, 0x4c, 0x1b, 0x2e, 0x85, 0xcf, 0xdb, 0xe5, 0x76, 0x76, 0xd6, 0x39,
	0x20, 0x22, 0x39, 0x9f, 0xe0, 0x78, 0x4a, 0x86, 0x9b, 0x50, 0x49, 0xb8, 0x51, 0x7d, 0x32, 0x16,
	0x64, 0xc0, 0x7c, 0x76, 0xf3, 0x71, 0x1e, 0xe1, 0x37, 0x50, 0x76, 0xf7, 0xe1, 0x74, 0xac, 0x26,
	0xb9, 0xd4, 0xb7, 0x16, 0xa3, 0x5e, 0xce, 0x85, 0x6b, 0xc4, 0xf7, 0x12, 0x9f, 0x33, 0xb5, 0x93,
	0x18, 0x67, 0xd3, 0x9c, 0xd3, 0x1a, 0xaf, 0xc2, 0x8c, 0x0b, 0xd4, 0x9f, 0xad, 0xb2, 0x55, 0x8e,
	0xf6, 0x12, 0xa2, 0x2c, 0xd3, 0xb1, 0xa7, 0x38, 0x82, 0x22, 0xbd, 0xbc, 0x0a, 0x9f, 0xfb, 0xe6,
	0x6a, 0xf4, 0x97, 0x7b, 0x15, 0x3b, 0x21, 0x5e, 0x83, 0x12, 0x57, 0xde, 0xd6, 0x6b, 0x6f, 0xab,
	0x1a, 0xed, 0x25, 0x89, 0x66, 0xc6, 0x78, 0x47, 0x69, 0x0f, 0x2f, 0x43, 0x81, 0xab, 0xb0, 0xed,
	0x87, 0xce, 0x45, 0x5c, 0x19, 0xc5, 0x68, 0x5c, 0xe0, 0x0a, 0xbf, 0x84, 0x62, 0x22, 0x4c, 0xb8,
	0xee, 0xef, 0x57, 0x23, 0xea, 0x09, 0x66, 0xbb, 0x96, 0x58, 0x4e, 0x0f, 0x8e, 0xbb, 0x1f, 0x85,
	0xd5, 0xe3, 0xd8, 0xf5, 0x37, 0x7e, 0x06, 0x80, 0xa6, 0x8f, 0x8b, 0x17, 0xa1, 0xe6, 0x98, 0xab,
	0x3f, 0x71, 0x6d, 0x2c, 0xfa, 0x07, 0x63, 0xa8, 0xbb, 0x11, 0x0e, 0x75, 0x6f, 0xb8, 0xa5, 0xd7,
	0x28, 0xf0, 0xb2, 0x94, 0x1d, 0x4a, 0x4a, 0xfa, 0xa8, 0x90, 0x47, 0xfb, 0x7d, 0x39, 0x4c, 0x50,
	0x11, 0x23, 0xa8, 0x66, 0xe8, 0x88, 0x99, 0x6b, 0x34, 0x83, 0x97, 0x00, 0x65, 0xe4, 0xb3, 0x14,
	0x6c, 0x7c, 0x22, 0x2d, 0x9a, 0xc5, 0xcb, 0xd0, 0xc8, 0xe8, 0xa9, 0x26, 0xc2, 0x28, 0xa2, 0x99,
	0xb0, 0xa8, 0x84, 0x17, 0xa1, 0x9a, 0xb9, 0x39, 0x24, 0xc6, 0xa2, 0xdf, 0xc1, 0xc6, 0xf7, 0x00,
	0x2a, 0xb9, 0x34, 0xdc, 0xc4, 0x5c, 0x99, 0x79, 0x6e, 0xc0, 0x42, 0x8e, 0x76, 0x4e, 0xce, 0xb7,
	0x51, 0xf0, 0x18, 0xee, 0xa0, 0x82, 0xfb, 0x76, 0x0e, 0xee, 0xeb, 0xb1, 0xb2, 0xf2, 0x7c, 0x1b,
	0x15, 0x9f, 0x6e, 0xec, 0xf8, 0x33, 0xe4, 0xc7, 0xa4, 0xbe, 0x3e, 0xbc, 0x87, 0x17, 0x54, 0x0e,
	0xa2, 0x3b, 0x96, 0xb0, 0x84, 0x44, 0xd4, 0x25, 0x10, 0x0d, 0xcd, 0xe4, 0xc7, 0x9e, 0x3c, 0x29,
	0xbd, 0x67, 0x57, 0xdc, 0x5e, 0x0f, 0x2f, 0x22, 0x2a, 0x07, 0x9b, 0x13, 0xdd, 0x26, 0x51, 0x7c,
	0xf3, 0x6e, 0xf2, 0x70, 0x5c, 0x94, 0xbc, 0xea, 0xdd, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6b,
	0xc2, 0x84, 0xfc, 0xa8, 0x04, 0x00, 0x00,
}
