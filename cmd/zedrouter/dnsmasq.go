// Copyright (c) 2017 Zededa, Inc.
// All rights reserved.

// dnsmasq configlets for overlay and underlay interfaces towards domU

package zedrouter

import (
	"fmt"
	"github.com/zededa/go-provision/agentlog"
	"github.com/zededa/go-provision/types"
	"log"
	"net"
	"os"
	"os/exec"
)

const dnsmasqStatic = `
# Automatically generated by zedrouter
except-interface=lo
bind-interfaces
log-queries
log-dhcp
no-hosts
no-ping
bogus-priv
stop-dns-rebind
rebind-localhost-ok
neg-ttl=10
`

// Create the dnsmasq configuration for the the overlay interface
// Would be more polite to return an error then to Fatal
func createDnsmasqOverlayConfiglet(ctx *zedrouterContext,
	cfgPathname string, olIfname string,
	olAddr1 string, olAddr2 string, olMac string, hostsDir string,
	hostName string, ipsets []string, netconf *types.NetworkObjectConfig) {
	if debug {
		log.Printf("createDnsmasqOverlayConfiglet: %s\n", olIfname)
	}
	file, err := os.Create(cfgPathname)
	if err != nil {
		log.Fatal("os.Create for ", cfgPathname, err)
	}
	defer file.Close()
	file.WriteString(dnsmasqStatic)
	// XXX insert in common if subnet is IPv6
	file.WriteString(fmt.Sprintf("dhcp-range=::,static,0,infinite\n"))
	for _, ipset := range ipsets {
		file.WriteString(fmt.Sprintf("ipset=/%s/ipv4.%s,ipv6.%s\n",
			ipset, ipset, ipset))
	}
	file.WriteString(fmt.Sprintf("pid-file=/var/run/dnsmasq.%s.pid\n",
		olIfname))
	file.WriteString(fmt.Sprintf("interface=%s\n", olIfname))
	file.WriteString(fmt.Sprintf("listen-address=%s\n", olAddr1))
	if netconf != nil {
		// walk all of netconf - find all hosts which use this network
		for _, status := range appNetworkStatus {
			for _, olStatus := range status.OverlayNetworkList {
				if olStatus.Network != netconf.UUID {
					continue
				}
				file.WriteString(fmt.Sprintf("dhcp-host=%s,[%s],%s\n",
					olStatus.Mac,
					olStatus.EID,
					olStatus.HostName))
			}
		}
	} else {
		file.WriteString(fmt.Sprintf("dhcp-host=%s,[%s],%s\n",
			olMac, olAddr2, hostName))
	}
	file.WriteString(fmt.Sprintf("hostsdir=%s\n", hostsDir))

	if netconf != nil {
		// XXX do we need same logic as for IPv4 to not advertise
		// as default router? Or done by radvd? Might need lower
		// radvd preference if isolated local network?
		if netconf.DomainName != "" {
			file.WriteString(fmt.Sprintf("dhcp-option=option:domain-search,%s\n",
				netconf.DomainName))
		}
		for _, ns := range netconf.DnsServers {
			file.WriteString(fmt.Sprintf("dhcp-option=option:dns-server,%s\n",
				ns.String()))
		}
		if netconf.NtpServer != nil {
			file.WriteString(fmt.Sprintf("dhcp-option=option:ntp-server,%s\n",
				netconf.NtpServer.String()))
		}
	}
}

// XXX call from NetworkObject when it is created. Have separate
// function to add/remove hosts using dhcp-hostsdir setup

// Create the dnsmasq configuration for the the underlay interface
// Would be more polite to return an error then to Fatal
// XXX not clear what needs to change here to handle IPv6 underlay. The default
// ranges are off, plus domain-name needs to be replaced by domain-search, etc
func createDnsmasqUnderlayConfiglet(ctx *zedrouterContext,
	cfgPathname string, ulIfname string,
	ulAddr1 string, ulAddr2 string, ulMac string, hostsDir string,
	hostName string, ipsets []string, netconf *types.NetworkObjectConfig) {
	if debug {
		log.Printf("createDnsmasqUnderlayConfiglet: %s netconf %v\n",
			ulIfname, netconf)
	}
	file, err := os.Create(cfgPathname)
	if err != nil {
		log.Fatal("os.Create for ", cfgPathname, err)
	}
	defer file.Close()
	file.WriteString(dnsmasqStatic)
	for _, ipset := range ipsets {
		file.WriteString(fmt.Sprintf("ipset=/%s/ipv4.%s,ipv6.%s\n",
			ipset, ipset, ipset))
	}
	file.WriteString(fmt.Sprintf("pid-file=/var/run/dnsmasq.%s.pid\n",
		ulIfname))
	file.WriteString(fmt.Sprintf("interface=%s\n", ulIfname))
	if ulAddr1 != "" {
		file.WriteString(fmt.Sprintf("listen-address=%s\n", ulAddr1))
	}
	file.WriteString(fmt.Sprintf("hostsdir=%s\n", hostsDir))

	if netconf != nil {
		// walk all of netconf - find all hosts which use this network
		for _, status := range appNetworkStatus {
			for _, ulStatus := range status.UnderlayNetworkList {
				if ulStatus.Network != netconf.UUID {
					continue
				}
				log.Printf("createDnsmasqUnderlayConfiglet: netconf has %s/%s\n",
					ulStatus.Mac, ulStatus.AssignedIPAddr)

				file.WriteString(fmt.Sprintf("dhcp-host=%s,id:*,%s,%s\n",
					ulStatus.Mac,
					ulStatus.AssignedIPAddr,
					ulStatus.HostName))
			}
		}
	} else {
		log.Printf("createDnsmasqUnderlayConfiglet: single %s/%s\n",
			ulMac, ulAddr2)
		file.WriteString(fmt.Sprintf("dhcp-host=%s,id:*,%s,%s\n",
			ulMac, ulAddr2, hostName))
	}

	netmask := "255.255.255.0" // Default unless there is a Subnet
	dhcpRange := ulAddr2       // Default unless there is a DhcpRange
	if dhcpRange == "" {
		dhcpRange = "172.27.0.0"
	}
	if netconf != nil {
		// By default dnsmasq advertizes a router (and we can have a
		// static router defined in the NetworkObjectConfig).
		// To support airgap networks we interpret gateway=0.0.0.0
		// to not advertize ourselves as a router. Also,
		// if there is not an explicit dns server we skip
		// advertising that as well.
		advertizeRouter := true
		var router string
		if netconf.Gateway != nil {
			if netconf.Gateway.IsUnspecified() {
				advertizeRouter = false
			} else {
				router = netconf.Gateway.String()
			}
		} else if ulAddr1 != "" {
			router = ulAddr1
		} else {
			advertizeRouter = false
		}
		if netconf.DomainName != "" {
			file.WriteString(fmt.Sprintf("dhcp-option=option:domain-name,%s\n",
				netconf.DomainName))
		}
		advertizedDns := false
		for _, ns := range netconf.DnsServers {
			advertizedDns = true
			file.WriteString(fmt.Sprintf("dhcp-option=option:dns-server,%s\n",
				ns.String()))
		}
		if netconf.NtpServer != nil {
			file.WriteString(fmt.Sprintf("dhcp-option=option:ntp-server,%s\n",
				netconf.NtpServer.String()))
		}
		if netconf.Subnet.IP != nil {
			netmask = net.IP(netconf.Subnet.Mask).String()
			file.WriteString(fmt.Sprintf("dhcp-option=option:netmask,%s\n",
				netmask))
		}
		if advertizeRouter {
			file.WriteString(fmt.Sprintf("dhcp-option=option:router,%s\n",
				router))
		} else {
			log.Printf("createDnsmasqUnderlayConfiglet: no router\n")
			file.WriteString(fmt.Sprintf("dhcp-option=option:router\n"))
			if !advertizedDns {
				// Handle isolated network by making sure
				// we are not a DNS server. Can be overridden
				// with the DnsServers above
				log.Printf("createDnsmasqUnderlayConfiglet: no DNS server\n")
				file.WriteString(fmt.Sprintf("dhcp-option=option:dns-server\n"))
			}
		}
		if netconf.DhcpRange.Start != nil {
			dhcpRange = netconf.DhcpRange.Start.String()
		}
	}
	file.WriteString(fmt.Sprintf("dhcp-range=%s,static,%s,infinite\n",
		dhcpRange, netmask))
}

// XXX new used when network is created; sets up dhcp-hostsdir
// XXX do we need ipsets?
// XXX if we don't have a service we need to allocate a ulAddr1 aka bridgeIPAddr
// from network... require a subnet and dhcp-range in that case.
func createDnsmasqConfiglet(ctx *zedrouterContext, bridgeName string,
	bridgeIPAddr string,
	netconf *types.NetworkObjectConfig, hostsDir string,
	ipsets []string) {

	if debug {
		log.Printf("createDnsmasqConfiglet: %s netconf %v\n",
			bridgeName, netconf)
	}
	cfgFilename := "dnsmasq." + bridgeName + ".conf"
	cfgPathname := runDirname + "/" + cfgFilename
	file, err := os.Create(cfgPathname)
	if err != nil {
		log.Fatal("os.Create for ", cfgPathname, err)
	}
	defer file.Close()

	// Create a dhcp-hosts directory to be used when hosts are added
	dhcphostsDirpath := globalRunDirname + "/dhcp-hosts." + bridgeName
	ensureDir(dhcphostsDirpath)
	
	file.WriteString(dnsmasqStatic)
	for _, ipset := range ipsets {
		file.WriteString(fmt.Sprintf("ipset=/%s/ipv4.%s,ipv6.%s\n",
			ipset, ipset, ipset))
	}
	file.WriteString(fmt.Sprintf("pid-file=/var/run/dnsmasq.%s.pid\n",
		bridgeName))
	file.WriteString(fmt.Sprintf("interface=%s\n", bridgeName))
	file.WriteString(fmt.Sprintf("listen-address=%s\n", bridgeIPAddr))
	file.WriteString(fmt.Sprintf("hostsdir=%s\n", hostsDir))

	netmask := "255.255.255.0" // Default unless there is a Subnet
	dhcpRange := bridgeIPAddr       // Default unless there is a DhcpRange

	if netconf != nil {
		// By default dnsmasq advertizes a router (and we can have a
		// static router defined in the NetworkObjectConfig).
		// However, if we have no NetworkService to the outside world
		// we don't advertise ourselves as a router by default.
		advertizeRouter := true
		nst, adapter, err := getServiceInfo(ctx, netconf.UUID)
		if err != nil {
			log.Println(err)
			advertizeRouter = false
		} else if nst == types.NST_FIRST {
			log.Printf("createDnsmasqConfiglet: NST_FIRST ignored\n")
			advertizeRouter = false
		} else {
			log.Printf("createDnsmasqConfiglet: found service %d adapter %s\n",
				nst, adapter)
		}
		if netconf.DomainName != "" {
			file.WriteString(fmt.Sprintf("dhcp-option=option:domain-name,%s\n",
				netconf.DomainName))
		}
		maybeAdvertizeDns := false
		for _, ns := range netconf.DnsServers {
			maybeAdvertizeDns = true
			file.WriteString(fmt.Sprintf("dhcp-option=option:dns-server,%s\n",
				ns.String()))
		}
		if netconf.NtpServer != nil {
			file.WriteString(fmt.Sprintf("dhcp-option=option:ntp-server,%s\n",
				netconf.NtpServer.String()))
		}
		if netconf.Subnet.IP != nil {
			netmask = net.IP(netconf.Subnet.Mask).String()
			file.WriteString(fmt.Sprintf("dhcp-option=option:netmask,%s\n",
				netmask))
		}
		if netconf.Gateway != nil {
			file.WriteString(fmt.Sprintf("dhcp-option=option:router,%s\n",
				netconf.Gateway.String()))
		} else if advertizeRouter {
			// XXX can bridgeIPAddr be zero?
			file.WriteString(fmt.Sprintf("dhcp-option=option:router,%s\n",
				bridgeIPAddr))
		} else {
			log.Printf("createDnsmasqConfiglet: no router\n")
			file.WriteString(fmt.Sprintf("dhcp-option=option:router\n"))
			if !maybeAdvertizeDns {
				// XXX handle isolated network by making sure
				// we are not a DNS server. Can be overridden
				// with the DnsServers above
				log.Printf("createDnsmasqConfiglet: no DNS server\n")
				file.WriteString(fmt.Sprintf("dhcp-option=option:dns-server\n"))
			}
		}
		if netconf.DhcpRange.Start != nil {
			dhcpRange = netconf.DhcpRange.Start.String()
		}
	}
	file.WriteString(fmt.Sprintf("dhcp-range=%s,static,%s,infinite\n",
		dhcpRange, netmask))
}

func deleteDnsmasqConfiglet(cfgPathname string) {
	if debug {
		log.Printf("deleteDnsmasqConfiglet: %s\n", cfgPathname)
	}
	if err := os.Remove(cfgPathname); err != nil {
		log.Println(err)
	}
}

func deleteDnsmasqConfiglet2(bridgeName string) {
	if debug {
		log.Printf("deleteDnsmasqConfiglet2(%s)\n", bridgeName)
	}
	cfgFilename := "dnsmasq." + bridgeName + ".conf"
	cfgPathname := runDirname + "/" + cfgFilename
	if err := os.Remove(cfgPathname); err != nil {
		log.Println(err)
	}
	dhcphostsDirpath := globalRunDirname + "/dhcp-hosts." + bridgeName
	if err := os.RemoveAll(dhcphostsDirpath); err != nil {
		log.Println(err)
	}
}

// Run this:
//    DMDIR=/opt/zededa/bin/
//    ${DMDIR}/dnsmasq -b -C /var/run/zedrouter/dnsmasq.${BRIDGENAME}.conf
func startDnsmasq(cfgPathname string, ifname string) {
	if debug {
		log.Printf("startDnsmasq: %s\n", cfgPathname)
	}
	name := "nohup"
	//    XXX currently running as root with -d above
	args := []string{
		"/opt/zededa/bin/dnsmasq",
		"-d",
		"-C",
		cfgPathname,
	}
	logFilename := fmt.Sprintf("dnsmasq.%s", ifname)
	logf, err := agentlog.InitChild(logFilename)
	if err != nil {
		log.Fatalf("startDnsmasq agentlog failed: %s\n", err)
	}
	cmd := exec.Command(name, args...)
	cmd.Stderr = logf
	if debug {
		log.Printf("Calling command %s %v\n", name, args)
	}
	go cmd.Run()
}

//    pkill -u nobody -f dnsmasq.${IFNAME}.conf
func stopDnsmasq(cfgFilename string, printOnError bool) {
	if debug {
		log.Printf("stopDnsmasq: %s\n", cfgFilename)
	}
	// XXX currently running as root with -d above
	pkillUserArgs("root", cfgFilename, printOnError)
}
