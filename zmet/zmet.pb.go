// Code generated by protoc-gen-go. DO NOT EDIT.
// source: zmet.proto

package zmet

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
// Broadly there are two types
// Info : information that is discovered/rarely changes
// Metrics: information that gets updated periodically
// Protobuf definitions in this file follow the convention.
type ZInfoTypes int32

const (
	ZInfoTypes_ZiNop    ZInfoTypes = 0
	ZInfoTypes_ZiDevice ZInfoTypes = 1
	// ZiHypervisor = 2;	// Deprecated
	ZInfoTypes_ZiApp           ZInfoTypes = 3
	ZInfoTypes_ZiService       ZInfoTypes = 4
	ZInfoTypes_ZiNetworkObject ZInfoTypes = 5
)

var ZInfoTypes_name = map[int32]string{
	0: "ZiNop",
	1: "ZiDevice",
	3: "ZiApp",
	4: "ZiService",
	5: "ZiNetworkObject",
}
var ZInfoTypes_value = map[string]int32{
	"ZiNop":           0,
	"ZiDevice":        1,
	"ZiApp":           3,
	"ZiService":       4,
	"ZiNetworkObject": 5,
}

func (x ZInfoTypes) String() string {
	return proto.EnumName(ZInfoTypes_name, int32(x))
}
func (ZInfoTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// Deprecate since we can't determine it on the device
type ZPeripheralTypes int32

const (
	ZPeripheralTypes_ZpNone    ZPeripheralTypes = 0
	ZPeripheralTypes_ZpStorage ZPeripheralTypes = 1
	ZPeripheralTypes_ZpNetwork ZPeripheralTypes = 2
)

var ZPeripheralTypes_name = map[int32]string{
	0: "ZpNone",
	1: "ZpStorage",
	2: "ZpNetwork",
}
var ZPeripheralTypes_value = map[string]int32{
	"ZpNone":    0,
	"ZpStorage": 1,
	"ZpNetwork": 2,
}

func (x ZPeripheralTypes) String() string {
	return proto.EnumName(ZPeripheralTypes_name, int32(x))
}
func (ZPeripheralTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

// Enum names from OMA-TS-LWM2M_SwMgmt-V1_0-20151201-C
type ZSwState int32

const (
	ZSwState_INVALID          ZSwState = 0
	ZSwState_INITIAL          ZSwState = 1
	ZSwState_DOWNLOAD_STARTED ZSwState = 2
	ZSwState_DOWNLOADED       ZSwState = 3
	ZSwState_DELIVERED        ZSwState = 4
	ZSwState_INSTALLED        ZSwState = 5
	ZSwState_BOOTING          ZSwState = 6
	ZSwState_RUNNING          ZSwState = 7
	ZSwState_HALTING          ZSwState = 8
	ZSwState_HALTED           ZSwState = 9
	ZSwState_RESTARTING       ZSwState = 10
	ZSwState_PURGING          ZSwState = 11
)

var ZSwState_name = map[int32]string{
	0:  "INVALID",
	1:  "INITIAL",
	2:  "DOWNLOAD_STARTED",
	3:  "DOWNLOADED",
	4:  "DELIVERED",
	5:  "INSTALLED",
	6:  "BOOTING",
	7:  "RUNNING",
	8:  "HALTING",
	9:  "HALTED",
	10: "RESTARTING",
	11: "PURGING",
}
var ZSwState_value = map[string]int32{
	"INVALID":          0,
	"INITIAL":          1,
	"DOWNLOAD_STARTED": 2,
	"DOWNLOADED":       3,
	"DELIVERED":        4,
	"INSTALLED":        5,
	"BOOTING":          6,
	"RUNNING":          7,
	"HALTING":          8,
	"HALTED":           9,
	"RESTARTING":       10,
	"PURGING":          11,
}

func (x ZSwState) String() string {
	return proto.EnumName(ZSwState_name, int32(x))
}
func (ZSwState) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

// ipSec state information
type ZInfoVpnState int32

const (
	ZInfoVpnState_VPN_INVALID     ZInfoVpnState = 0
	ZInfoVpnState_VPN_INITIAL     ZInfoVpnState = 1
	ZInfoVpnState_VPN_CONNECTING  ZInfoVpnState = 2
	ZInfoVpnState_VPN_ESTABLISHED ZInfoVpnState = 3
	ZInfoVpnState_VPN_INSTALLED   ZInfoVpnState = 4
	ZInfoVpnState_VPN_REKEYED     ZInfoVpnState = 5
	ZInfoVpnState_VPN_DELETED     ZInfoVpnState = 10
)

var ZInfoVpnState_name = map[int32]string{
	0:  "VPN_INVALID",
	1:  "VPN_INITIAL",
	2:  "VPN_CONNECTING",
	3:  "VPN_ESTABLISHED",
	4:  "VPN_INSTALLED",
	5:  "VPN_REKEYED",
	10: "VPN_DELETED",
}
var ZInfoVpnState_value = map[string]int32{
	"VPN_INVALID":     0,
	"VPN_INITIAL":     1,
	"VPN_CONNECTING":  2,
	"VPN_ESTABLISHED": 3,
	"VPN_INSTALLED":   4,
	"VPN_REKEYED":     5,
	"VPN_DELETED":     10,
}

func (x ZInfoVpnState) String() string {
	return proto.EnumName(ZInfoVpnState_name, int32(x))
}
func (ZInfoVpnState) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

// XXX duplicate of definition in appconfig.proto
// Types of I/O adapters that can be assigned to applications
type ZioType int32

const (
	ZioType_ZioNop   ZioType = 0
	ZioType_ZioEth   ZioType = 1
	ZioType_ZioUSB   ZioType = 2
	ZioType_ZioCOM   ZioType = 3
	ZioType_ZioOther ZioType = 255
)

var ZioType_name = map[int32]string{
	0:   "ZioNop",
	1:   "ZioEth",
	2:   "ZioUSB",
	3:   "ZioCOM",
	255: "ZioOther",
}
var ZioType_value = map[string]int32{
	"ZioNop":   0,
	"ZioEth":   1,
	"ZioUSB":   2,
	"ZioCOM":   3,
	"ZioOther": 255,
}

func (x ZioType) String() string {
	return proto.EnumName(ZioType_name, int32(x))
}
func (ZioType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

type ZmetricTypes int32

const (
	ZmetricTypes_ZmNop    ZmetricTypes = 0
	ZmetricTypes_ZmDevice ZmetricTypes = 1
	ZmetricTypes_ZmApp    ZmetricTypes = 3
)

var ZmetricTypes_name = map[int32]string{
	0: "ZmNop",
	1: "ZmDevice",
	3: "ZmApp",
}
var ZmetricTypes_value = map[string]int32{
	"ZmNop":    0,
	"ZmDevice": 1,
	"ZmApp":    3,
}

func (x ZmetricTypes) String() string {
	return proto.EnumName(ZmetricTypes_name, int32(x))
}
func (ZmetricTypes) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

type MetricItemType int32

const (
	MetricItemType_MetricItemOther   MetricItemType = 0
	MetricItemType_MetricItemGauge   MetricItemType = 1
	MetricItemType_MetricItemCounter MetricItemType = 2
	MetricItemType_MetricItemState   MetricItemType = 3
)

var MetricItemType_name = map[int32]string{
	0: "MetricItemOther",
	1: "MetricItemGauge",
	2: "MetricItemCounter",
	3: "MetricItemState",
}
var MetricItemType_value = map[string]int32{
	"MetricItemOther":   0,
	"MetricItemGauge":   1,
	"MetricItemCounter": 2,
	"MetricItemState":   3,
}

func (x MetricItemType) String() string {
	return proto.EnumName(MetricItemType_name, int32(x))
}
func (MetricItemType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

// Manufacturing info, product name, model, version etc.
// From dmidecode/BIOS on Intel
type ZInfoManufacturer struct {
	Manufacturer    string `protobuf:"bytes,1,opt,name=manufacturer" json:"manufacturer,omitempty"`
	ProductName     string `protobuf:"bytes,2,opt,name=productName" json:"productName,omitempty"`
	Version         string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	SerialNumber    string `protobuf:"bytes,4,opt,name=serialNumber" json:"serialNumber,omitempty"`
	UUID            string `protobuf:"bytes,5,opt,name=UUID" json:"UUID,omitempty"`
	Compatible      string `protobuf:"bytes,6,opt,name=compatible" json:"compatible,omitempty"`
	BiosVendor      string `protobuf:"bytes,7,opt,name=biosVendor" json:"biosVendor,omitempty"`
	BiosVersion     string `protobuf:"bytes,8,opt,name=biosVersion" json:"biosVersion,omitempty"`
	BiosReleaseDate string `protobuf:"bytes,9,opt,name=biosReleaseDate" json:"biosReleaseDate,omitempty"`
}

func (m *ZInfoManufacturer) Reset()                    { *m = ZInfoManufacturer{} }
func (m *ZInfoManufacturer) String() string            { return proto.CompactTextString(m) }
func (*ZInfoManufacturer) ProtoMessage()               {}
func (*ZInfoManufacturer) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *ZInfoManufacturer) GetManufacturer() string {
	if m != nil {
		return m.Manufacturer
	}
	return ""
}

func (m *ZInfoManufacturer) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *ZInfoManufacturer) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ZInfoManufacturer) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *ZInfoManufacturer) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *ZInfoManufacturer) GetCompatible() string {
	if m != nil {
		return m.Compatible
	}
	return ""
}

func (m *ZInfoManufacturer) GetBiosVendor() string {
	if m != nil {
		return m.BiosVendor
	}
	return ""
}

func (m *ZInfoManufacturer) GetBiosVersion() string {
	if m != nil {
		return m.BiosVersion
	}
	return ""
}

func (m *ZInfoManufacturer) GetBiosReleaseDate() string {
	if m != nil {
		return m.BiosReleaseDate
	}
	return ""
}

type ZInfoNetwork struct {
	// string IPAddr = 1; // Deprecated. Returning first address for now
	// string gwAddr = 2; // Deprecated; routing is richer than a single gateway
	MacAddr        string     `protobuf:"bytes,3,opt,name=macAddr" json:"macAddr,omitempty"`
	DevName        string     `protobuf:"bytes,4,opt,name=devName" json:"devName,omitempty"`
	IPAddrs        []string   `protobuf:"bytes,5,rep,name=IPAddrs" json:"IPAddrs,omitempty"`
	DefaultRouters []string   `protobuf:"bytes,6,rep,name=defaultRouters" json:"defaultRouters,omitempty"`
	Dns            *ZInfoDNS  `protobuf:"bytes,7,opt,name=dns" json:"dns,omitempty"`
	Up             bool       `protobuf:"varint,8,opt,name=up" json:"up,omitempty"`
	Location       *GeoLoc    `protobuf:"bytes,9,opt,name=location" json:"location,omitempty"`
	Uplink         bool       `protobuf:"varint,10,opt,name=uplink" json:"uplink,omitempty"`
	NetworkErr     *ErrorInfo `protobuf:"bytes,11,opt,name=networkErr" json:"networkErr,omitempty"`
	Name           string     `protobuf:"bytes,12,opt,name=name" json:"name,omitempty"`
}

func (m *ZInfoNetwork) Reset()                    { *m = ZInfoNetwork{} }
func (m *ZInfoNetwork) String() string            { return proto.CompactTextString(m) }
func (*ZInfoNetwork) ProtoMessage()               {}
func (*ZInfoNetwork) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ZInfoNetwork) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func (m *ZInfoNetwork) GetDevName() string {
	if m != nil {
		return m.DevName
	}
	return ""
}

func (m *ZInfoNetwork) GetIPAddrs() []string {
	if m != nil {
		return m.IPAddrs
	}
	return nil
}

func (m *ZInfoNetwork) GetDefaultRouters() []string {
	if m != nil {
		return m.DefaultRouters
	}
	return nil
}

func (m *ZInfoNetwork) GetDns() *ZInfoDNS {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *ZInfoNetwork) GetUp() bool {
	if m != nil {
		return m.Up
	}
	return false
}

func (m *ZInfoNetwork) GetLocation() *GeoLoc {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *ZInfoNetwork) GetUplink() bool {
	if m != nil {
		return m.Uplink
	}
	return false
}

func (m *ZInfoNetwork) GetNetworkErr() *ErrorInfo {
	if m != nil {
		return m.NetworkErr
	}
	return nil
}

func (m *ZInfoNetwork) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// From an IP address-based geolocation service
// XXX later define GPS coordinates from device
type GeoLoc struct {
	UnderlayIP string `protobuf:"bytes,1,opt,name=UnderlayIP" json:"UnderlayIP,omitempty"`
	Hostname   string `protobuf:"bytes,2,opt,name=Hostname" json:"Hostname,omitempty"`
	City       string `protobuf:"bytes,3,opt,name=City" json:"City,omitempty"`
	Region     string `protobuf:"bytes,4,opt,name=Region" json:"Region,omitempty"`
	Country    string `protobuf:"bytes,5,opt,name=Country" json:"Country,omitempty"`
	Loc        string `protobuf:"bytes,6,opt,name=Loc" json:"Loc,omitempty"`
	Org        string `protobuf:"bytes,7,opt,name=Org" json:"Org,omitempty"`
	Postal     string `protobuf:"bytes,8,opt,name=Postal" json:"Postal,omitempty"`
}

func (m *GeoLoc) Reset()                    { *m = GeoLoc{} }
func (m *GeoLoc) String() string            { return proto.CompactTextString(m) }
func (*GeoLoc) ProtoMessage()               {}
func (*GeoLoc) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *GeoLoc) GetUnderlayIP() string {
	if m != nil {
		return m.UnderlayIP
	}
	return ""
}

func (m *GeoLoc) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *GeoLoc) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *GeoLoc) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *GeoLoc) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *GeoLoc) GetLoc() string {
	if m != nil {
		return m.Loc
	}
	return ""
}

func (m *GeoLoc) GetOrg() string {
	if m != nil {
		return m.Org
	}
	return ""
}

func (m *GeoLoc) GetPostal() string {
	if m != nil {
		return m.Postal
	}
	return ""
}

// This is used both to represent the information we receive from DHCP
// for each interface, and the information the device is using
// (from /etc/resolv.conf). The latter could be different than what's received
// from DHCP on all the interfaces
type ZInfoDNS struct {
	DNSservers []string `protobuf:"bytes,1,rep,name=DNSservers" json:"DNSservers,omitempty"`
	DNSdomain  string   `protobuf:"bytes,2,opt,name=DNSdomain" json:"DNSdomain,omitempty"`
	DNSsearch  []string `protobuf:"bytes,3,rep,name=DNSsearch" json:"DNSsearch,omitempty"`
}

func (m *ZInfoDNS) Reset()                    { *m = ZInfoDNS{} }
func (m *ZInfoDNS) String() string            { return proto.CompactTextString(m) }
func (*ZInfoDNS) ProtoMessage()               {}
func (*ZInfoDNS) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *ZInfoDNS) GetDNSservers() []string {
	if m != nil {
		return m.DNSservers
	}
	return nil
}

func (m *ZInfoDNS) GetDNSdomain() string {
	if m != nil {
		return m.DNSdomain
	}
	return ""
}

func (m *ZInfoDNS) GetDNSsearch() []string {
	if m != nil {
		return m.DNSsearch
	}
	return nil
}

// Deprecate since we can't determine it on the device
type ZinfoPeripheral struct {
	Ztype     ZPeripheralTypes   `protobuf:"varint,1,opt,name=ztype,enum=ZPeripheralTypes" json:"ztype,omitempty"`
	Pluggable bool               `protobuf:"varint,2,opt,name=pluggable" json:"pluggable,omitempty"`
	Minfo     *ZInfoManufacturer `protobuf:"bytes,3,opt,name=minfo" json:"minfo,omitempty"`
}

func (m *ZinfoPeripheral) Reset()                    { *m = ZinfoPeripheral{} }
func (m *ZinfoPeripheral) String() string            { return proto.CompactTextString(m) }
func (*ZinfoPeripheral) ProtoMessage()               {}
func (*ZinfoPeripheral) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *ZinfoPeripheral) GetZtype() ZPeripheralTypes {
	if m != nil {
		return m.Ztype
	}
	return ZPeripheralTypes_ZpNone
}

func (m *ZinfoPeripheral) GetPluggable() bool {
	if m != nil {
		return m.Pluggable
	}
	return false
}

func (m *ZinfoPeripheral) GetMinfo() *ZInfoManufacturer {
	if m != nil {
		return m.Minfo
	}
	return nil
}

// SW Info for Apps
type ZInfoSW struct {
	SwVersion        string   `protobuf:"bytes,2,opt,name=swVersion" json:"swVersion,omitempty"`
	SwHash           string   `protobuf:"bytes,3,opt,name=swHash" json:"swHash,omitempty"`
	State            ZSwState `protobuf:"varint,4,opt,name=state,enum=ZSwState" json:"state,omitempty"`
	Target           string   `protobuf:"bytes,6,opt,name=target" json:"target,omitempty"`
	Vdev             string   `protobuf:"bytes,7,opt,name=vdev" json:"vdev,omitempty"`
	DownloadProgress uint32   `protobuf:"varint,8,opt,name=downloadProgress" json:"downloadProgress,omitempty"`
	ImageName        string   `protobuf:"bytes,9,opt,name=imageName" json:"imageName,omitempty"`
}

func (m *ZInfoSW) Reset()                    { *m = ZInfoSW{} }
func (m *ZInfoSW) String() string            { return proto.CompactTextString(m) }
func (*ZInfoSW) ProtoMessage()               {}
func (*ZInfoSW) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *ZInfoSW) GetSwVersion() string {
	if m != nil {
		return m.SwVersion
	}
	return ""
}

func (m *ZInfoSW) GetSwHash() string {
	if m != nil {
		return m.SwHash
	}
	return ""
}

func (m *ZInfoSW) GetState() ZSwState {
	if m != nil {
		return m.State
	}
	return ZSwState_INVALID
}

func (m *ZInfoSW) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *ZInfoSW) GetVdev() string {
	if m != nil {
		return m.Vdev
	}
	return ""
}

func (m *ZInfoSW) GetDownloadProgress() uint32 {
	if m != nil {
		return m.DownloadProgress
	}
	return 0
}

func (m *ZInfoSW) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

// Errors in response to the applicatioan of configuration
type ErrorInfo struct {
	Description string                     `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	Timestamp   *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *ErrorInfo) Reset()                    { *m = ErrorInfo{} }
func (m *ErrorInfo) String() string            { return proto.CompactTextString(m) }
func (*ErrorInfo) ProtoMessage()               {}
func (*ErrorInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *ErrorInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ErrorInfo) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// Base device info, as discovered by Xen (or OS on bare metal)
type ZInfoDevice struct {
	MachineArch        string                     `protobuf:"bytes,4,opt,name=machineArch" json:"machineArch,omitempty"`
	CpuArch            string                     `protobuf:"bytes,5,opt,name=cpuArch" json:"cpuArch,omitempty"`
	Platform           string                     `protobuf:"bytes,6,opt,name=platform" json:"platform,omitempty"`
	Ncpu               uint32                     `protobuf:"varint,7,opt,name=ncpu" json:"ncpu,omitempty"`
	Memory             uint64                     `protobuf:"varint,8,opt,name=memory" json:"memory,omitempty"`
	Storage            uint64                     `protobuf:"varint,9,opt,name=storage" json:"storage,omitempty"`
	Minfo              *ZInfoManufacturer         `protobuf:"bytes,11,opt,name=minfo" json:"minfo,omitempty"`
	Network            []*ZInfoNetwork            `protobuf:"bytes,13,rep,name=network" json:"network,omitempty"`
	AssignableAdapters []*ZioBundle               `protobuf:"bytes,15,rep,name=assignableAdapters" json:"assignableAdapters,omitempty"`
	Dns                *ZInfoDNS                  `protobuf:"bytes,16,opt,name=dns" json:"dns,omitempty"`
	StorageList        []*ZInfoStorage            `protobuf:"bytes,17,rep,name=storageList" json:"storageList,omitempty"`
	BootTime           *google_protobuf.Timestamp `protobuf:"bytes,18,opt,name=bootTime" json:"bootTime,omitempty"`
	SwList             []*ZInfoDevSW              `protobuf:"bytes,19,rep,name=swList" json:"swList,omitempty"`
	HostName           string                     `protobuf:"bytes,20,opt,name=HostName" json:"HostName,omitempty"`
	MetricItems        []*MetricItem              `protobuf:"bytes,21,rep,name=metricItems" json:"metricItems,omitempty"`
}

func (m *ZInfoDevice) Reset()                    { *m = ZInfoDevice{} }
func (m *ZInfoDevice) String() string            { return proto.CompactTextString(m) }
func (*ZInfoDevice) ProtoMessage()               {}
func (*ZInfoDevice) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *ZInfoDevice) GetMachineArch() string {
	if m != nil {
		return m.MachineArch
	}
	return ""
}

func (m *ZInfoDevice) GetCpuArch() string {
	if m != nil {
		return m.CpuArch
	}
	return ""
}

func (m *ZInfoDevice) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *ZInfoDevice) GetNcpu() uint32 {
	if m != nil {
		return m.Ncpu
	}
	return 0
}

func (m *ZInfoDevice) GetMemory() uint64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ZInfoDevice) GetStorage() uint64 {
	if m != nil {
		return m.Storage
	}
	return 0
}

func (m *ZInfoDevice) GetMinfo() *ZInfoManufacturer {
	if m != nil {
		return m.Minfo
	}
	return nil
}

func (m *ZInfoDevice) GetNetwork() []*ZInfoNetwork {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *ZInfoDevice) GetAssignableAdapters() []*ZioBundle {
	if m != nil {
		return m.AssignableAdapters
	}
	return nil
}

func (m *ZInfoDevice) GetDns() *ZInfoDNS {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *ZInfoDevice) GetStorageList() []*ZInfoStorage {
	if m != nil {
		return m.StorageList
	}
	return nil
}

func (m *ZInfoDevice) GetBootTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.BootTime
	}
	return nil
}

func (m *ZInfoDevice) GetSwList() []*ZInfoDevSW {
	if m != nil {
		return m.SwList
	}
	return nil
}

func (m *ZInfoDevice) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *ZInfoDevice) GetMetricItems() []*MetricItem {
	if m != nil {
		return m.MetricItems
	}
	return nil
}

// SW Info for the device base OS
type ZInfoDevSW struct {
	Activated        bool       `protobuf:"varint,2,opt,name=activated" json:"activated,omitempty"`
	PartitionLabel   string     `protobuf:"bytes,3,opt,name=partitionLabel" json:"partitionLabel,omitempty"`
	PartitionDevice  string     `protobuf:"bytes,4,opt,name=partitionDevice" json:"partitionDevice,omitempty"`
	PartitionState   string     `protobuf:"bytes,5,opt,name=partitionState" json:"partitionState,omitempty"`
	Status           ZSwState   `protobuf:"varint,6,opt,name=status,enum=ZSwState" json:"status,omitempty"`
	ShortVersion     string     `protobuf:"bytes,7,opt,name=shortVersion" json:"shortVersion,omitempty"`
	LongVersion      string     `protobuf:"bytes,8,opt,name=longVersion" json:"longVersion,omitempty"`
	SwErr            *ErrorInfo `protobuf:"bytes,9,opt,name=swErr" json:"swErr,omitempty"`
	DownloadProgress uint32     `protobuf:"varint,10,opt,name=downloadProgress" json:"downloadProgress,omitempty"`
}

func (m *ZInfoDevSW) Reset()                    { *m = ZInfoDevSW{} }
func (m *ZInfoDevSW) String() string            { return proto.CompactTextString(m) }
func (*ZInfoDevSW) ProtoMessage()               {}
func (*ZInfoDevSW) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *ZInfoDevSW) GetActivated() bool {
	if m != nil {
		return m.Activated
	}
	return false
}

func (m *ZInfoDevSW) GetPartitionLabel() string {
	if m != nil {
		return m.PartitionLabel
	}
	return ""
}

func (m *ZInfoDevSW) GetPartitionDevice() string {
	if m != nil {
		return m.PartitionDevice
	}
	return ""
}

func (m *ZInfoDevSW) GetPartitionState() string {
	if m != nil {
		return m.PartitionState
	}
	return ""
}

func (m *ZInfoDevSW) GetStatus() ZSwState {
	if m != nil {
		return m.Status
	}
	return ZSwState_INVALID
}

func (m *ZInfoDevSW) GetShortVersion() string {
	if m != nil {
		return m.ShortVersion
	}
	return ""
}

func (m *ZInfoDevSW) GetLongVersion() string {
	if m != nil {
		return m.LongVersion
	}
	return ""
}

func (m *ZInfoDevSW) GetSwErr() *ErrorInfo {
	if m != nil {
		return m.SwErr
	}
	return nil
}

func (m *ZInfoDevSW) GetDownloadProgress() uint32 {
	if m != nil {
		return m.DownloadProgress
	}
	return 0
}

// Per filesystem/partition information
type ZInfoStorage struct {
	Device          string `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	MountPath       string `protobuf:"bytes,2,opt,name=mountPath" json:"mountPath,omitempty"`
	Total           uint64 `protobuf:"varint,3,opt,name=total" json:"total,omitempty"`
	StorageLocation bool   `protobuf:"varint,4,opt,name=storageLocation" json:"storageLocation,omitempty"`
}

func (m *ZInfoStorage) Reset()                    { *m = ZInfoStorage{} }
func (m *ZInfoStorage) String() string            { return proto.CompactTextString(m) }
func (*ZInfoStorage) ProtoMessage()               {}
func (*ZInfoStorage) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *ZInfoStorage) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *ZInfoStorage) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *ZInfoStorage) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ZInfoStorage) GetStorageLocation() bool {
	if m != nil {
		return m.StorageLocation
	}
	return false
}

type ZInfoApp struct {
	AppID            string                     `protobuf:"bytes,1,opt,name=AppID" json:"AppID,omitempty"`
	SystemApp        bool                       `protobuf:"varint,6,opt,name=systemApp" json:"systemApp,omitempty"`
	AppName          string                     `protobuf:"bytes,7,opt,name=AppName" json:"AppName,omitempty"`
	SoftwareList     []*ZInfoSW                 `protobuf:"bytes,8,rep,name=softwareList" json:"softwareList,omitempty"`
	BootTime         *google_protobuf.Timestamp `protobuf:"bytes,12,opt,name=bootTime" json:"bootTime,omitempty"`
	AssignedAdapters []*ZioBundle               `protobuf:"bytes,13,rep,name=assignedAdapters" json:"assignedAdapters,omitempty"`
	AppErr           []*ErrorInfo               `protobuf:"bytes,14,rep,name=appErr" json:"appErr,omitempty"`
	State            ZSwState                   `protobuf:"varint,15,opt,name=state,enum=ZSwState" json:"state,omitempty"`
	Network          []*ZInfoNetwork            `protobuf:"bytes,16,rep,name=network" json:"network,omitempty"`
}

func (m *ZInfoApp) Reset()                    { *m = ZInfoApp{} }
func (m *ZInfoApp) String() string            { return proto.CompactTextString(m) }
func (*ZInfoApp) ProtoMessage()               {}
func (*ZInfoApp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *ZInfoApp) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *ZInfoApp) GetSystemApp() bool {
	if m != nil {
		return m.SystemApp
	}
	return false
}

func (m *ZInfoApp) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *ZInfoApp) GetSoftwareList() []*ZInfoSW {
	if m != nil {
		return m.SoftwareList
	}
	return nil
}

func (m *ZInfoApp) GetBootTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.BootTime
	}
	return nil
}

func (m *ZInfoApp) GetAssignedAdapters() []*ZioBundle {
	if m != nil {
		return m.AssignedAdapters
	}
	return nil
}

func (m *ZInfoApp) GetAppErr() []*ErrorInfo {
	if m != nil {
		return m.AppErr
	}
	return nil
}

func (m *ZInfoApp) GetState() ZSwState {
	if m != nil {
		return m.State
	}
	return ZSwState_INVALID
}

func (m *ZInfoApp) GetNetwork() []*ZInfoNetwork {
	if m != nil {
		return m.Network
	}
	return nil
}

// tunnel link details
type ZInfoVpnLinkInfo struct {
	SpiId     string `protobuf:"bytes,1,opt,name=spiId" json:"spiId,omitempty"`
	SubNet    string `protobuf:"bytes,2,opt,name=subNet" json:"subNet,omitempty"`
	Direction bool   `protobuf:"varint,3,opt,name=direction" json:"direction,omitempty"`
}

func (m *ZInfoVpnLinkInfo) Reset()                    { *m = ZInfoVpnLinkInfo{} }
func (m *ZInfoVpnLinkInfo) String() string            { return proto.CompactTextString(m) }
func (*ZInfoVpnLinkInfo) ProtoMessage()               {}
func (*ZInfoVpnLinkInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *ZInfoVpnLinkInfo) GetSpiId() string {
	if m != nil {
		return m.SpiId
	}
	return ""
}

func (m *ZInfoVpnLinkInfo) GetSubNet() string {
	if m != nil {
		return m.SubNet
	}
	return ""
}

func (m *ZInfoVpnLinkInfo) GetDirection() bool {
	if m != nil {
		return m.Direction
	}
	return false
}

// Esp details
type ZInfoVpnLink struct {
	Id       string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name     string            `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	ReqId    string            `protobuf:"bytes,3,opt,name=reqId" json:"reqId,omitempty"`
	InstTime uint64            `protobuf:"varint,4,opt,name=instTime" json:"instTime,omitempty"`
	EspInfo  string            `protobuf:"bytes,5,opt,name=espInfo" json:"espInfo,omitempty"`
	State    ZInfoVpnState     `protobuf:"varint,6,opt,name=state,enum=ZInfoVpnState" json:"state,omitempty"`
	LInfo    *ZInfoVpnLinkInfo `protobuf:"bytes,10,opt,name=lInfo" json:"lInfo,omitempty"`
	RInfo    *ZInfoVpnLinkInfo `protobuf:"bytes,11,opt,name=rInfo" json:"rInfo,omitempty"`
}

func (m *ZInfoVpnLink) Reset()                    { *m = ZInfoVpnLink{} }
func (m *ZInfoVpnLink) String() string            { return proto.CompactTextString(m) }
func (*ZInfoVpnLink) ProtoMessage()               {}
func (*ZInfoVpnLink) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

func (m *ZInfoVpnLink) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ZInfoVpnLink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ZInfoVpnLink) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *ZInfoVpnLink) GetInstTime() uint64 {
	if m != nil {
		return m.InstTime
	}
	return 0
}

func (m *ZInfoVpnLink) GetEspInfo() string {
	if m != nil {
		return m.EspInfo
	}
	return ""
}

func (m *ZInfoVpnLink) GetState() ZInfoVpnState {
	if m != nil {
		return m.State
	}
	return ZInfoVpnState_VPN_INVALID
}

func (m *ZInfoVpnLink) GetLInfo() *ZInfoVpnLinkInfo {
	if m != nil {
		return m.LInfo
	}
	return nil
}

func (m *ZInfoVpnLink) GetRInfo() *ZInfoVpnLinkInfo {
	if m != nil {
		return m.RInfo
	}
	return nil
}

// ipsec left/right end-point info
type ZInfoVpnEndPoint struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	IpAddr string `protobuf:"bytes,2,opt,name=ipAddr" json:"ipAddr,omitempty"`
	Port   uint32 `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
}

func (m *ZInfoVpnEndPoint) Reset()                    { *m = ZInfoVpnEndPoint{} }
func (m *ZInfoVpnEndPoint) String() string            { return proto.CompactTextString(m) }
func (*ZInfoVpnEndPoint) ProtoMessage()               {}
func (*ZInfoVpnEndPoint) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

func (m *ZInfoVpnEndPoint) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ZInfoVpnEndPoint) GetIpAddr() string {
	if m != nil {
		return m.IpAddr
	}
	return ""
}

func (m *ZInfoVpnEndPoint) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// Ike details
type ZInfoVpnConn struct {
	Id      string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name    string            `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string            `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	EstTime uint64            `protobuf:"varint,4,opt,name=estTime" json:"estTime,omitempty"`
	Ikes    string            `protobuf:"bytes,5,opt,name=ikes" json:"ikes,omitempty"`
	State   ZInfoVpnState     `protobuf:"varint,6,opt,name=state,enum=ZInfoVpnState" json:"state,omitempty"`
	LInfo   *ZInfoVpnEndPoint `protobuf:"bytes,7,opt,name=lInfo" json:"lInfo,omitempty"`
	RInfo   *ZInfoVpnEndPoint `protobuf:"bytes,8,opt,name=rInfo" json:"rInfo,omitempty"`
	Links   []*ZInfoVpnLink   `protobuf:"bytes,10,rep,name=links" json:"links,omitempty"`
}

func (m *ZInfoVpnConn) Reset()                    { *m = ZInfoVpnConn{} }
func (m *ZInfoVpnConn) String() string            { return proto.CompactTextString(m) }
func (*ZInfoVpnConn) ProtoMessage()               {}
func (*ZInfoVpnConn) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

func (m *ZInfoVpnConn) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ZInfoVpnConn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ZInfoVpnConn) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ZInfoVpnConn) GetEstTime() uint64 {
	if m != nil {
		return m.EstTime
	}
	return 0
}

func (m *ZInfoVpnConn) GetIkes() string {
	if m != nil {
		return m.Ikes
	}
	return ""
}

func (m *ZInfoVpnConn) GetState() ZInfoVpnState {
	if m != nil {
		return m.State
	}
	return ZInfoVpnState_VPN_INVALID
}

func (m *ZInfoVpnConn) GetLInfo() *ZInfoVpnEndPoint {
	if m != nil {
		return m.LInfo
	}
	return nil
}

func (m *ZInfoVpnConn) GetRInfo() *ZInfoVpnEndPoint {
	if m != nil {
		return m.RInfo
	}
	return nil
}

func (m *ZInfoVpnConn) GetLinks() []*ZInfoVpnLink {
	if m != nil {
		return m.Links
	}
	return nil
}

// ipsec level information
type ZInfoVpn struct {
	UpTime           uint64          `protobuf:"varint,1,opt,name=upTime" json:"upTime,omitempty"`
	PolicyBased      bool            `protobuf:"varint,2,opt,name=policyBased" json:"policyBased,omitempty"`
	ListeningIpAddrs []string        `protobuf:"bytes,3,rep,name=listeningIpAddrs" json:"listeningIpAddrs,omitempty"`
	Conn             []*ZInfoVpnConn `protobuf:"bytes,10,rep,name=conn" json:"conn,omitempty"`
}

func (m *ZInfoVpn) Reset()                    { *m = ZInfoVpn{} }
func (m *ZInfoVpn) String() string            { return proto.CompactTextString(m) }
func (*ZInfoVpn) ProtoMessage()               {}
func (*ZInfoVpn) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *ZInfoVpn) GetUpTime() uint64 {
	if m != nil {
		return m.UpTime
	}
	return 0
}

func (m *ZInfoVpn) GetPolicyBased() bool {
	if m != nil {
		return m.PolicyBased
	}
	return false
}

func (m *ZInfoVpn) GetListeningIpAddrs() []string {
	if m != nil {
		return m.ListeningIpAddrs
	}
	return nil
}

func (m *ZInfoVpn) GetConn() []*ZInfoVpnConn {
	if m != nil {
		return m.Conn
	}
	return nil
}

// Lisp state information
type RlocState struct {
	Rloc      string `protobuf:"bytes,1,opt,name=Rloc" json:"Rloc,omitempty"`
	Reachable bool   `protobuf:"varint,2,opt,name=Reachable" json:"Reachable,omitempty"`
}

func (m *RlocState) Reset()                    { *m = RlocState{} }
func (m *RlocState) String() string            { return proto.CompactTextString(m) }
func (*RlocState) ProtoMessage()               {}
func (*RlocState) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{16} }

func (m *RlocState) GetRloc() string {
	if m != nil {
		return m.Rloc
	}
	return ""
}

func (m *RlocState) GetReachable() bool {
	if m != nil {
		return m.Reachable
	}
	return false
}

type MapCacheEntry struct {
	EID   string       `protobuf:"bytes,1,opt,name=EID" json:"EID,omitempty"`
	Rlocs []*RlocState `protobuf:"bytes,2,rep,name=Rlocs" json:"Rlocs,omitempty"`
}

func (m *MapCacheEntry) Reset()                    { *m = MapCacheEntry{} }
func (m *MapCacheEntry) String() string            { return proto.CompactTextString(m) }
func (*MapCacheEntry) ProtoMessage()               {}
func (*MapCacheEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{17} }

func (m *MapCacheEntry) GetEID() string {
	if m != nil {
		return m.EID
	}
	return ""
}

func (m *MapCacheEntry) GetRlocs() []*RlocState {
	if m != nil {
		return m.Rlocs
	}
	return nil
}

type DatabaseMap struct {
	IID             uint64           `protobuf:"varint,1,opt,name=IID" json:"IID,omitempty"`
	MapCacheEntries []*MapCacheEntry `protobuf:"bytes,2,rep,name=MapCacheEntries" json:"MapCacheEntries,omitempty"`
}

func (m *DatabaseMap) Reset()                    { *m = DatabaseMap{} }
func (m *DatabaseMap) String() string            { return proto.CompactTextString(m) }
func (*DatabaseMap) ProtoMessage()               {}
func (*DatabaseMap) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18} }

func (m *DatabaseMap) GetIID() uint64 {
	if m != nil {
		return m.IID
	}
	return 0
}

func (m *DatabaseMap) GetMapCacheEntries() []*MapCacheEntry {
	if m != nil {
		return m.MapCacheEntries
	}
	return nil
}

type DecapKey struct {
	Rloc     string `protobuf:"bytes,1,opt,name=Rloc" json:"Rloc,omitempty"`
	Port     uint64 `protobuf:"varint,2,opt,name=Port" json:"Port,omitempty"`
	KeyCount uint64 `protobuf:"varint,3,opt,name=KeyCount" json:"KeyCount,omitempty"`
}

func (m *DecapKey) Reset()                    { *m = DecapKey{} }
func (m *DecapKey) String() string            { return proto.CompactTextString(m) }
func (*DecapKey) ProtoMessage()               {}
func (*DecapKey) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{19} }

func (m *DecapKey) GetRloc() string {
	if m != nil {
		return m.Rloc
	}
	return ""
}

func (m *DecapKey) GetPort() uint64 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DecapKey) GetKeyCount() uint64 {
	if m != nil {
		return m.KeyCount
	}
	return 0
}

type ZInfoLisp struct {
	ItrCryptoPort uint64         `protobuf:"varint,1,opt,name=ItrCryptoPort" json:"ItrCryptoPort,omitempty"`
	EtrNatPort    uint64         `protobuf:"varint,2,opt,name=EtrNatPort" json:"EtrNatPort,omitempty"`
	Interfaces    []string       `protobuf:"bytes,3,rep,name=Interfaces" json:"Interfaces,omitempty"`
	DatabaseMaps  []*DatabaseMap `protobuf:"bytes,4,rep,name=DatabaseMaps" json:"DatabaseMaps,omitempty"`
	DecapKeys     []*DecapKey    `protobuf:"bytes,5,rep,name=DecapKeys" json:"DecapKeys,omitempty"`
}

func (m *ZInfoLisp) Reset()                    { *m = ZInfoLisp{} }
func (m *ZInfoLisp) String() string            { return proto.CompactTextString(m) }
func (*ZInfoLisp) ProtoMessage()               {}
func (*ZInfoLisp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{20} }

func (m *ZInfoLisp) GetItrCryptoPort() uint64 {
	if m != nil {
		return m.ItrCryptoPort
	}
	return 0
}

func (m *ZInfoLisp) GetEtrNatPort() uint64 {
	if m != nil {
		return m.EtrNatPort
	}
	return 0
}

func (m *ZInfoLisp) GetInterfaces() []string {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *ZInfoLisp) GetDatabaseMaps() []*DatabaseMap {
	if m != nil {
		return m.DatabaseMaps
	}
	return nil
}

func (m *ZInfoLisp) GetDecapKeys() []*DecapKey {
	if m != nil {
		return m.DecapKeys
	}
	return nil
}

// Service instance state information
type ZInfoService struct {
	ServiceID        string                     `protobuf:"bytes,1,opt,name=serviceID" json:"serviceID,omitempty"`
	ServiceName      string                     `protobuf:"bytes,2,opt,name=serviceName" json:"serviceName,omitempty"`
	ServiceType      uint32                     `protobuf:"varint,3,opt,name=serviceType" json:"serviceType,omitempty"`
	SoftwareList     *ZInfoSW                   `protobuf:"bytes,4,opt,name=softwareList" json:"softwareList,omitempty"`
	Activated        bool                       `protobuf:"varint,5,opt,name=activated" json:"activated,omitempty"`
	UpTimeStamp      *google_protobuf.Timestamp `protobuf:"bytes,6,opt,name=upTimeStamp" json:"upTimeStamp,omitempty"`
	AssignedAdapters []*ZioBundle               `protobuf:"bytes,7,rep,name=assignedAdapters" json:"assignedAdapters,omitempty"`
	SvcErr           []*ErrorInfo               `protobuf:"bytes,8,rep,name=svcErr" json:"svcErr,omitempty"`
	Network          []*ZInfoNetwork            `protobuf:"bytes,9,rep,name=network" json:"network,omitempty"`
	// Types that are valid to be assigned to InfoContent:
	//	*ZInfoService_Vinfo
	//	*ZInfoService_Linfo
	InfoContent isZInfoService_InfoContent `protobuf_oneof:"InfoContent"`
}

func (m *ZInfoService) Reset()                    { *m = ZInfoService{} }
func (m *ZInfoService) String() string            { return proto.CompactTextString(m) }
func (*ZInfoService) ProtoMessage()               {}
func (*ZInfoService) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{21} }

type isZInfoService_InfoContent interface {
	isZInfoService_InfoContent()
}

type ZInfoService_Vinfo struct {
	Vinfo *ZInfoVpn `protobuf:"bytes,20,opt,name=vinfo,oneof"`
}
type ZInfoService_Linfo struct {
	Linfo *ZInfoLisp `protobuf:"bytes,21,opt,name=linfo,oneof"`
}

func (*ZInfoService_Vinfo) isZInfoService_InfoContent() {}
func (*ZInfoService_Linfo) isZInfoService_InfoContent() {}

func (m *ZInfoService) GetInfoContent() isZInfoService_InfoContent {
	if m != nil {
		return m.InfoContent
	}
	return nil
}

func (m *ZInfoService) GetServiceID() string {
	if m != nil {
		return m.ServiceID
	}
	return ""
}

func (m *ZInfoService) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *ZInfoService) GetServiceType() uint32 {
	if m != nil {
		return m.ServiceType
	}
	return 0
}

func (m *ZInfoService) GetSoftwareList() *ZInfoSW {
	if m != nil {
		return m.SoftwareList
	}
	return nil
}

func (m *ZInfoService) GetActivated() bool {
	if m != nil {
		return m.Activated
	}
	return false
}

func (m *ZInfoService) GetUpTimeStamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpTimeStamp
	}
	return nil
}

func (m *ZInfoService) GetAssignedAdapters() []*ZioBundle {
	if m != nil {
		return m.AssignedAdapters
	}
	return nil
}

func (m *ZInfoService) GetSvcErr() []*ErrorInfo {
	if m != nil {
		return m.SvcErr
	}
	return nil
}

func (m *ZInfoService) GetNetwork() []*ZInfoNetwork {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *ZInfoService) GetVinfo() *ZInfoVpn {
	if x, ok := m.GetInfoContent().(*ZInfoService_Vinfo); ok {
		return x.Vinfo
	}
	return nil
}

func (m *ZInfoService) GetLinfo() *ZInfoLisp {
	if x, ok := m.GetInfoContent().(*ZInfoService_Linfo); ok {
		return x.Linfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZInfoService) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZInfoService_OneofMarshaler, _ZInfoService_OneofUnmarshaler, _ZInfoService_OneofSizer, []interface{}{
		(*ZInfoService_Vinfo)(nil),
		(*ZInfoService_Linfo)(nil),
	}
}

func _ZInfoService_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZInfoService)
	// InfoContent
	switch x := m.InfoContent.(type) {
	case *ZInfoService_Vinfo:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vinfo); err != nil {
			return err
		}
	case *ZInfoService_Linfo:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Linfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ZInfoService.InfoContent has unexpected type %T", x)
	}
	return nil
}

func _ZInfoService_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZInfoService)
	switch tag {
	case 20: // InfoContent.vinfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoVpn)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoService_Vinfo{msg}
		return true, err
	case 21: // InfoContent.linfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoLisp)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoService_Linfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ZInfoService_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZInfoService)
	// InfoContent
	switch x := m.InfoContent.(type) {
	case *ZInfoService_Vinfo:
		s := proto.Size(x.Vinfo)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ZInfoService_Linfo:
		s := proto.Size(x.Linfo)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Network Object information
type ZInfoNetworkObject struct {
	NetworkID string `protobuf:"bytes,1,opt,name=networkID" json:"networkID,omitempty"`
	// From NetworkObjectConfig; do we need to include all of these?
	NetworkType   uint32   `protobuf:"varint,2,opt,name=networkType" json:"networkType,omitempty"`
	DhcpType      uint32   `protobuf:"varint,3,opt,name=dhcpType" json:"dhcpType,omitempty"`
	Subnet        string   `protobuf:"bytes,4,opt,name=subnet" json:"subnet,omitempty"`
	Gateway       string   `protobuf:"bytes,5,opt,name=gateway" json:"gateway,omitempty"`
	Domainname    string   `protobuf:"bytes,6,opt,name=domainname" json:"domainname,omitempty"`
	NtpServer     string   `protobuf:"bytes,7,opt,name=ntpServer" json:"ntpServer,omitempty"`
	DnsServers    []string `protobuf:"bytes,8,rep,name=dnsServers" json:"dnsServers,omitempty"`
	DhcpRangeLow  string   `protobuf:"bytes,9,opt,name=dhcpRangeLow" json:"dhcpRangeLow,omitempty"`
	DhcpRangeHigh string   `protobuf:"bytes,10,opt,name=dhcpRangeHigh" json:"dhcpRangeHigh,omitempty"`
	// From NetworkObjectStatus
	BridgeNum     uint32                   `protobuf:"varint,12,opt,name=bridgeNum" json:"bridgeNum,omitempty"`
	BridgeName    string                   `protobuf:"bytes,13,opt,name=bridgeName" json:"bridgeName,omitempty"`
	BridgeIPAddr  string                   `protobuf:"bytes,14,opt,name=bridgeIPAddr" json:"bridgeIPAddr,omitempty"`
	IpAssignments []*ZmetIPAssignmentEntry `protobuf:"bytes,15,rep,name=ipAssignments" json:"ipAssignments,omitempty"`
	BridgeIPSets  []string                 `protobuf:"bytes,16,rep,name=bridgeIPSets" json:"bridgeIPSets,omitempty"`
	VifNames      []string                 `protobuf:"bytes,17,rep,name=vifNames" json:"vifNames,omitempty"`
	Ipv4Eid       bool                     `protobuf:"varint,18,opt,name=ipv4Eid" json:"ipv4Eid,omitempty"`
	NetworkErr    []*ErrorInfo             `protobuf:"bytes,19,rep,name=networkErr" json:"networkErr,omitempty"`
}

func (m *ZInfoNetworkObject) Reset()                    { *m = ZInfoNetworkObject{} }
func (m *ZInfoNetworkObject) String() string            { return proto.CompactTextString(m) }
func (*ZInfoNetworkObject) ProtoMessage()               {}
func (*ZInfoNetworkObject) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{22} }

func (m *ZInfoNetworkObject) GetNetworkID() string {
	if m != nil {
		return m.NetworkID
	}
	return ""
}

func (m *ZInfoNetworkObject) GetNetworkType() uint32 {
	if m != nil {
		return m.NetworkType
	}
	return 0
}

func (m *ZInfoNetworkObject) GetDhcpType() uint32 {
	if m != nil {
		return m.DhcpType
	}
	return 0
}

func (m *ZInfoNetworkObject) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *ZInfoNetworkObject) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *ZInfoNetworkObject) GetDomainname() string {
	if m != nil {
		return m.Domainname
	}
	return ""
}

func (m *ZInfoNetworkObject) GetNtpServer() string {
	if m != nil {
		return m.NtpServer
	}
	return ""
}

func (m *ZInfoNetworkObject) GetDnsServers() []string {
	if m != nil {
		return m.DnsServers
	}
	return nil
}

func (m *ZInfoNetworkObject) GetDhcpRangeLow() string {
	if m != nil {
		return m.DhcpRangeLow
	}
	return ""
}

func (m *ZInfoNetworkObject) GetDhcpRangeHigh() string {
	if m != nil {
		return m.DhcpRangeHigh
	}
	return ""
}

func (m *ZInfoNetworkObject) GetBridgeNum() uint32 {
	if m != nil {
		return m.BridgeNum
	}
	return 0
}

func (m *ZInfoNetworkObject) GetBridgeName() string {
	if m != nil {
		return m.BridgeName
	}
	return ""
}

func (m *ZInfoNetworkObject) GetBridgeIPAddr() string {
	if m != nil {
		return m.BridgeIPAddr
	}
	return ""
}

func (m *ZInfoNetworkObject) GetIpAssignments() []*ZmetIPAssignmentEntry {
	if m != nil {
		return m.IpAssignments
	}
	return nil
}

func (m *ZInfoNetworkObject) GetBridgeIPSets() []string {
	if m != nil {
		return m.BridgeIPSets
	}
	return nil
}

func (m *ZInfoNetworkObject) GetVifNames() []string {
	if m != nil {
		return m.VifNames
	}
	return nil
}

func (m *ZInfoNetworkObject) GetIpv4Eid() bool {
	if m != nil {
		return m.Ipv4Eid
	}
	return false
}

func (m *ZInfoNetworkObject) GetNetworkErr() []*ErrorInfo {
	if m != nil {
		return m.NetworkErr
	}
	return nil
}

// Map from MAC to IP addresses
type ZmetIPAssignmentEntry struct {
	MacAddress string   `protobuf:"bytes,1,opt,name=macAddress" json:"macAddress,omitempty"`
	IpAddress  []string `protobuf:"bytes,2,rep,name=ipAddress" json:"ipAddress,omitempty"`
}

func (m *ZmetIPAssignmentEntry) Reset()                    { *m = ZmetIPAssignmentEntry{} }
func (m *ZmetIPAssignmentEntry) String() string            { return proto.CompactTextString(m) }
func (*ZmetIPAssignmentEntry) ProtoMessage()               {}
func (*ZmetIPAssignmentEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{23} }

func (m *ZmetIPAssignmentEntry) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *ZmetIPAssignmentEntry) GetIpAddress() []string {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

type ZInfoMsg struct {
	Ztype ZInfoTypes `protobuf:"varint,1,opt,name=ztype,enum=ZInfoTypes" json:"ztype,omitempty"`
	DevId string     `protobuf:"bytes,2,opt,name=devId" json:"devId,omitempty"`
	// Types that are valid to be assigned to InfoContent:
	//	*ZInfoMsg_Dinfo
	//	*ZInfoMsg_Ainfo
	//	*ZInfoMsg_Sinfo
	//	*ZInfoMsg_Ninfo
	InfoContent isZInfoMsg_InfoContent     `protobuf_oneof:"InfoContent"`
	AtTimeStamp *google_protobuf.Timestamp `protobuf:"bytes,6,opt,name=atTimeStamp" json:"atTimeStamp,omitempty"`
}

func (m *ZInfoMsg) Reset()                    { *m = ZInfoMsg{} }
func (m *ZInfoMsg) String() string            { return proto.CompactTextString(m) }
func (*ZInfoMsg) ProtoMessage()               {}
func (*ZInfoMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{24} }

type isZInfoMsg_InfoContent interface {
	isZInfoMsg_InfoContent()
}

type ZInfoMsg_Dinfo struct {
	Dinfo *ZInfoDevice `protobuf:"bytes,3,opt,name=dinfo,oneof"`
}
type ZInfoMsg_Ainfo struct {
	Ainfo *ZInfoApp `protobuf:"bytes,5,opt,name=ainfo,oneof"`
}
type ZInfoMsg_Sinfo struct {
	Sinfo *ZInfoService `protobuf:"bytes,10,opt,name=sinfo,oneof"`
}
type ZInfoMsg_Ninfo struct {
	Ninfo *ZInfoNetworkObject `protobuf:"bytes,11,opt,name=ninfo,oneof"`
}

func (*ZInfoMsg_Dinfo) isZInfoMsg_InfoContent() {}
func (*ZInfoMsg_Ainfo) isZInfoMsg_InfoContent() {}
func (*ZInfoMsg_Sinfo) isZInfoMsg_InfoContent() {}
func (*ZInfoMsg_Ninfo) isZInfoMsg_InfoContent() {}

func (m *ZInfoMsg) GetInfoContent() isZInfoMsg_InfoContent {
	if m != nil {
		return m.InfoContent
	}
	return nil
}

func (m *ZInfoMsg) GetZtype() ZInfoTypes {
	if m != nil {
		return m.Ztype
	}
	return ZInfoTypes_ZiNop
}

func (m *ZInfoMsg) GetDevId() string {
	if m != nil {
		return m.DevId
	}
	return ""
}

func (m *ZInfoMsg) GetDinfo() *ZInfoDevice {
	if x, ok := m.GetInfoContent().(*ZInfoMsg_Dinfo); ok {
		return x.Dinfo
	}
	return nil
}

func (m *ZInfoMsg) GetAinfo() *ZInfoApp {
	if x, ok := m.GetInfoContent().(*ZInfoMsg_Ainfo); ok {
		return x.Ainfo
	}
	return nil
}

func (m *ZInfoMsg) GetSinfo() *ZInfoService {
	if x, ok := m.GetInfoContent().(*ZInfoMsg_Sinfo); ok {
		return x.Sinfo
	}
	return nil
}

func (m *ZInfoMsg) GetNinfo() *ZInfoNetworkObject {
	if x, ok := m.GetInfoContent().(*ZInfoMsg_Ninfo); ok {
		return x.Ninfo
	}
	return nil
}

func (m *ZInfoMsg) GetAtTimeStamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.AtTimeStamp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZInfoMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZInfoMsg_OneofMarshaler, _ZInfoMsg_OneofUnmarshaler, _ZInfoMsg_OneofSizer, []interface{}{
		(*ZInfoMsg_Dinfo)(nil),
		(*ZInfoMsg_Ainfo)(nil),
		(*ZInfoMsg_Sinfo)(nil),
		(*ZInfoMsg_Ninfo)(nil),
	}
}

func _ZInfoMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZInfoMsg)
	// InfoContent
	switch x := m.InfoContent.(type) {
	case *ZInfoMsg_Dinfo:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dinfo); err != nil {
			return err
		}
	case *ZInfoMsg_Ainfo:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ainfo); err != nil {
			return err
		}
	case *ZInfoMsg_Sinfo:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sinfo); err != nil {
			return err
		}
	case *ZInfoMsg_Ninfo:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ninfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ZInfoMsg.InfoContent has unexpected type %T", x)
	}
	return nil
}

func _ZInfoMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZInfoMsg)
	switch tag {
	case 3: // InfoContent.dinfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoDevice)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoMsg_Dinfo{msg}
		return true, err
	case 5: // InfoContent.ainfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoApp)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoMsg_Ainfo{msg}
		return true, err
	case 10: // InfoContent.sinfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoService)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoMsg_Sinfo{msg}
		return true, err
	case 11: // InfoContent.ninfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZInfoNetworkObject)
		err := b.DecodeMessage(msg)
		m.InfoContent = &ZInfoMsg_Ninfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ZInfoMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZInfoMsg)
	// InfoContent
	switch x := m.InfoContent.(type) {
	case *ZInfoMsg_Dinfo:
		s := proto.Size(x.Dinfo)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ZInfoMsg_Ainfo:
		s := proto.Size(x.Ainfo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ZInfoMsg_Sinfo:
		s := proto.Size(x.Sinfo)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ZInfoMsg_Ninfo:
		s := proto.Size(x.Ninfo)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Information about assignable I/O adapter bundles
type ZioBundle struct {
	Type          ZioType  `protobuf:"varint,1,opt,name=type,enum=ZioType" json:"type,omitempty"`
	Name          string   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Members       []string `protobuf:"bytes,3,rep,name=members" json:"members,omitempty"`
	UsedByAppUUID string   `protobuf:"bytes,4,opt,name=usedByAppUUID" json:"usedByAppUUID,omitempty"`
	UsedByBaseOS  bool     `protobuf:"varint,5,opt,name=usedByBaseOS" json:"usedByBaseOS,omitempty"`
}

func (m *ZioBundle) Reset()                    { *m = ZioBundle{} }
func (m *ZioBundle) String() string            { return proto.CompactTextString(m) }
func (*ZioBundle) ProtoMessage()               {}
func (*ZioBundle) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{25} }

func (m *ZioBundle) GetType() ZioType {
	if m != nil {
		return m.Type
	}
	return ZioType_ZioNop
}

func (m *ZioBundle) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ZioBundle) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *ZioBundle) GetUsedByAppUUID() string {
	if m != nil {
		return m.UsedByAppUUID
	}
	return ""
}

func (m *ZioBundle) GetUsedByBaseOS() bool {
	if m != nil {
		return m.UsedByBaseOS
	}
	return false
}

type MemoryMetric struct {
	UsedMem         uint32  `protobuf:"varint,2,opt,name=usedMem" json:"usedMem,omitempty"`
	AvailMem        uint32  `protobuf:"varint,3,opt,name=availMem" json:"availMem,omitempty"`
	UsedPercentage  float64 `protobuf:"fixed64,4,opt,name=usedPercentage" json:"usedPercentage,omitempty"`
	AvailPercentage float64 `protobuf:"fixed64,5,opt,name=availPercentage" json:"availPercentage,omitempty"`
}

func (m *MemoryMetric) Reset()                    { *m = MemoryMetric{} }
func (m *MemoryMetric) String() string            { return proto.CompactTextString(m) }
func (*MemoryMetric) ProtoMessage()               {}
func (*MemoryMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{26} }

func (m *MemoryMetric) GetUsedMem() uint32 {
	if m != nil {
		return m.UsedMem
	}
	return 0
}

func (m *MemoryMetric) GetAvailMem() uint32 {
	if m != nil {
		return m.AvailMem
	}
	return 0
}

func (m *MemoryMetric) GetUsedPercentage() float64 {
	if m != nil {
		return m.UsedPercentage
	}
	return 0
}

func (m *MemoryMetric) GetAvailPercentage() float64 {
	if m != nil {
		return m.AvailPercentage
	}
	return 0
}

type NetworkMetric struct {
	IName               string `protobuf:"bytes,1,opt,name=iName" json:"iName,omitempty"`
	TxBytes             uint64 `protobuf:"varint,2,opt,name=txBytes" json:"txBytes,omitempty"`
	RxBytes             uint64 `protobuf:"varint,3,opt,name=rxBytes" json:"rxBytes,omitempty"`
	TxDrops             uint64 `protobuf:"varint,4,opt,name=txDrops" json:"txDrops,omitempty"`
	RxDrops             uint64 `protobuf:"varint,5,opt,name=rxDrops" json:"rxDrops,omitempty"`
	TxRate              uint64 `protobuf:"varint,6,opt,name=txRate" json:"txRate,omitempty"`
	RxRate              uint64 `protobuf:"varint,7,opt,name=rxRate" json:"rxRate,omitempty"`
	TxPkts              uint64 `protobuf:"varint,8,opt,name=txPkts" json:"txPkts,omitempty"`
	RxPkts              uint64 `protobuf:"varint,9,opt,name=rxPkts" json:"rxPkts,omitempty"`
	TxErrors            uint64 `protobuf:"varint,10,opt,name=txErrors" json:"txErrors,omitempty"`
	RxErrors            uint64 `protobuf:"varint,11,opt,name=rxErrors" json:"rxErrors,omitempty"`
	TxAclDrops          uint64 `protobuf:"varint,12,opt,name=txAclDrops" json:"txAclDrops,omitempty"`
	RxAclDrops          uint64 `protobuf:"varint,13,opt,name=rxAclDrops" json:"rxAclDrops,omitempty"`
	TxAclRateLimitDrops uint64 `protobuf:"varint,14,opt,name=txAclRateLimitDrops" json:"txAclRateLimitDrops,omitempty"`
	RxAclRateLimitDrops uint64 `protobuf:"varint,15,opt,name=rxAclRateLimitDrops" json:"rxAclRateLimitDrops,omitempty"`
	Name                string `protobuf:"bytes,16,opt,name=name" json:"name,omitempty"`
}

func (m *NetworkMetric) Reset()                    { *m = NetworkMetric{} }
func (m *NetworkMetric) String() string            { return proto.CompactTextString(m) }
func (*NetworkMetric) ProtoMessage()               {}
func (*NetworkMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{27} }

func (m *NetworkMetric) GetIName() string {
	if m != nil {
		return m.IName
	}
	return ""
}

func (m *NetworkMetric) GetTxBytes() uint64 {
	if m != nil {
		return m.TxBytes
	}
	return 0
}

func (m *NetworkMetric) GetRxBytes() uint64 {
	if m != nil {
		return m.RxBytes
	}
	return 0
}

func (m *NetworkMetric) GetTxDrops() uint64 {
	if m != nil {
		return m.TxDrops
	}
	return 0
}

func (m *NetworkMetric) GetRxDrops() uint64 {
	if m != nil {
		return m.RxDrops
	}
	return 0
}

func (m *NetworkMetric) GetTxRate() uint64 {
	if m != nil {
		return m.TxRate
	}
	return 0
}

func (m *NetworkMetric) GetRxRate() uint64 {
	if m != nil {
		return m.RxRate
	}
	return 0
}

func (m *NetworkMetric) GetTxPkts() uint64 {
	if m != nil {
		return m.TxPkts
	}
	return 0
}

func (m *NetworkMetric) GetRxPkts() uint64 {
	if m != nil {
		return m.RxPkts
	}
	return 0
}

func (m *NetworkMetric) GetTxErrors() uint64 {
	if m != nil {
		return m.TxErrors
	}
	return 0
}

func (m *NetworkMetric) GetRxErrors() uint64 {
	if m != nil {
		return m.RxErrors
	}
	return 0
}

func (m *NetworkMetric) GetTxAclDrops() uint64 {
	if m != nil {
		return m.TxAclDrops
	}
	return 0
}

func (m *NetworkMetric) GetRxAclDrops() uint64 {
	if m != nil {
		return m.RxAclDrops
	}
	return 0
}

func (m *NetworkMetric) GetTxAclRateLimitDrops() uint64 {
	if m != nil {
		return m.TxAclRateLimitDrops
	}
	return 0
}

func (m *NetworkMetric) GetRxAclRateLimitDrops() uint64 {
	if m != nil {
		return m.RxAclRateLimitDrops
	}
	return 0
}

func (m *NetworkMetric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Failures and successes for commuication to zedcloud
// for each uplink interface
type ZedcloudMetric struct {
	IfName      string                     `protobuf:"bytes,1,opt,name=ifName" json:"ifName,omitempty"`
	Failures    uint64                     `protobuf:"varint,2,opt,name=failures" json:"failures,omitempty"`
	Success     uint64                     `protobuf:"varint,3,opt,name=success" json:"success,omitempty"`
	LastFailure *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=lastFailure" json:"lastFailure,omitempty"`
	LastSuccess *google_protobuf.Timestamp `protobuf:"bytes,5,opt,name=lastSuccess" json:"lastSuccess,omitempty"`
	UrlMetrics  []*UrlcloudMetric          `protobuf:"bytes,6,rep,name=urlMetrics" json:"urlMetrics,omitempty"`
}

func (m *ZedcloudMetric) Reset()                    { *m = ZedcloudMetric{} }
func (m *ZedcloudMetric) String() string            { return proto.CompactTextString(m) }
func (*ZedcloudMetric) ProtoMessage()               {}
func (*ZedcloudMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{28} }

func (m *ZedcloudMetric) GetIfName() string {
	if m != nil {
		return m.IfName
	}
	return ""
}

func (m *ZedcloudMetric) GetFailures() uint64 {
	if m != nil {
		return m.Failures
	}
	return 0
}

func (m *ZedcloudMetric) GetSuccess() uint64 {
	if m != nil {
		return m.Success
	}
	return 0
}

func (m *ZedcloudMetric) GetLastFailure() *google_protobuf.Timestamp {
	if m != nil {
		return m.LastFailure
	}
	return nil
}

func (m *ZedcloudMetric) GetLastSuccess() *google_protobuf.Timestamp {
	if m != nil {
		return m.LastSuccess
	}
	return nil
}

func (m *ZedcloudMetric) GetUrlMetrics() []*UrlcloudMetric {
	if m != nil {
		return m.UrlMetrics
	}
	return nil
}

type UrlcloudMetric struct {
	Url           string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	TryMsgCount   int64  `protobuf:"varint,2,opt,name=tryMsgCount" json:"tryMsgCount,omitempty"`
	TryByteCount  int64  `protobuf:"varint,3,opt,name=tryByteCount" json:"tryByteCount,omitempty"`
	SentMsgCount  int64  `protobuf:"varint,4,opt,name=sentMsgCount" json:"sentMsgCount,omitempty"`
	SentByteCount int64  `protobuf:"varint,5,opt,name=sentByteCount" json:"sentByteCount,omitempty"`
	RecvMsgCount  int64  `protobuf:"varint,6,opt,name=recvMsgCount" json:"recvMsgCount,omitempty"`
	RecvByteCount int64  `protobuf:"varint,7,opt,name=recvByteCount" json:"recvByteCount,omitempty"`
}

func (m *UrlcloudMetric) Reset()                    { *m = UrlcloudMetric{} }
func (m *UrlcloudMetric) String() string            { return proto.CompactTextString(m) }
func (*UrlcloudMetric) ProtoMessage()               {}
func (*UrlcloudMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{29} }

func (m *UrlcloudMetric) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *UrlcloudMetric) GetTryMsgCount() int64 {
	if m != nil {
		return m.TryMsgCount
	}
	return 0
}

func (m *UrlcloudMetric) GetTryByteCount() int64 {
	if m != nil {
		return m.TryByteCount
	}
	return 0
}

func (m *UrlcloudMetric) GetSentMsgCount() int64 {
	if m != nil {
		return m.SentMsgCount
	}
	return 0
}

func (m *UrlcloudMetric) GetSentByteCount() int64 {
	if m != nil {
		return m.SentByteCount
	}
	return 0
}

func (m *UrlcloudMetric) GetRecvMsgCount() int64 {
	if m != nil {
		return m.RecvMsgCount
	}
	return 0
}

func (m *UrlcloudMetric) GetRecvByteCount() int64 {
	if m != nil {
		return m.RecvByteCount
	}
	return 0
}

type AppCpuMetric struct {
	// uint32 cpuTotal = 2;		// deprecated
	// double cpuPercentage = 3;		// deprecated
	UpTime *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=upTime" json:"upTime,omitempty"`
	Total  uint64                     `protobuf:"varint,5,opt,name=total" json:"total,omitempty"`
}

func (m *AppCpuMetric) Reset()                    { *m = AppCpuMetric{} }
func (m *AppCpuMetric) String() string            { return proto.CompactTextString(m) }
func (*AppCpuMetric) ProtoMessage()               {}
func (*AppCpuMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{30} }

func (m *AppCpuMetric) GetUpTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpTime
	}
	return nil
}

func (m *AppCpuMetric) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type DeviceMetric struct {
	// cpuMetric cpu = 1;	// deprecated
	Memory   *MemoryMetric     `protobuf:"bytes,2,opt,name=memory" json:"memory,omitempty"`
	Network  []*NetworkMetric  `protobuf:"bytes,3,rep,name=network" json:"network,omitempty"`
	Zedcloud []*ZedcloudMetric `protobuf:"bytes,4,rep,name=zedcloud" json:"zedcloud,omitempty"`
	// devCpuMetric compute = 5; // deprecated
	Disk        []*DiskMetric `protobuf:"bytes,6,rep,name=disk" json:"disk,omitempty"`
	CpuMetric   *AppCpuMetric `protobuf:"bytes,7,opt,name=cpuMetric" json:"cpuMetric,omitempty"`
	MetricItems []*MetricItem `protobuf:"bytes,8,rep,name=metricItems" json:"metricItems,omitempty"`
}

func (m *DeviceMetric) Reset()                    { *m = DeviceMetric{} }
func (m *DeviceMetric) String() string            { return proto.CompactTextString(m) }
func (*DeviceMetric) ProtoMessage()               {}
func (*DeviceMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{31} }

func (m *DeviceMetric) GetMemory() *MemoryMetric {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *DeviceMetric) GetNetwork() []*NetworkMetric {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *DeviceMetric) GetZedcloud() []*ZedcloudMetric {
	if m != nil {
		return m.Zedcloud
	}
	return nil
}

func (m *DeviceMetric) GetDisk() []*DiskMetric {
	if m != nil {
		return m.Disk
	}
	return nil
}

func (m *DeviceMetric) GetCpuMetric() *AppCpuMetric {
	if m != nil {
		return m.CpuMetric
	}
	return nil
}

func (m *DeviceMetric) GetMetricItems() []*MetricItem {
	if m != nil {
		return m.MetricItems
	}
	return nil
}

// Open-ended metrics from different part of the device such as LTE modem
// metrics.
type MetricItem struct {
	Key  string         `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Type MetricItemType `protobuf:"varint,2,opt,name=type,enum=MetricItemType" json:"type,omitempty"`
	// Types that are valid to be assigned to MetricItemValue:
	//	*MetricItem_BoolValue
	//	*MetricItem_Uint32Value
	//	*MetricItem_Uint64Value
	//	*MetricItem_FloatValue
	//	*MetricItem_StringValue
	MetricItemValue isMetricItem_MetricItemValue `protobuf_oneof:"metricItemValue"`
}

func (m *MetricItem) Reset()                    { *m = MetricItem{} }
func (m *MetricItem) String() string            { return proto.CompactTextString(m) }
func (*MetricItem) ProtoMessage()               {}
func (*MetricItem) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{32} }

type isMetricItem_MetricItemValue interface {
	isMetricItem_MetricItemValue()
}

type MetricItem_BoolValue struct {
	BoolValue bool `protobuf:"varint,3,opt,name=boolValue,oneof"`
}
type MetricItem_Uint32Value struct {
	Uint32Value uint32 `protobuf:"varint,4,opt,name=uint32Value,oneof"`
}
type MetricItem_Uint64Value struct {
	Uint64Value uint64 `protobuf:"varint,5,opt,name=uint64Value,oneof"`
}
type MetricItem_FloatValue struct {
	FloatValue float32 `protobuf:"fixed32,6,opt,name=floatValue,oneof"`
}
type MetricItem_StringValue struct {
	StringValue string `protobuf:"bytes,7,opt,name=stringValue,oneof"`
}

func (*MetricItem_BoolValue) isMetricItem_MetricItemValue()   {}
func (*MetricItem_Uint32Value) isMetricItem_MetricItemValue() {}
func (*MetricItem_Uint64Value) isMetricItem_MetricItemValue() {}
func (*MetricItem_FloatValue) isMetricItem_MetricItemValue()  {}
func (*MetricItem_StringValue) isMetricItem_MetricItemValue() {}

func (m *MetricItem) GetMetricItemValue() isMetricItem_MetricItemValue {
	if m != nil {
		return m.MetricItemValue
	}
	return nil
}

func (m *MetricItem) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *MetricItem) GetType() MetricItemType {
	if m != nil {
		return m.Type
	}
	return MetricItemType_MetricItemOther
}

func (m *MetricItem) GetBoolValue() bool {
	if x, ok := m.GetMetricItemValue().(*MetricItem_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *MetricItem) GetUint32Value() uint32 {
	if x, ok := m.GetMetricItemValue().(*MetricItem_Uint32Value); ok {
		return x.Uint32Value
	}
	return 0
}

func (m *MetricItem) GetUint64Value() uint64 {
	if x, ok := m.GetMetricItemValue().(*MetricItem_Uint64Value); ok {
		return x.Uint64Value
	}
	return 0
}

func (m *MetricItem) GetFloatValue() float32 {
	if x, ok := m.GetMetricItemValue().(*MetricItem_FloatValue); ok {
		return x.FloatValue
	}
	return 0
}

func (m *MetricItem) GetStringValue() string {
	if x, ok := m.GetMetricItemValue().(*MetricItem_StringValue); ok {
		return x.StringValue
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MetricItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MetricItem_OneofMarshaler, _MetricItem_OneofUnmarshaler, _MetricItem_OneofSizer, []interface{}{
		(*MetricItem_BoolValue)(nil),
		(*MetricItem_Uint32Value)(nil),
		(*MetricItem_Uint64Value)(nil),
		(*MetricItem_FloatValue)(nil),
		(*MetricItem_StringValue)(nil),
	}
}

func _MetricItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MetricItem)
	// metricItemValue
	switch x := m.MetricItemValue.(type) {
	case *MetricItem_BoolValue:
		t := uint64(0)
		if x.BoolValue {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *MetricItem_Uint32Value:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Uint32Value))
	case *MetricItem_Uint64Value:
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Uint64Value))
	case *MetricItem_FloatValue:
		b.EncodeVarint(6<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(math.Float32bits(x.FloatValue)))
	case *MetricItem_StringValue:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.StringValue)
	case nil:
	default:
		return fmt.Errorf("MetricItem.MetricItemValue has unexpected type %T", x)
	}
	return nil
}

func _MetricItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MetricItem)
	switch tag {
	case 3: // metricItemValue.boolValue
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MetricItemValue = &MetricItem_BoolValue{x != 0}
		return true, err
	case 4: // metricItemValue.uint32Value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MetricItemValue = &MetricItem_Uint32Value{uint32(x)}
		return true, err
	case 5: // metricItemValue.uint64Value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.MetricItemValue = &MetricItem_Uint64Value{x}
		return true, err
	case 6: // metricItemValue.floatValue
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.MetricItemValue = &MetricItem_FloatValue{math.Float32frombits(uint32(x))}
		return true, err
	case 7: // metricItemValue.stringValue
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MetricItemValue = &MetricItem_StringValue{x}
		return true, err
	default:
		return false, nil
	}
}

func _MetricItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MetricItem)
	// metricItemValue
	switch x := m.MetricItemValue.(type) {
	case *MetricItem_BoolValue:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *MetricItem_Uint32Value:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Uint32Value))
	case *MetricItem_Uint64Value:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Uint64Value))
	case *MetricItem_FloatValue:
		n += proto.SizeVarint(6<<3 | proto.WireFixed32)
		n += 4
	case *MetricItem_StringValue:
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringValue)))
		n += len(x.StringValue)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// For each partition; counts since boot
type DiskMetric struct {
	Disk       string `protobuf:"bytes,1,opt,name=disk" json:"disk,omitempty"`
	MountPath  string `protobuf:"bytes,2,opt,name=mountPath" json:"mountPath,omitempty"`
	ReadBytes  uint64 `protobuf:"varint,3,opt,name=readBytes" json:"readBytes,omitempty"`
	WriteBytes uint64 `protobuf:"varint,4,opt,name=writeBytes" json:"writeBytes,omitempty"`
	ReadCount  uint64 `protobuf:"varint,5,opt,name=readCount" json:"readCount,omitempty"`
	WriteCount uint64 `protobuf:"varint,6,opt,name=writeCount" json:"writeCount,omitempty"`
	Total      uint64 `protobuf:"varint,7,opt,name=total" json:"total,omitempty"`
	Used       uint64 `protobuf:"varint,8,opt,name=used" json:"used,omitempty"`
	Free       uint64 `protobuf:"varint,9,opt,name=free" json:"free,omitempty"`
}

func (m *DiskMetric) Reset()                    { *m = DiskMetric{} }
func (m *DiskMetric) String() string            { return proto.CompactTextString(m) }
func (*DiskMetric) ProtoMessage()               {}
func (*DiskMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{33} }

func (m *DiskMetric) GetDisk() string {
	if m != nil {
		return m.Disk
	}
	return ""
}

func (m *DiskMetric) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *DiskMetric) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *DiskMetric) GetWriteBytes() uint64 {
	if m != nil {
		return m.WriteBytes
	}
	return 0
}

func (m *DiskMetric) GetReadCount() uint64 {
	if m != nil {
		return m.ReadCount
	}
	return 0
}

func (m *DiskMetric) GetWriteCount() uint64 {
	if m != nil {
		return m.WriteCount
	}
	return 0
}

func (m *DiskMetric) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DiskMetric) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DiskMetric) GetFree() uint64 {
	if m != nil {
		return m.Free
	}
	return 0
}

type AppDiskMetric struct {
	Disk        string `protobuf:"bytes,1,opt,name=disk" json:"disk,omitempty"`
	Provisioned uint64 `protobuf:"varint,2,opt,name=provisioned" json:"provisioned,omitempty"`
	Used        uint64 `protobuf:"varint,3,opt,name=used" json:"used,omitempty"`
	DiskType    string `protobuf:"bytes,4,opt,name=diskType" json:"diskType,omitempty"`
	Dirty       bool   `protobuf:"varint,5,opt,name=dirty" json:"dirty,omitempty"`
}

func (m *AppDiskMetric) Reset()                    { *m = AppDiskMetric{} }
func (m *AppDiskMetric) String() string            { return proto.CompactTextString(m) }
func (*AppDiskMetric) ProtoMessage()               {}
func (*AppDiskMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{34} }

func (m *AppDiskMetric) GetDisk() string {
	if m != nil {
		return m.Disk
	}
	return ""
}

func (m *AppDiskMetric) GetProvisioned() uint64 {
	if m != nil {
		return m.Provisioned
	}
	return 0
}

func (m *AppDiskMetric) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *AppDiskMetric) GetDiskType() string {
	if m != nil {
		return m.DiskType
	}
	return ""
}

func (m *AppDiskMetric) GetDirty() bool {
	if m != nil {
		return m.Dirty
	}
	return false
}

type AppMetric struct {
	AppID   string           `protobuf:"bytes,1,opt,name=AppID" json:"AppID,omitempty"`
	AppName string           `protobuf:"bytes,2,opt,name=AppName" json:"AppName,omitempty"`
	Cpu     *AppCpuMetric    `protobuf:"bytes,3,opt,name=cpu" json:"cpu,omitempty"`
	Memory  *MemoryMetric    `protobuf:"bytes,4,opt,name=memory" json:"memory,omitempty"`
	Network []*NetworkMetric `protobuf:"bytes,5,rep,name=network" json:"network,omitempty"`
	Disk    []*AppDiskMetric `protobuf:"bytes,6,rep,name=disk" json:"disk,omitempty"`
}

func (m *AppMetric) Reset()                    { *m = AppMetric{} }
func (m *AppMetric) String() string            { return proto.CompactTextString(m) }
func (*AppMetric) ProtoMessage()               {}
func (*AppMetric) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{35} }

func (m *AppMetric) GetAppID() string {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *AppMetric) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *AppMetric) GetCpu() *AppCpuMetric {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *AppMetric) GetMemory() *MemoryMetric {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *AppMetric) GetNetwork() []*NetworkMetric {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *AppMetric) GetDisk() []*AppDiskMetric {
	if m != nil {
		return m.Disk
	}
	return nil
}

// Lisp stats
type PktStat struct {
	Packets uint64 `protobuf:"varint,1,opt,name=Packets" json:"Packets,omitempty"`
	Bytes   uint64 `protobuf:"varint,2,opt,name=Bytes" json:"Bytes,omitempty"`
}

func (m *PktStat) Reset()                    { *m = PktStat{} }
func (m *PktStat) String() string            { return proto.CompactTextString(m) }
func (*PktStat) ProtoMessage()               {}
func (*PktStat) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{36} }

func (m *PktStat) GetPackets() uint64 {
	if m != nil {
		return m.Packets
	}
	return 0
}

func (m *PktStat) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type RlocStats struct {
	Rloc                   string   `protobuf:"bytes,1,opt,name=Rloc" json:"Rloc,omitempty"`
	Stats                  *PktStat `protobuf:"bytes,2,opt,name=Stats" json:"Stats,omitempty"`
	SecondsSinceLastPacket uint64   `protobuf:"varint,3,opt,name=SecondsSinceLastPacket" json:"SecondsSinceLastPacket,omitempty"`
}

func (m *RlocStats) Reset()                    { *m = RlocStats{} }
func (m *RlocStats) String() string            { return proto.CompactTextString(m) }
func (*RlocStats) ProtoMessage()               {}
func (*RlocStats) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{37} }

func (m *RlocStats) GetRloc() string {
	if m != nil {
		return m.Rloc
	}
	return ""
}

func (m *RlocStats) GetStats() *PktStat {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *RlocStats) GetSecondsSinceLastPacket() uint64 {
	if m != nil {
		return m.SecondsSinceLastPacket
	}
	return 0
}

type EidStats struct {
	IID              uint64       `protobuf:"varint,1,opt,name=IID" json:"IID,omitempty"`
	EID              string       `protobuf:"bytes,2,opt,name=EID" json:"EID,omitempty"`
	RlocStatsEntries []*RlocStats `protobuf:"bytes,3,rep,name=RlocStatsEntries" json:"RlocStatsEntries,omitempty"`
}

func (m *EidStats) Reset()                    { *m = EidStats{} }
func (m *EidStats) String() string            { return proto.CompactTextString(m) }
func (*EidStats) ProtoMessage()               {}
func (*EidStats) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{38} }

func (m *EidStats) GetIID() uint64 {
	if m != nil {
		return m.IID
	}
	return 0
}

func (m *EidStats) GetEID() string {
	if m != nil {
		return m.EID
	}
	return ""
}

func (m *EidStats) GetRlocStatsEntries() []*RlocStats {
	if m != nil {
		return m.RlocStatsEntries
	}
	return nil
}

type ZMetricLisp struct {
	// Encap Statistics
	EidStatsEntries    []*EidStats `protobuf:"bytes,1,rep,name=EidStatsEntries" json:"EidStatsEntries,omitempty"`
	ItrPacketSendError *PktStat    `protobuf:"bytes,2,opt,name=ItrPacketSendError" json:"ItrPacketSendError,omitempty"`
	InvalidEidError    *PktStat    `protobuf:"bytes,3,opt,name=InvalidEidError" json:"InvalidEidError,omitempty"`
	// Decap Statistics
	NoDecryptKey       *PktStat `protobuf:"bytes,4,opt,name=NoDecryptKey" json:"NoDecryptKey,omitempty"`
	OuterHeaderError   *PktStat `protobuf:"bytes,5,opt,name=OuterHeaderError" json:"OuterHeaderError,omitempty"`
	BadInnerVersion    *PktStat `protobuf:"bytes,6,opt,name=BadInnerVersion" json:"BadInnerVersion,omitempty"`
	GoodPackets        *PktStat `protobuf:"bytes,7,opt,name=GoodPackets" json:"GoodPackets,omitempty"`
	ICVError           *PktStat `protobuf:"bytes,8,opt,name=ICVError" json:"ICVError,omitempty"`
	LispHeaderError    *PktStat `protobuf:"bytes,9,opt,name=LispHeaderError" json:"LispHeaderError,omitempty"`
	CheckSumError      *PktStat `protobuf:"bytes,10,opt,name=CheckSumError" json:"CheckSumError,omitempty"`
	DecapReInjectError *PktStat `protobuf:"bytes,11,opt,name=DecapReInjectError" json:"DecapReInjectError,omitempty"`
	DecryptError       *PktStat `protobuf:"bytes,12,opt,name=DecryptError" json:"DecryptError,omitempty"`
}

func (m *ZMetricLisp) Reset()                    { *m = ZMetricLisp{} }
func (m *ZMetricLisp) String() string            { return proto.CompactTextString(m) }
func (*ZMetricLisp) ProtoMessage()               {}
func (*ZMetricLisp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{39} }

func (m *ZMetricLisp) GetEidStatsEntries() []*EidStats {
	if m != nil {
		return m.EidStatsEntries
	}
	return nil
}

func (m *ZMetricLisp) GetItrPacketSendError() *PktStat {
	if m != nil {
		return m.ItrPacketSendError
	}
	return nil
}

func (m *ZMetricLisp) GetInvalidEidError() *PktStat {
	if m != nil {
		return m.InvalidEidError
	}
	return nil
}

func (m *ZMetricLisp) GetNoDecryptKey() *PktStat {
	if m != nil {
		return m.NoDecryptKey
	}
	return nil
}

func (m *ZMetricLisp) GetOuterHeaderError() *PktStat {
	if m != nil {
		return m.OuterHeaderError
	}
	return nil
}

func (m *ZMetricLisp) GetBadInnerVersion() *PktStat {
	if m != nil {
		return m.BadInnerVersion
	}
	return nil
}

func (m *ZMetricLisp) GetGoodPackets() *PktStat {
	if m != nil {
		return m.GoodPackets
	}
	return nil
}

func (m *ZMetricLisp) GetICVError() *PktStat {
	if m != nil {
		return m.ICVError
	}
	return nil
}

func (m *ZMetricLisp) GetLispHeaderError() *PktStat {
	if m != nil {
		return m.LispHeaderError
	}
	return nil
}

func (m *ZMetricLisp) GetCheckSumError() *PktStat {
	if m != nil {
		return m.CheckSumError
	}
	return nil
}

func (m *ZMetricLisp) GetDecapReInjectError() *PktStat {
	if m != nil {
		return m.DecapReInjectError
	}
	return nil
}

func (m *ZMetricLisp) GetDecryptError() *PktStat {
	if m != nil {
		return m.DecryptError
	}
	return nil
}

// Vpn Stats
type ZMetricConn struct {
	InPkts        *PktStat `protobuf:"bytes,1,opt,name=InPkts" json:"InPkts,omitempty"`
	OutPkts       *PktStat `protobuf:"bytes,2,opt,name=OutPkts" json:"OutPkts,omitempty"`
	ErrPkts       *PktStat `protobuf:"bytes,3,opt,name=ErrPkts" json:"ErrPkts,omitempty"`
	CarierErrPkts *PktStat `protobuf:"bytes,4,opt,name=CarierErrPkts" json:"CarierErrPkts,omitempty"`
}

func (m *ZMetricConn) Reset()                    { *m = ZMetricConn{} }
func (m *ZMetricConn) String() string            { return proto.CompactTextString(m) }
func (*ZMetricConn) ProtoMessage()               {}
func (*ZMetricConn) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{40} }

func (m *ZMetricConn) GetInPkts() *PktStat {
	if m != nil {
		return m.InPkts
	}
	return nil
}

func (m *ZMetricConn) GetOutPkts() *PktStat {
	if m != nil {
		return m.OutPkts
	}
	return nil
}

func (m *ZMetricConn) GetErrPkts() *PktStat {
	if m != nil {
		return m.ErrPkts
	}
	return nil
}

func (m *ZMetricConn) GetCarierErrPkts() *PktStat {
	if m != nil {
		return m.CarierErrPkts
	}
	return nil
}

type ZMetricVpn struct {
	ConnStat *ZMetricConn `protobuf:"bytes,1,opt,name=ConnStat" json:"ConnStat,omitempty"`
	IkeStat  *ZMetricConn `protobuf:"bytes,2,opt,name=IkeStat" json:"IkeStat,omitempty"`
	NatTStat *ZMetricConn `protobuf:"bytes,3,opt,name=NatTStat" json:"NatTStat,omitempty"`
	EspStat  *ZMetricConn `protobuf:"bytes,4,opt,name=EspStat" json:"EspStat,omitempty"`
}

func (m *ZMetricVpn) Reset()                    { *m = ZMetricVpn{} }
func (m *ZMetricVpn) String() string            { return proto.CompactTextString(m) }
func (*ZMetricVpn) ProtoMessage()               {}
func (*ZMetricVpn) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{41} }

func (m *ZMetricVpn) GetConnStat() *ZMetricConn {
	if m != nil {
		return m.ConnStat
	}
	return nil
}

func (m *ZMetricVpn) GetIkeStat() *ZMetricConn {
	if m != nil {
		return m.IkeStat
	}
	return nil
}

func (m *ZMetricVpn) GetNatTStat() *ZMetricConn {
	if m != nil {
		return m.NatTStat
	}
	return nil
}

func (m *ZMetricVpn) GetEspStat() *ZMetricConn {
	if m != nil {
		return m.EspStat
	}
	return nil
}

// flow stats
type ZMetricFlowLink struct {
	// Types that are valid to be assigned to Link:
	//	*ZMetricFlowLink_SubNet
	//	*ZMetricFlowLink_Eid
	Link  isZMetricFlowLink_Link `protobuf_oneof:"Link"`
	SpiId string                 `protobuf:"bytes,3,opt,name=spiId" json:"spiId,omitempty"`
}

func (m *ZMetricFlowLink) Reset()                    { *m = ZMetricFlowLink{} }
func (m *ZMetricFlowLink) String() string            { return proto.CompactTextString(m) }
func (*ZMetricFlowLink) ProtoMessage()               {}
func (*ZMetricFlowLink) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{42} }

type isZMetricFlowLink_Link interface {
	isZMetricFlowLink_Link()
}

type ZMetricFlowLink_SubNet struct {
	SubNet string `protobuf:"bytes,1,opt,name=subNet,oneof"`
}
type ZMetricFlowLink_Eid struct {
	Eid string `protobuf:"bytes,2,opt,name=eid,oneof"`
}

func (*ZMetricFlowLink_SubNet) isZMetricFlowLink_Link() {}
func (*ZMetricFlowLink_Eid) isZMetricFlowLink_Link()    {}

func (m *ZMetricFlowLink) GetLink() isZMetricFlowLink_Link {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *ZMetricFlowLink) GetSubNet() string {
	if x, ok := m.GetLink().(*ZMetricFlowLink_SubNet); ok {
		return x.SubNet
	}
	return ""
}

func (m *ZMetricFlowLink) GetEid() string {
	if x, ok := m.GetLink().(*ZMetricFlowLink_Eid); ok {
		return x.Eid
	}
	return ""
}

func (m *ZMetricFlowLink) GetSpiId() string {
	if m != nil {
		return m.SpiId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZMetricFlowLink) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZMetricFlowLink_OneofMarshaler, _ZMetricFlowLink_OneofUnmarshaler, _ZMetricFlowLink_OneofSizer, []interface{}{
		(*ZMetricFlowLink_SubNet)(nil),
		(*ZMetricFlowLink_Eid)(nil),
	}
}

func _ZMetricFlowLink_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZMetricFlowLink)
	// Link
	switch x := m.Link.(type) {
	case *ZMetricFlowLink_SubNet:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.SubNet)
	case *ZMetricFlowLink_Eid:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Eid)
	case nil:
	default:
		return fmt.Errorf("ZMetricFlowLink.Link has unexpected type %T", x)
	}
	return nil
}

func _ZMetricFlowLink_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZMetricFlowLink)
	switch tag {
	case 1: // Link.subNet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Link = &ZMetricFlowLink_SubNet{x}
		return true, err
	case 2: // Link.eid
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Link = &ZMetricFlowLink_Eid{x}
		return true, err
	default:
		return false, nil
	}
}

func _ZMetricFlowLink_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZMetricFlowLink)
	// Link
	switch x := m.Link.(type) {
	case *ZMetricFlowLink_SubNet:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SubNet)))
		n += len(x.SubNet)
	case *ZMetricFlowLink_Eid:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Eid)))
		n += len(x.Eid)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ZMetricFlowEndPoint struct {
	// Types that are valid to be assigned to Endpoint:
	//	*ZMetricFlowEndPoint_IpAddr
	//	*ZMetricFlowEndPoint_Rloc
	Endpoint isZMetricFlowEndPoint_Endpoint `protobuf_oneof:"Endpoint"`
	Link     []*ZMetricFlowLink             `protobuf:"bytes,5,rep,name=link" json:"link,omitempty"`
	Stats    *PktStat                       `protobuf:"bytes,10,opt,name=stats" json:"stats,omitempty"`
}

func (m *ZMetricFlowEndPoint) Reset()                    { *m = ZMetricFlowEndPoint{} }
func (m *ZMetricFlowEndPoint) String() string            { return proto.CompactTextString(m) }
func (*ZMetricFlowEndPoint) ProtoMessage()               {}
func (*ZMetricFlowEndPoint) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{43} }

type isZMetricFlowEndPoint_Endpoint interface {
	isZMetricFlowEndPoint_Endpoint()
}

type ZMetricFlowEndPoint_IpAddr struct {
	IpAddr string `protobuf:"bytes,1,opt,name=ipAddr,oneof"`
}
type ZMetricFlowEndPoint_Rloc struct {
	Rloc string `protobuf:"bytes,2,opt,name=rloc,oneof"`
}

func (*ZMetricFlowEndPoint_IpAddr) isZMetricFlowEndPoint_Endpoint() {}
func (*ZMetricFlowEndPoint_Rloc) isZMetricFlowEndPoint_Endpoint()   {}

func (m *ZMetricFlowEndPoint) GetEndpoint() isZMetricFlowEndPoint_Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *ZMetricFlowEndPoint) GetIpAddr() string {
	if x, ok := m.GetEndpoint().(*ZMetricFlowEndPoint_IpAddr); ok {
		return x.IpAddr
	}
	return ""
}

func (m *ZMetricFlowEndPoint) GetRloc() string {
	if x, ok := m.GetEndpoint().(*ZMetricFlowEndPoint_Rloc); ok {
		return x.Rloc
	}
	return ""
}

func (m *ZMetricFlowEndPoint) GetLink() []*ZMetricFlowLink {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *ZMetricFlowEndPoint) GetStats() *PktStat {
	if m != nil {
		return m.Stats
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZMetricFlowEndPoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZMetricFlowEndPoint_OneofMarshaler, _ZMetricFlowEndPoint_OneofUnmarshaler, _ZMetricFlowEndPoint_OneofSizer, []interface{}{
		(*ZMetricFlowEndPoint_IpAddr)(nil),
		(*ZMetricFlowEndPoint_Rloc)(nil),
	}
}

func _ZMetricFlowEndPoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZMetricFlowEndPoint)
	// Endpoint
	switch x := m.Endpoint.(type) {
	case *ZMetricFlowEndPoint_IpAddr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.IpAddr)
	case *ZMetricFlowEndPoint_Rloc:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Rloc)
	case nil:
	default:
		return fmt.Errorf("ZMetricFlowEndPoint.Endpoint has unexpected type %T", x)
	}
	return nil
}

func _ZMetricFlowEndPoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZMetricFlowEndPoint)
	switch tag {
	case 1: // Endpoint.ipAddr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Endpoint = &ZMetricFlowEndPoint_IpAddr{x}
		return true, err
	case 2: // Endpoint.rloc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Endpoint = &ZMetricFlowEndPoint_Rloc{x}
		return true, err
	default:
		return false, nil
	}
}

func _ZMetricFlowEndPoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZMetricFlowEndPoint)
	// Endpoint
	switch x := m.Endpoint.(type) {
	case *ZMetricFlowEndPoint_IpAddr:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.IpAddr)))
		n += len(x.IpAddr)
	case *ZMetricFlowEndPoint_Rloc:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Rloc)))
		n += len(x.Rloc)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ZMetricFlow struct {
	Id        string                 `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name      string                 `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Type      uint32                 `protobuf:"varint,3,opt,name=type" json:"type,omitempty"`
	Iid       uint64                 `protobuf:"varint,4,opt,name=iid" json:"iid,omitempty"`
	EstTime   uint64                 `protobuf:"varint,5,opt,name=estTime" json:"estTime,omitempty"`
	LEndPoint *ZMetricFlowEndPoint   `protobuf:"bytes,10,opt,name=lEndPoint" json:"lEndPoint,omitempty"`
	REndPoint []*ZMetricFlowEndPoint `protobuf:"bytes,11,rep,name=rEndPoint" json:"rEndPoint,omitempty"`
}

func (m *ZMetricFlow) Reset()                    { *m = ZMetricFlow{} }
func (m *ZMetricFlow) String() string            { return proto.CompactTextString(m) }
func (*ZMetricFlow) ProtoMessage()               {}
func (*ZMetricFlow) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{44} }

func (m *ZMetricFlow) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ZMetricFlow) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ZMetricFlow) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ZMetricFlow) GetIid() uint64 {
	if m != nil {
		return m.Iid
	}
	return 0
}

func (m *ZMetricFlow) GetEstTime() uint64 {
	if m != nil {
		return m.EstTime
	}
	return 0
}

func (m *ZMetricFlow) GetLEndPoint() *ZMetricFlowEndPoint {
	if m != nil {
		return m.LEndPoint
	}
	return nil
}

func (m *ZMetricFlow) GetREndPoint() []*ZMetricFlowEndPoint {
	if m != nil {
		return m.REndPoint
	}
	return nil
}

type ZMetricLispGlobal struct {
	// Encap/ITR Statistics
	ItrPacketSendError *PktStat `protobuf:"bytes,2,opt,name=ItrPacketSendError" json:"ItrPacketSendError,omitempty"`
	InvalidEidError    *PktStat `protobuf:"bytes,3,opt,name=InvalidEidError" json:"InvalidEidError,omitempty"`
	// Decap/ETR Statistics
	NoDecryptKey       *PktStat `protobuf:"bytes,4,opt,name=NoDecryptKey" json:"NoDecryptKey,omitempty"`
	OuterHeaderError   *PktStat `protobuf:"bytes,5,opt,name=OuterHeaderError" json:"OuterHeaderError,omitempty"`
	BadInnerVersion    *PktStat `protobuf:"bytes,6,opt,name=BadInnerVersion" json:"BadInnerVersion,omitempty"`
	GoodPackets        *PktStat `protobuf:"bytes,7,opt,name=GoodPackets" json:"GoodPackets,omitempty"`
	ICVError           *PktStat `protobuf:"bytes,8,opt,name=ICVError" json:"ICVError,omitempty"`
	LispHeaderError    *PktStat `protobuf:"bytes,9,opt,name=LispHeaderError" json:"LispHeaderError,omitempty"`
	CheckSumError      *PktStat `protobuf:"bytes,10,opt,name=CheckSumError" json:"CheckSumError,omitempty"`
	DecapReInjectError *PktStat `protobuf:"bytes,11,opt,name=DecapReInjectError" json:"DecapReInjectError,omitempty"`
	DecryptError       *PktStat `protobuf:"bytes,12,opt,name=DecryptError" json:"DecryptError,omitempty"`
}

func (m *ZMetricLispGlobal) Reset()                    { *m = ZMetricLispGlobal{} }
func (m *ZMetricLispGlobal) String() string            { return proto.CompactTextString(m) }
func (*ZMetricLispGlobal) ProtoMessage()               {}
func (*ZMetricLispGlobal) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{45} }

func (m *ZMetricLispGlobal) GetItrPacketSendError() *PktStat {
	if m != nil {
		return m.ItrPacketSendError
	}
	return nil
}

func (m *ZMetricLispGlobal) GetInvalidEidError() *PktStat {
	if m != nil {
		return m.InvalidEidError
	}
	return nil
}

func (m *ZMetricLispGlobal) GetNoDecryptKey() *PktStat {
	if m != nil {
		return m.NoDecryptKey
	}
	return nil
}

func (m *ZMetricLispGlobal) GetOuterHeaderError() *PktStat {
	if m != nil {
		return m.OuterHeaderError
	}
	return nil
}

func (m *ZMetricLispGlobal) GetBadInnerVersion() *PktStat {
	if m != nil {
		return m.BadInnerVersion
	}
	return nil
}

func (m *ZMetricLispGlobal) GetGoodPackets() *PktStat {
	if m != nil {
		return m.GoodPackets
	}
	return nil
}

func (m *ZMetricLispGlobal) GetICVError() *PktStat {
	if m != nil {
		return m.ICVError
	}
	return nil
}

func (m *ZMetricLispGlobal) GetLispHeaderError() *PktStat {
	if m != nil {
		return m.LispHeaderError
	}
	return nil
}

func (m *ZMetricLispGlobal) GetCheckSumError() *PktStat {
	if m != nil {
		return m.CheckSumError
	}
	return nil
}

func (m *ZMetricLispGlobal) GetDecapReInjectError() *PktStat {
	if m != nil {
		return m.DecapReInjectError
	}
	return nil
}

func (m *ZMetricLispGlobal) GetDecryptError() *PktStat {
	if m != nil {
		return m.DecryptError
	}
	return nil
}

type ZMetricService struct {
	ServiceID   string           `protobuf:"bytes,1,opt,name=serviceID" json:"serviceID,omitempty"`
	ServiceName string           `protobuf:"bytes,2,opt,name=serviceName" json:"serviceName,omitempty"`
	ServiceType uint32           `protobuf:"varint,3,opt,name=serviceType" json:"serviceType,omitempty"`
	Network     []*NetworkMetric `protobuf:"bytes,4,rep,name=network" json:"network,omitempty"`
	// Types that are valid to be assigned to ServiceContent:
	//	*ZMetricService_Vpnm
	//	*ZMetricService_Lispm
	ServiceContent  isZMetricService_ServiceContent `protobuf_oneof:"ServiceContent"`
	FlowStats       []*ZMetricFlow                  `protobuf:"bytes,10,rep,name=flowStats" json:"flowStats,omitempty"`
	LispGlobalStats *ZMetricLispGlobal              `protobuf:"bytes,11,opt,name=lispGlobalStats" json:"lispGlobalStats,omitempty"`
}

func (m *ZMetricService) Reset()                    { *m = ZMetricService{} }
func (m *ZMetricService) String() string            { return proto.CompactTextString(m) }
func (*ZMetricService) ProtoMessage()               {}
func (*ZMetricService) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{46} }

type isZMetricService_ServiceContent interface {
	isZMetricService_ServiceContent()
}

type ZMetricService_Vpnm struct {
	Vpnm *ZMetricVpn `protobuf:"bytes,20,opt,name=vpnm,oneof"`
}
type ZMetricService_Lispm struct {
	Lispm *ZMetricLisp `protobuf:"bytes,21,opt,name=lispm,oneof"`
}

func (*ZMetricService_Vpnm) isZMetricService_ServiceContent()  {}
func (*ZMetricService_Lispm) isZMetricService_ServiceContent() {}

func (m *ZMetricService) GetServiceContent() isZMetricService_ServiceContent {
	if m != nil {
		return m.ServiceContent
	}
	return nil
}

func (m *ZMetricService) GetServiceID() string {
	if m != nil {
		return m.ServiceID
	}
	return ""
}

func (m *ZMetricService) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *ZMetricService) GetServiceType() uint32 {
	if m != nil {
		return m.ServiceType
	}
	return 0
}

func (m *ZMetricService) GetNetwork() []*NetworkMetric {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *ZMetricService) GetVpnm() *ZMetricVpn {
	if x, ok := m.GetServiceContent().(*ZMetricService_Vpnm); ok {
		return x.Vpnm
	}
	return nil
}

func (m *ZMetricService) GetLispm() *ZMetricLisp {
	if x, ok := m.GetServiceContent().(*ZMetricService_Lispm); ok {
		return x.Lispm
	}
	return nil
}

func (m *ZMetricService) GetFlowStats() []*ZMetricFlow {
	if m != nil {
		return m.FlowStats
	}
	return nil
}

func (m *ZMetricService) GetLispGlobalStats() *ZMetricLispGlobal {
	if m != nil {
		return m.LispGlobalStats
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZMetricService) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZMetricService_OneofMarshaler, _ZMetricService_OneofUnmarshaler, _ZMetricService_OneofSizer, []interface{}{
		(*ZMetricService_Vpnm)(nil),
		(*ZMetricService_Lispm)(nil),
	}
}

func _ZMetricService_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZMetricService)
	// ServiceContent
	switch x := m.ServiceContent.(type) {
	case *ZMetricService_Vpnm:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vpnm); err != nil {
			return err
		}
	case *ZMetricService_Lispm:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Lispm); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ZMetricService.ServiceContent has unexpected type %T", x)
	}
	return nil
}

func _ZMetricService_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZMetricService)
	switch tag {
	case 20: // ServiceContent.vpnm
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZMetricVpn)
		err := b.DecodeMessage(msg)
		m.ServiceContent = &ZMetricService_Vpnm{msg}
		return true, err
	case 21: // ServiceContent.lispm
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ZMetricLisp)
		err := b.DecodeMessage(msg)
		m.ServiceContent = &ZMetricService_Lispm{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ZMetricService_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZMetricService)
	// ServiceContent
	switch x := m.ServiceContent.(type) {
	case *ZMetricService_Vpnm:
		s := proto.Size(x.Vpnm)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ZMetricService_Lispm:
		s := proto.Size(x.Lispm)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ZMetricMsg struct {
	DevID string `protobuf:"bytes,1,opt,name=devID" json:"devID,omitempty"`
	// ZmetricTypes ztype = 2;  // deprecated
	AtTimeStamp *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=atTimeStamp" json:"atTimeStamp,omitempty"`
	// Types that are valid to be assigned to MetricContent:
	//	*ZMetricMsg_Dm
	MetricContent isZMetricMsg_MetricContent `protobuf_oneof:"MetricContent"`
	Am            []*AppMetric               `protobuf:"bytes,5,rep,name=am" json:"am,omitempty"`
	Sm            []*ZMetricService          `protobuf:"bytes,6,rep,name=sm" json:"sm,omitempty"`
}

func (m *ZMetricMsg) Reset()                    { *m = ZMetricMsg{} }
func (m *ZMetricMsg) String() string            { return proto.CompactTextString(m) }
func (*ZMetricMsg) ProtoMessage()               {}
func (*ZMetricMsg) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{47} }

type isZMetricMsg_MetricContent interface {
	isZMetricMsg_MetricContent()
}

type ZMetricMsg_Dm struct {
	Dm *DeviceMetric `protobuf:"bytes,4,opt,name=dm,oneof"`
}

func (*ZMetricMsg_Dm) isZMetricMsg_MetricContent() {}

func (m *ZMetricMsg) GetMetricContent() isZMetricMsg_MetricContent {
	if m != nil {
		return m.MetricContent
	}
	return nil
}

func (m *ZMetricMsg) GetDevID() string {
	if m != nil {
		return m.DevID
	}
	return ""
}

func (m *ZMetricMsg) GetAtTimeStamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.AtTimeStamp
	}
	return nil
}

func (m *ZMetricMsg) GetDm() *DeviceMetric {
	if x, ok := m.GetMetricContent().(*ZMetricMsg_Dm); ok {
		return x.Dm
	}
	return nil
}

func (m *ZMetricMsg) GetAm() []*AppMetric {
	if m != nil {
		return m.Am
	}
	return nil
}

func (m *ZMetricMsg) GetSm() []*ZMetricService {
	if m != nil {
		return m.Sm
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ZMetricMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ZMetricMsg_OneofMarshaler, _ZMetricMsg_OneofUnmarshaler, _ZMetricMsg_OneofSizer, []interface{}{
		(*ZMetricMsg_Dm)(nil),
	}
}

func _ZMetricMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ZMetricMsg)
	// MetricContent
	switch x := m.MetricContent.(type) {
	case *ZMetricMsg_Dm:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dm); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ZMetricMsg.MetricContent has unexpected type %T", x)
	}
	return nil
}

func _ZMetricMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ZMetricMsg)
	switch tag {
	case 4: // MetricContent.dm
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeviceMetric)
		err := b.DecodeMessage(msg)
		m.MetricContent = &ZMetricMsg_Dm{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ZMetricMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ZMetricMsg)
	// MetricContent
	switch x := m.MetricContent.(type) {
	case *ZMetricMsg_Dm:
		s := proto.Size(x.Dm)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ZInfoManufacturer)(nil), "ZInfoManufacturer")
	proto.RegisterType((*ZInfoNetwork)(nil), "ZInfoNetwork")
	proto.RegisterType((*GeoLoc)(nil), "GeoLoc")
	proto.RegisterType((*ZInfoDNS)(nil), "ZInfoDNS")
	proto.RegisterType((*ZinfoPeripheral)(nil), "ZinfoPeripheral")
	proto.RegisterType((*ZInfoSW)(nil), "ZInfoSW")
	proto.RegisterType((*ErrorInfo)(nil), "ErrorInfo")
	proto.RegisterType((*ZInfoDevice)(nil), "ZInfoDevice")
	proto.RegisterType((*ZInfoDevSW)(nil), "ZInfoDevSW")
	proto.RegisterType((*ZInfoStorage)(nil), "ZInfoStorage")
	proto.RegisterType((*ZInfoApp)(nil), "ZInfoApp")
	proto.RegisterType((*ZInfoVpnLinkInfo)(nil), "ZInfoVpnLinkInfo")
	proto.RegisterType((*ZInfoVpnLink)(nil), "ZInfoVpnLink")
	proto.RegisterType((*ZInfoVpnEndPoint)(nil), "ZInfoVpnEndPoint")
	proto.RegisterType((*ZInfoVpnConn)(nil), "ZInfoVpnConn")
	proto.RegisterType((*ZInfoVpn)(nil), "ZInfoVpn")
	proto.RegisterType((*RlocState)(nil), "RlocState")
	proto.RegisterType((*MapCacheEntry)(nil), "MapCacheEntry")
	proto.RegisterType((*DatabaseMap)(nil), "DatabaseMap")
	proto.RegisterType((*DecapKey)(nil), "DecapKey")
	proto.RegisterType((*ZInfoLisp)(nil), "ZInfoLisp")
	proto.RegisterType((*ZInfoService)(nil), "ZInfoService")
	proto.RegisterType((*ZInfoNetworkObject)(nil), "ZInfoNetworkObject")
	proto.RegisterType((*ZmetIPAssignmentEntry)(nil), "ZmetIPAssignmentEntry")
	proto.RegisterType((*ZInfoMsg)(nil), "ZInfoMsg")
	proto.RegisterType((*ZioBundle)(nil), "ZioBundle")
	proto.RegisterType((*MemoryMetric)(nil), "memoryMetric")
	proto.RegisterType((*NetworkMetric)(nil), "networkMetric")
	proto.RegisterType((*ZedcloudMetric)(nil), "zedcloudMetric")
	proto.RegisterType((*UrlcloudMetric)(nil), "urlcloudMetric")
	proto.RegisterType((*AppCpuMetric)(nil), "appCpuMetric")
	proto.RegisterType((*DeviceMetric)(nil), "deviceMetric")
	proto.RegisterType((*MetricItem)(nil), "MetricItem")
	proto.RegisterType((*DiskMetric)(nil), "diskMetric")
	proto.RegisterType((*AppDiskMetric)(nil), "appDiskMetric")
	proto.RegisterType((*AppMetric)(nil), "appMetric")
	proto.RegisterType((*PktStat)(nil), "PktStat")
	proto.RegisterType((*RlocStats)(nil), "RlocStats")
	proto.RegisterType((*EidStats)(nil), "EidStats")
	proto.RegisterType((*ZMetricLisp)(nil), "ZMetricLisp")
	proto.RegisterType((*ZMetricConn)(nil), "ZMetricConn")
	proto.RegisterType((*ZMetricVpn)(nil), "ZMetricVpn")
	proto.RegisterType((*ZMetricFlowLink)(nil), "ZMetricFlowLink")
	proto.RegisterType((*ZMetricFlowEndPoint)(nil), "ZMetricFlowEndPoint")
	proto.RegisterType((*ZMetricFlow)(nil), "ZMetricFlow")
	proto.RegisterType((*ZMetricLispGlobal)(nil), "ZMetricLispGlobal")
	proto.RegisterType((*ZMetricService)(nil), "ZMetricService")
	proto.RegisterType((*ZMetricMsg)(nil), "ZMetricMsg")
	proto.RegisterEnum("ZInfoTypes", ZInfoTypes_name, ZInfoTypes_value)
	proto.RegisterEnum("ZPeripheralTypes", ZPeripheralTypes_name, ZPeripheralTypes_value)
	proto.RegisterEnum("ZSwState", ZSwState_name, ZSwState_value)
	proto.RegisterEnum("ZInfoVpnState", ZInfoVpnState_name, ZInfoVpnState_value)
	proto.RegisterEnum("ZioType", ZioType_name, ZioType_value)
	proto.RegisterEnum("ZmetricTypes", ZmetricTypes_name, ZmetricTypes_value)
	proto.RegisterEnum("MetricItemType", MetricItemType_name, MetricItemType_value)
}

func init() { proto.RegisterFile("zmet.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 4186 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x6f, 0x24, 0x49,
	0x56, 0x77, 0x7d, 0xd9, 0x55, 0xaf, 0x5c, 0x76, 0x75, 0x74, 0xcf, 0xa8, 0xd4, 0xac, 0xa6, 0x7b,
	0x72, 0x66, 0x77, 0x5a, 0x9e, 0xa5, 0x7a, 0xe5, 0x19, 0x8d, 0x06, 0x34, 0x7b, 0xb0, 0x5d, 0xb5,
	0xed, 0xd2, 0xb8, 0xcb, 0x56, 0x56, 0xb7, 0x87, 0xb5, 0x04, 0xab, 0x74, 0x66, 0xb8, 0x9c, 0x38,
	0xbf, 0x88, 0x8c, 0xb2, 0xa7, 0xfa, 0x88, 0xf6, 0x82, 0xf6, 0xc0, 0x01, 0x89, 0x3d, 0x73, 0xe2,
	0x04, 0xda, 0xdb, 0xf2, 0x17, 0x70, 0x42, 0x42, 0x1c, 0x40, 0x42, 0x88, 0x03, 0x12, 0xe2, 0xcc,
	0x09, 0x71, 0x40, 0x02, 0xbd, 0x17, 0x11, 0x99, 0x51, 0x69, 0xf7, 0xc7, 0x5c, 0x38, 0xed, 0x2d,
	0xdf, 0xef, 0xbd, 0xf8, 0x7a, 0x5f, 0xf1, 0xe2, 0x55, 0x01, 0xbc, 0x8a, 0xb9, 0x1c, 0x66, 0x22,
	0x95, 0xe9, 0xc3, 0x47, 0xf3, 0x34, 0x9d, 0x47, 0xfc, 0x29, 0x51, 0xe7, 0x8b, 0x8b, 0xa7, 0x32,
	0x8c, 0x79, 0x2e, 0xbd, 0x38, 0x53, 0x02, 0xce, 0xaf, 0xeb, 0x70, 0xef, 0x6c, 0x92, 0x5c, 0xa4,
	0xcf, 0xbd, 0x64, 0x71, 0xe1, 0xf9, 0x72, 0x21, 0xb8, 0x60, 0x0e, 0x6c, 0xc6, 0x16, 0x3d, 0xa8,
	0x3d, 0xae, 0x3d, 0xe9, 0xb8, 0x2b, 0x18, 0x7b, 0x0c, 0xdd, 0x4c, 0xa4, 0xc1, 0xc2, 0x97, 0x53,
	0x2f, 0xe6, 0x83, 0x3a, 0x89, 0xd8, 0x10, 0x1b, 0xc0, 0xc6, 0x35, 0x17, 0x79, 0x98, 0x26, 0x83,
	0x06, 0x71, 0x0d, 0x89, 0xf3, 0xe7, 0x5c, 0x84, 0x5e, 0x34, 0x5d, 0xc4, 0xe7, 0x5c, 0x0c, 0x9a,
	0x6a, 0x7e, 0x1b, 0x63, 0x0c, 0x9a, 0x2f, 0x5f, 0x4e, 0x46, 0x83, 0x16, 0xf1, 0xe8, 0x9b, 0x7d,
	0x00, 0xe0, 0xa7, 0x71, 0xe6, 0xc9, 0xf0, 0x3c, 0xe2, 0x83, 0x75, 0xe2, 0x58, 0x08, 0xf2, 0xcf,
	0xc3, 0x34, 0x3f, 0xe5, 0x49, 0x90, 0x8a, 0xc1, 0x86, 0xe2, 0x97, 0x08, 0xee, 0x59, 0x51, 0x6a,
	0x57, 0x6d, 0xb5, 0x67, 0x0b, 0x62, 0x4f, 0x60, 0x1b, 0x49, 0x97, 0x47, 0xdc, 0xcb, 0xf9, 0xc8,
	0x93, 0x7c, 0xd0, 0x21, 0xa9, 0x2a, 0xec, 0xfc, 0x75, 0x1d, 0x36, 0x49, 0x73, 0x53, 0x2e, 0x6f,
	0x52, 0x71, 0x85, 0xc7, 0x8d, 0x3d, 0x7f, 0x2f, 0x08, 0x84, 0x39, 0xae, 0x26, 0x91, 0x13, 0xf0,
	0x6b, 0x52, 0x93, 0x3a, 0xa9, 0x21, 0x91, 0x33, 0x39, 0x41, 0x99, 0x7c, 0xd0, 0x7a, 0xdc, 0x40,
	0x8e, 0x26, 0xd9, 0x0f, 0x60, 0x2b, 0xe0, 0x17, 0xde, 0x22, 0x92, 0x6e, 0xba, 0x90, 0x5c, 0xe4,
	0x83, 0x75, 0x12, 0xa8, 0xa0, 0xec, 0xb7, 0xa0, 0x11, 0x24, 0x39, 0x9d, 0xb5, 0xbb, 0xdb, 0x19,
	0xd2, 0x8e, 0x46, 0xd3, 0x99, 0x8b, 0x28, 0xdb, 0x82, 0xfa, 0x22, 0xa3, 0x63, 0xb6, 0xdd, 0xfa,
	0x22, 0x63, 0x1f, 0x41, 0x3b, 0x4a, 0x7d, 0x4f, 0xe2, 0xe1, 0x3b, 0x34, 0x62, 0x63, 0xf8, 0x8c,
	0xa7, 0x47, 0xa9, 0xef, 0x16, 0x0c, 0xf6, 0x3e, 0xac, 0x2f, 0xb2, 0x28, 0x4c, 0xae, 0x06, 0x40,
	0x03, 0x35, 0xc5, 0x76, 0x00, 0x12, 0x75, 0xd4, 0xb1, 0x10, 0x83, 0x2e, 0x0d, 0x87, 0xe1, 0x58,
	0x88, 0x54, 0xe0, 0xa2, 0xae, 0xc5, 0x45, 0xe3, 0x25, 0x78, 0xdc, 0x4d, 0x65, 0x3c, 0xfc, 0x76,
	0xfe, 0xb6, 0x06, 0xeb, 0x6a, 0x31, 0xb4, 0xd3, 0xcb, 0x24, 0xe0, 0x22, 0xf2, 0x96, 0x93, 0x13,
	0xed, 0x5d, 0x16, 0xc2, 0x1e, 0x42, 0xfb, 0x30, 0xcd, 0x65, 0x52, 0x3a, 0x56, 0x41, 0xe3, 0xd4,
	0x07, 0xa1, 0x5c, 0x6a, 0x1d, 0xd3, 0x37, 0x6e, 0xd9, 0xe5, 0x73, 0x3c, 0x95, 0xd2, 0xaf, 0xa6,
	0x50, 0xbd, 0x07, 0xe9, 0x22, 0x91, 0x62, 0xa9, 0xdd, 0xc8, 0x90, 0xac, 0x0f, 0x8d, 0xa3, 0xd4,
	0xd7, 0x2e, 0x84, 0x9f, 0x88, 0x1c, 0x8b, 0xb9, 0x76, 0x1a, 0xfc, 0xc4, 0x59, 0x4f, 0xd2, 0x5c,
	0x7a, 0x91, 0x76, 0x14, 0x4d, 0x39, 0x17, 0xd0, 0x36, 0x6a, 0xc6, 0x93, 0x8c, 0xa6, 0xb3, 0x9c,
	0x0b, 0x74, 0xed, 0x41, 0x8d, 0x4c, 0x64, 0x21, 0xec, 0x7b, 0xd0, 0x19, 0x4d, 0x67, 0x41, 0x1a,
	0x7b, 0x61, 0xa2, 0x8f, 0x52, 0x02, 0x9a, 0x9b, 0x73, 0x4f, 0xf8, 0x97, 0x83, 0x06, 0x0d, 0x2e,
	0x01, 0xe7, 0x8f, 0x6b, 0xb0, 0x7d, 0x16, 0x26, 0x17, 0xe9, 0x09, 0x17, 0x61, 0x76, 0xc9, 0x85,
	0x17, 0xb1, 0x4f, 0xa0, 0xf5, 0x4a, 0x2e, 0x33, 0x4e, 0x4a, 0xdb, 0xda, 0xbd, 0x37, 0x3c, 0x2b,
	0x99, 0x2f, 0x96, 0x19, 0xcf, 0x5d, 0xc5, 0xc7, 0xa9, 0xb3, 0x68, 0x31, 0x9f, 0x7b, 0x18, 0x29,
	0x75, 0x32, 0x64, 0x09, 0xb0, 0x27, 0xd0, 0x8a, 0x71, 0x66, 0xd2, 0x62, 0x77, 0x97, 0x0d, 0x6f,
	0xe5, 0x00, 0x57, 0x09, 0x38, 0xff, 0x54, 0x83, 0x0d, 0x62, 0xce, 0xbe, 0xc1, 0x39, 0xf3, 0x1b,
	0x13, 0x3c, 0xfa, 0x30, 0x05, 0x80, 0xea, 0xca, 0x6f, 0x0e, 0xbd, 0xfc, 0x52, 0x9b, 0x46, 0x53,
	0xec, 0x11, 0xb4, 0x72, 0x89, 0x81, 0xd4, 0xa4, 0x2d, 0x77, 0x86, 0x67, 0xb3, 0x9b, 0x19, 0x02,
	0xae, 0xc2, 0x71, 0xa0, 0xf4, 0xc4, 0x9c, 0x4b, 0x6d, 0x0e, 0x4d, 0xa1, 0xa5, 0xaf, 0x03, 0x7e,
	0xad, 0x4d, 0x42, 0xdf, 0x6c, 0x07, 0xfa, 0x41, 0x7a, 0x93, 0x44, 0xa9, 0x17, 0x9c, 0x88, 0x74,
	0x2e, 0x78, 0x9e, 0x93, 0x75, 0x7a, 0xee, 0x2d, 0x1c, 0xb7, 0x1b, 0xc6, 0xde, 0x9c, 0x53, 0xe0,
	0xa9, 0x28, 0x2e, 0x01, 0x67, 0x0e, 0x9d, 0xc2, 0x77, 0x31, 0x31, 0x04, 0x3c, 0xf7, 0x45, 0x98,
	0x51, 0x6c, 0x28, 0x8f, 0xb4, 0x21, 0xf6, 0x25, 0x74, 0x8a, 0xdc, 0x49, 0x67, 0xef, 0xee, 0x3e,
	0x1c, 0xaa, 0xec, 0x3a, 0x34, 0xd9, 0x75, 0xf8, 0xc2, 0x48, 0xb8, 0xa5, 0xb0, 0xf3, 0xab, 0x26,
	0x74, 0x95, 0xbf, 0xf0, 0xeb, 0xd0, 0xe7, 0xb8, 0x56, 0xec, 0xf9, 0x97, 0x61, 0xc2, 0xf7, 0xd0,
	0xec, 0xca, 0x63, 0x6d, 0x08, 0xdd, 0xd6, 0xcf, 0x16, 0xc4, 0xd5, 0x6e, 0xab, 0x49, 0x0c, 0x8c,
	0x2c, 0xf2, 0xe4, 0x45, 0x2a, 0x62, 0xad, 0xac, 0x82, 0xa6, 0x98, 0xf3, 0xb3, 0x05, 0xa9, 0xab,
	0xe7, 0xd2, 0x37, 0xaa, 0x36, 0xe6, 0x71, 0x2a, 0x96, 0xa4, 0xa4, 0xa6, 0xab, 0x29, 0x5c, 0x21,
	0x97, 0xa9, 0xf0, 0xe6, 0x4a, 0x31, 0x4d, 0xd7, 0x90, 0xa5, 0x67, 0x74, 0xdf, 0xe2, 0x19, 0xec,
	0x13, 0xd8, 0xd0, 0x11, 0x3f, 0xe8, 0x3d, 0x6e, 0x3c, 0xe9, 0xee, 0xf6, 0x86, 0x76, 0x3e, 0x74,
	0x0d, 0x97, 0xfd, 0x2e, 0x30, 0x2f, 0xcf, 0xc3, 0x79, 0x82, 0xae, 0xb7, 0x17, 0x78, 0x19, 0xa5,
	0xb3, 0x6d, 0x1a, 0x03, 0xc3, 0xb3, 0x30, 0xdd, 0x5f, 0x24, 0x41, 0xc4, 0xdd, 0x3b, 0xa4, 0x4c,
	0x7a, 0xeb, 0xdf, 0x99, 0xde, 0x9e, 0x42, 0x57, 0x6f, 0xfb, 0x28, 0xcc, 0xe5, 0xe0, 0x9e, 0xbd,
	0x8b, 0x99, 0x62, 0xb8, 0xb6, 0x04, 0xfb, 0x02, 0xda, 0xe7, 0x69, 0x2a, 0xd1, 0x4c, 0x03, 0xf6,
	0x56, 0x1b, 0x16, 0xb2, 0xec, 0x23, 0x74, 0x6d, 0x5a, 0xe3, 0x3e, 0xad, 0xd1, 0x1d, 0x1a, 0x83,
	0xce, 0xbe, 0x71, 0x35, 0xcb, 0x24, 0x2d, 0xf2, 0xb6, 0x07, 0x65, 0xd2, 0xa2, 0x3c, 0xff, 0xdb,
	0xd0, 0x8d, 0xb9, 0x14, 0xa1, 0x3f, 0x91, 0x3c, 0xce, 0x07, 0xef, 0xe9, 0x59, 0x9e, 0x17, 0x98,
	0x6b, 0xf3, 0x9d, 0x7f, 0xa9, 0x03, 0x94, 0x2b, 0xa0, 0x23, 0x7b, 0xbe, 0x0c, 0xaf, 0x3d, 0xc9,
	0x03, 0x13, 0xcb, 0x05, 0x80, 0x37, 0x45, 0xe6, 0x09, 0x19, 0xa2, 0x9b, 0x1e, 0x79, 0xe7, 0x3c,
	0xd2, 0xf1, 0x57, 0x41, 0xf1, 0x6a, 0x2b, 0x10, 0xe5, 0x8a, 0xda, 0xf7, 0xaa, 0xf0, 0xca, 0x8c,
	0x14, 0xa9, 0xda, 0x0d, 0x2b, 0x28, 0xfb, 0x10, 0xd6, 0x31, 0x82, 0x17, 0x39, 0xf9, 0xe2, 0x4a,
	0x68, 0x6b, 0x06, 0xdd, 0xf4, 0x97, 0xa9, 0x90, 0x26, 0x6b, 0x6c, 0xe8, 0x9b, 0xde, 0xc2, 0x30,
	0x20, 0xa2, 0x34, 0x99, 0x57, 0x6e, 0x65, 0x0b, 0x62, 0x8f, 0xa1, 0x95, 0xdf, 0xe0, 0xad, 0xd3,
	0xb9, 0x75, 0xeb, 0x28, 0xc6, 0x9d, 0x79, 0x01, 0xee, 0xce, 0x0b, 0xce, 0xcf, 0x6b, 0xfa, 0xe6,
	0xd6, 0x3e, 0x82, 0x51, 0x12, 0x28, 0x85, 0xa8, 0xc0, 0xd7, 0x14, 0xea, 0x3d, 0xc6, 0xfb, 0xe2,
	0xc4, 0x93, 0x97, 0x26, 0xdf, 0x15, 0x00, 0x7b, 0x00, 0x2d, 0x99, 0xe2, 0xed, 0xd0, 0xa0, 0x08,
	0x52, 0x04, 0x6a, 0xd9, 0x78, 0x9c, 0xb9, 0x69, 0x9b, 0x64, 0xb1, 0x2a, 0xec, 0xfc, 0x7b, 0x5d,
	0xdf, 0x23, 0x7b, 0x59, 0x86, 0x93, 0xed, 0x65, 0xd9, 0x64, 0xa4, 0x77, 0xa0, 0x08, 0x4a, 0xb8,
	0xcb, 0x5c, 0xf2, 0x78, 0x2f, 0xcb, 0x48, 0xc7, 0x6d, 0xb7, 0x04, 0x30, 0x88, 0xf7, 0xb2, 0x8c,
	0xfc, 0x4d, 0xa9, 0xd5, 0x90, 0xec, 0x87, 0xb0, 0x99, 0xa7, 0x17, 0xf2, 0xc6, 0x13, 0x2a, 0x32,
	0xda, 0xe4, 0x6f, 0x6d, 0x1d, 0x19, 0xdf, 0xb8, 0x2b, 0xdc, 0x95, 0xa8, 0xd8, 0xfc, 0x0e, 0x51,
	0xf1, 0x05, 0xf4, 0x55, 0xc4, 0xf2, 0xa0, 0x88, 0xea, 0xde, 0xad, 0xa8, 0xbe, 0x25, 0xc3, 0x1c,
	0x58, 0xf7, 0xb2, 0x0c, 0xcd, 0xb9, 0xa5, 0xa5, 0x4b, 0x73, 0x6a, 0x4e, 0x79, 0x69, 0x6c, 0xbf,
	0xe6, 0xd2, 0xb0, 0xb2, 0x4f, 0xff, 0x4d, 0xd9, 0xc7, 0xf9, 0x03, 0xe8, 0x13, 0xe3, 0x34, 0x4b,
	0x8e, 0xc2, 0xe4, 0x8a, 0xd2, 0xfd, 0x03, 0x68, 0xe5, 0x59, 0x38, 0x09, 0x8c, 0xb6, 0x89, 0xa0,
	0x0b, 0x6c, 0x71, 0x3e, 0xe5, 0x52, 0xdb, 0x5a, 0x53, 0x68, 0x85, 0x20, 0x14, 0xdc, 0x97, 0xa6,
	0x92, 0x6d, 0xbb, 0x25, 0xe0, 0xfc, 0x97, 0xf1, 0x26, 0xbd, 0x00, 0x16, 0x5d, 0xa1, 0x99, 0xb9,
	0x1e, 0x06, 0x45, 0x2d, 0x54, 0x2f, 0x6b, 0x21, 0xdc, 0x80, 0xe0, 0x7f, 0x34, 0x09, 0x74, 0xa8,
	0x2a, 0x02, 0x33, 0x48, 0x98, 0xe4, 0xca, 0x10, 0x4d, 0x72, 0xaa, 0x82, 0x46, 0x63, 0xf3, 0x3c,
	0xc3, 0x75, 0xcc, 0x9d, 0xa0, 0x49, 0xf6, 0xb1, 0x51, 0x95, 0x0a, 0xc2, 0xad, 0xa1, 0xd9, 0x4d,
	0x45, 0x5f, 0xad, 0x88, 0x46, 0x03, 0x59, 0xf8, 0xde, 0xb0, 0xaa, 0x14, 0x57, 0xf1, 0x51, 0x90,
	0x4c, 0xa1, 0x2f, 0x80, 0xbb, 0x04, 0x89, 0xef, 0x4c, 0x4b, 0xc5, 0x8e, 0x93, 0xe0, 0x24, 0x0d,
	0x13, 0x79, 0xeb, 0xec, 0xef, 0xc3, 0x7a, 0x98, 0x51, 0x49, 0xac, 0x55, 0xaa, 0x28, 0xd4, 0x49,
	0x96, 0x0a, 0x49, 0xc7, 0xef, 0xb9, 0xf4, 0xed, 0xfc, 0xb2, 0x5e, 0x2a, 0xf2, 0x20, 0x4d, 0x92,
	0x77, 0x52, 0xe4, 0xeb, 0xdf, 0x18, 0xa4, 0x30, 0x5b, 0x97, 0x86, 0xc4, 0x79, 0xc2, 0x2b, 0x9e,
	0x9b, 0x97, 0x05, 0x7e, 0x7f, 0x57, 0x25, 0x6e, 0x54, 0x74, 0x63, 0x14, 0x70, 0x4b, 0x89, 0xed,
	0xd7, 0x0a, 0xaa, 0xc2, 0xe3, 0x23, 0x68, 0x61, 0x71, 0x8d, 0xc9, 0xca, 0x72, 0x62, 0xad, 0x6d,
	0x57, 0xf1, 0x9c, 0x3f, 0xab, 0xe9, 0x4c, 0x71, 0x9a, 0xe9, 0xf2, 0x9c, 0x8e, 0x55, 0x53, 0x57,
	0xba, 0xa2, 0xe8, 0x3d, 0x96, 0x46, 0xa1, 0xbf, 0xdc, 0xf7, 0xf2, 0xe2, 0x9a, 0xb0, 0x21, 0xcc,
	0x91, 0x51, 0x98, 0x4b, 0x9e, 0x84, 0xc9, 0x7c, 0x92, 0xa9, 0x57, 0x87, 0x2a, 0x3a, 0x6f, 0xe1,
	0xec, 0x43, 0x68, 0xfa, 0x69, 0x92, 0xdc, 0xda, 0x16, 0x1a, 0xc6, 0x25, 0x96, 0xf3, 0x63, 0xe8,
	0xb8, 0x51, 0xea, 0xab, 0xab, 0x80, 0x41, 0x13, 0x09, 0x6d, 0x2d, 0xfa, 0xc6, 0xb8, 0x71, 0xb9,
	0xe7, 0x5f, 0xda, 0x25, 0x68, 0x01, 0x38, 0x07, 0xd0, 0x7b, 0xee, 0x65, 0x07, 0x9e, 0x7f, 0xc9,
	0xc7, 0xa6, 0x24, 0x1f, 0x17, 0x09, 0x10, 0x3f, 0x31, 0xed, 0xe3, 0x44, 0xf9, 0xa0, 0xae, 0xf3,
	0x44, 0xb1, 0x9e, 0xab, 0x18, 0xce, 0x4f, 0xa1, 0x3b, 0xf2, 0xa4, 0x77, 0xee, 0xe5, 0xfc, 0xb9,
	0x97, 0xe1, 0x14, 0x13, 0x3d, 0x45, 0xd3, 0xc5, 0x4f, 0xf6, 0x25, 0x6c, 0xdb, 0xab, 0x84, 0xdc,
	0x4c, 0xb6, 0x35, 0x5c, 0x59, 0xdd, 0xad, 0x8a, 0x39, 0x53, 0x68, 0x8f, 0xb8, 0xef, 0x65, 0x5f,
	0xf3, 0xe5, 0x9d, 0xa7, 0x63, 0xd0, 0x3c, 0x41, 0x17, 0xae, 0xd3, 0x62, 0xf4, 0x8d, 0x01, 0xfc,
	0x35, 0x5f, 0xd2, 0x1b, 0x43, 0xdf, 0x0a, 0x05, 0xed, 0xfc, 0x5d, 0x0d, 0x3a, 0xa4, 0xc5, 0xa3,
	0x30, 0xcf, 0xd8, 0xc7, 0xd0, 0x9b, 0x48, 0x71, 0x20, 0x96, 0x99, 0x4c, 0x69, 0x1a, 0xb5, 0xe7,
	0x55, 0x10, 0x5f, 0x17, 0x63, 0x29, 0xa6, 0x9e, 0xb4, 0x56, 0xb2, 0x10, 0xe4, 0x4f, 0x12, 0xc9,
	0xc5, 0x85, 0xe7, 0x73, 0x63, 0x4b, 0x0b, 0x61, 0x3f, 0x82, 0x4d, 0x4b, 0x3d, 0xf9, 0xa0, 0x49,
	0x47, 0xdf, 0x1c, 0x5a, 0xa0, 0xbb, 0x22, 0xc1, 0x3e, 0x81, 0x8e, 0x39, 0xb5, 0x7a, 0x92, 0x62,
	0xd5, 0x65, 0x10, 0xb7, 0xe4, 0x39, 0xff, 0xd8, 0x30, 0x97, 0x28, 0x17, 0xe6, 0xb2, 0xcc, 0xd5,
	0x67, 0x61, 0xc4, 0x12, 0x40, 0xef, 0xd4, 0x84, 0xdd, 0x2d, 0xb0, 0x20, 0x4b, 0x02, 0xdf, 0x31,
	0x3a, 0x33, 0xd8, 0xd0, 0xad, 0x5b, 0xad, 0x49, 0xb1, 0xf5, 0xba, 0x5b, 0x6d, 0xa5, 0x68, 0x6a,
	0x55, 0x8b, 0xa6, 0xaf, 0xa0, 0xab, 0xe2, 0x66, 0x46, 0x05, 0xfd, 0xfa, 0x5b, 0xaf, 0x3d, 0x5b,
	0xfc, 0xce, 0x9b, 0x6f, 0xe3, 0xdd, 0x6e, 0xbe, 0xfc, 0xda, 0xc7, 0x9b, 0xaf, 0x7d, 0xfb, 0xe6,
	0x53, 0x1c, 0xfb, 0x62, 0xeb, 0xbc, 0xb1, 0xac, 0xfe, 0x10, 0x5a, 0xd7, 0x54, 0xa9, 0x3f, 0xb0,
	0x8b, 0xe3, 0xd3, 0x2c, 0x39, 0x5c, 0x73, 0x15, 0x87, 0x39, 0x94, 0x5d, 0x2e, 0xd2, 0xc1, 0x7b,
	0xba, 0x6e, 0x2a, 0x1c, 0x10, 0x65, 0x88, 0xb5, 0xdf, 0x83, 0x2e, 0x82, 0x07, 0x69, 0x22, 0x79,
	0x22, 0x9d, 0xff, 0x6c, 0x02, 0xb3, 0xd7, 0x3b, 0x3e, 0xff, 0x43, 0xee, 0x93, 0x36, 0xf5, 0xba,
	0xa5, 0x75, 0x0b, 0x00, 0x6d, 0xa7, 0x09, 0xb2, 0x5d, 0x5d, 0xd9, 0xce, 0x82, 0x30, 0x32, 0x82,
	0x4b, 0x3f, 0xb3, 0x4c, 0x5b, 0xd0, 0xfa, 0xde, 0x4d, 0xb8, 0x34, 0xaf, 0x77, 0x45, 0x61, 0x06,
	0x9f, 0x7b, 0x92, 0xdf, 0x78, 0xc5, 0xeb, 0x5d, 0x93, 0xe8, 0xf7, 0xea, 0x05, 0x4d, 0xf7, 0x81,
	0xee, 0x03, 0x95, 0x08, 0xed, 0x56, 0x66, 0x33, 0x7a, 0x83, 0xeb, 0xda, 0xa8, 0x04, 0x68, 0x74,
	0x92, 0xcf, 0xf4, 0x9b, 0xbd, 0xad, 0xa2, 0xa6, 0x44, 0xb0, 0x66, 0xc5, 0xbd, 0xb9, 0x5e, 0x82,
	0xd5, 0xda, 0x8d, 0x7e, 0x3a, 0xae, 0x60, 0x18, 0xbf, 0x05, 0x7d, 0x18, 0xce, 0x2f, 0xe9, 0x5a,
	0xed, 0xb8, 0xab, 0x20, 0xee, 0xe3, 0x5c, 0x84, 0xc1, 0x9c, 0x4f, 0x17, 0x31, 0x95, 0x56, 0x3d,
	0xb7, 0x04, 0xa8, 0x5b, 0xa5, 0x08, 0x3c, 0x45, 0x4f, 0x77, 0xab, 0x0a, 0x04, 0xf7, 0xa1, 0x28,
	0xd5, 0x13, 0x1a, 0x6c, 0xa9, 0x7d, 0xd8, 0x18, 0xfb, 0x0a, 0x7a, 0x61, 0xb6, 0x47, 0x7e, 0x16,
	0xf3, 0x44, 0x9a, 0x67, 0xd5, 0xfb, 0xc3, 0xb3, 0x98, 0xcb, 0xc9, 0x49, 0xc9, 0x51, 0x59, 0x6e,
	0x55, 0xd8, 0x5e, 0x61, 0xc6, 0x65, 0x4e, 0x95, 0x94, 0xb5, 0x02, 0x62, 0x68, 0xb9, 0xeb, 0xf0,
	0x02, 0x37, 0x94, 0xd3, 0x0b, 0xab, 0xe3, 0x16, 0x34, 0x5a, 0x28, 0xcc, 0xae, 0x3f, 0x1f, 0x87,
	0x01, 0x3d, 0xa7, 0xda, 0xae, 0x21, 0x2b, 0xcd, 0xa2, 0xfb, 0xb7, 0xbc, 0xdd, 0xe2, 0x3a, 0x2f,
	0xe1, 0xbd, 0x3b, 0x77, 0x8b, 0x0a, 0xd2, 0x2d, 0x34, 0x2c, 0xe7, 0x75, 0x9b, 0xa8, 0x44, 0xe8,
	0x81, 0x9f, 0x19, 0x76, 0x5d, 0xb5, 0x4f, 0x0a, 0xc0, 0xf9, 0x2b, 0x53, 0x5f, 0x3f, 0xcf, 0xe7,
	0x18, 0x2c, 0x76, 0xdf, 0x44, 0x3f, 0xe0, 0x56, 0x3a, 0x26, 0x0f, 0xa0, 0x15, 0xf0, 0xeb, 0x49,
	0xa0, 0x93, 0x93, 0x22, 0xb0, 0x30, 0x08, 0xac, 0x4e, 0xc9, 0xe6, 0xd0, 0x7a, 0xca, 0x63, 0x10,
	0x11, 0x13, 0xa7, 0xf7, 0x42, 0x53, 0x9b, 0x15, 0xb1, 0xb8, 0x97, 0x51, 0x9c, 0x11, 0x87, 0x7d,
	0x1f, 0x5a, 0x79, 0x58, 0x16, 0x60, 0xe6, 0x99, 0xaa, 0xf2, 0x1b, 0x8a, 0x11, 0x97, 0x7d, 0x0a,
	0xad, 0xc4, 0x7a, 0x7f, 0xdf, 0x1f, 0xde, 0x0e, 0x46, 0x14, 0x26, 0x19, 0xcc, 0x62, 0x9e, 0xfc,
	0x4e, 0x59, 0xcc, 0x12, 0xaf, 0x46, 0xfe, 0x5f, 0xe0, 0x05, 0x65, 0x92, 0x17, 0xfb, 0x1e, 0x34,
	0x2d, 0x7d, 0xb5, 0x31, 0xad, 0xa1, 0xb6, 0x5c, 0x42, 0x5f, 0x57, 0x8a, 0xc5, 0x3c, 0x3e, 0xe7,
	0x45, 0x55, 0x61, 0x48, 0x0c, 0x96, 0x45, 0xce, 0x83, 0xfd, 0xe5, 0x5e, 0x96, 0x51, 0x4f, 0x57,
	0xc5, 0xf9, 0x2a, 0x88, 0xce, 0xa8, 0x00, 0xac, 0x56, 0x8e, 0x67, 0x3a, 0x67, 0xaf, 0x60, 0xce,
	0x9f, 0xd7, 0x60, 0x53, 0xb5, 0x30, 0xd4, 0xd3, 0x19, 0x17, 0x45, 0x81, 0xe7, 0x3c, 0xd6, 0x59,
	0xc7, 0x90, 0xe8, 0xb7, 0xde, 0xb5, 0x17, 0x46, 0xc8, 0xd2, 0x19, 0xc7, 0xd0, 0xf8, 0xc0, 0x45,
	0xb1, 0x13, 0x2e, 0x7c, 0x9e, 0x48, 0x6f, 0xae, 0x4a, 0xc4, 0x9a, 0x5b, 0x41, 0xf1, 0x31, 0x47,
	0x63, 0x2c, 0xc1, 0x16, 0x09, 0x56, 0x61, 0xe7, 0x5f, 0x1b, 0xd0, 0xd3, 0x2e, 0xad, 0x77, 0xf6,
	0x00, 0x5a, 0x21, 0x05, 0xb6, 0x7e, 0x63, 0x84, 0xa6, 0xe1, 0x2b, 0xbf, 0xdd, 0x5f, 0x4a, 0xaa,
	0x43, 0xa8, 0x2a, 0xd5, 0x24, 0x72, 0x84, 0xe6, 0xa8, 0xd2, 0xc1, 0x90, 0x6a, 0xcc, 0x48, 0xa4,
	0x74, 0x81, 0xeb, 0x31, 0x44, 0xaa, 0x31, 0x8a, 0xd3, 0x32, 0x63, 0x14, 0xe7, 0x7d, 0x58, 0x97,
	0xdf, 0xba, 0xa6, 0xa0, 0x6d, 0xba, 0x9a, 0x42, 0x5c, 0x28, 0x7c, 0x43, 0xe1, 0xa2, 0xc0, 0xe5,
	0xb7, 0x27, 0x57, 0x32, 0x37, 0x8d, 0x22, 0x45, 0x29, 0x79, 0xc2, 0x3b, 0x46, 0x9e, 0xf0, 0x87,
	0xd0, 0x96, 0xdf, 0x52, 0x38, 0xab, 0x77, 0x76, 0xd3, 0x2d, 0x68, 0xe4, 0x09, 0xc3, 0xeb, 0x2a,
	0x9e, 0xa1, 0x31, 0xa4, 0xe5, 0xb7, 0x7b, 0x7e, 0xa4, 0x36, 0xbd, 0xa9, 0x2a, 0x9a, 0x12, 0x41,
	0xbe, 0x28, 0xf9, 0x3d, 0xc5, 0x2f, 0x11, 0xf6, 0x23, 0xb8, 0x4f, 0xd2, 0xb8, 0xe9, 0xa3, 0x30,
	0x0e, 0xa5, 0x12, 0xdc, 0x22, 0xc1, 0xbb, 0x58, 0x38, 0x42, 0xdc, 0x31, 0x62, 0x5b, 0x8d, 0xb8,
	0x83, 0x55, 0x38, 0x77, 0xdf, 0x6a, 0x5e, 0xff, 0xa2, 0x0e, 0x5b, 0xaf, 0x78, 0xe0, 0x47, 0xe9,
	0x22, 0xd0, 0x06, 0xc6, 0xb7, 0xcd, 0x85, 0x65, 0x61, 0x4d, 0xe1, 0xf1, 0x2f, 0xbc, 0x30, 0x5a,
	0x88, 0xc2, 0xc6, 0x05, 0x4d, 0x7d, 0xb7, 0x85, 0xef, 0x63, 0xbe, 0xd2, 0x46, 0xd6, 0x24, 0x86,
	0x72, 0xe4, 0xe5, 0xf2, 0x27, 0x4a, 0x52, 0xd7, 0x36, 0x6f, 0x0c, 0x65, 0x4b, 0xdc, 0x8c, 0x9e,
	0xe9, 0xb9, 0x5b, 0xef, 0x36, 0x5a, 0x8b, 0xb3, 0xa7, 0x00, 0x0b, 0x11, 0xa9, 0x63, 0xa9, 0xdf,
	0x19, 0xba, 0xbb, 0xdb, 0xc3, 0x85, 0x88, 0xac, 0xe3, 0xba, 0x96, 0x88, 0xf3, 0x3f, 0x35, 0xd8,
	0x5a, 0x65, 0x63, 0xe9, 0xbd, 0x10, 0x91, 0xa9, 0xde, 0x17, 0x22, 0xc2, 0xa2, 0x40, 0x8a, 0xe5,
	0xf3, 0x7c, 0xae, 0xea, 0x61, 0x54, 0x45, 0xc3, 0xb5, 0x21, 0x8c, 0x78, 0x29, 0x96, 0xe8, 0xe4,
	0x65, 0xc9, 0xdc, 0x70, 0x57, 0x30, 0xf5, 0x53, 0x51, 0x22, 0x8b, 0x69, 0x9a, 0x4a, 0xc6, 0xc6,
	0x30, 0xbf, 0x20, 0x5d, 0x4e, 0xd4, 0x22, 0xa1, 0x55, 0x10, 0x67, 0x12, 0xdc, 0xbf, 0x2e, 0x66,
	0x5a, 0x57, 0x33, 0xd9, 0x18, 0xce, 0x84, 0x74, 0x39, 0xd3, 0x86, 0x9a, 0x69, 0x05, 0x74, 0x7e,
	0x0f, 0x36, 0xbd, 0x2c, 0x3b, 0xc8, 0x16, 0xfa, 0xec, 0xbb, 0xc5, 0x93, 0xec, 0xed, 0x66, 0x33,
	0xcf, 0xb5, 0xa2, 0x7b, 0xd4, 0xb2, 0xba, 0x47, 0xce, 0x9f, 0xd4, 0x61, 0x53, 0x35, 0x9f, 0xf4,
	0xd4, 0xdf, 0x2f, 0x1a, 0xb8, 0x75, 0x7d, 0x6d, 0xd8, 0xe9, 0xaf, 0xe8, 0xe7, 0x3e, 0x29, 0x8b,
	0xc6, 0x86, 0x7e, 0xde, 0xac, 0x64, 0xa3, 0xb2, 0x6a, 0xfc, 0x14, 0xda, 0xc6, 0x8f, 0xf5, 0x73,
	0x60, 0x7b, 0xb8, 0xea, 0xd8, 0x6e, 0x21, 0xc0, 0x1e, 0x41, 0x33, 0x08, 0xf3, 0x2b, 0xed, 0x12,
	0xdd, 0x21, 0x12, 0x5a, 0x88, 0x18, 0xec, 0x53, 0xe8, 0xf8, 0x46, 0x0d, 0xfa, 0x51, 0xdc, 0x1b,
	0xda, 0xba, 0x71, 0x4b, 0x7e, 0xb5, 0x09, 0xda, 0x7e, 0x4b, 0x13, 0xf4, 0xe7, 0x75, 0x80, 0x92,
	0x87, 0x0e, 0x76, 0xc5, 0x97, 0xc6, 0xc1, 0xae, 0xf8, 0x92, 0x7d, 0xa4, 0xaf, 0xa8, 0x3a, 0x5d,
	0x51, 0xdb, 0xd6, 0x44, 0xd6, 0x4d, 0xf5, 0x01, 0x74, 0xce, 0xd3, 0x34, 0x3a, 0xf5, 0xa2, 0x85,
	0xaa, 0x3c, 0xdb, 0x87, 0x6b, 0x6e, 0x09, 0x31, 0x07, 0xba, 0x8b, 0x30, 0x91, 0x9f, 0xed, 0x2a,
	0x09, 0x34, 0x60, 0xef, 0x70, 0xcd, 0xb5, 0x41, 0x23, 0xf3, 0xc5, 0xe7, 0x4a, 0x86, 0x2c, 0x66,
	0x64, 0x34, 0xc8, 0x1e, 0x03, 0x5c, 0x44, 0xa9, 0x27, 0x95, 0x08, 0xfa, 0x56, 0xfd, 0x70, 0xcd,
	0xb5, 0x30, 0x9c, 0x25, 0x97, 0x22, 0x4c, 0xe6, 0x4a, 0x84, 0xca, 0x52, 0x9c, 0xc5, 0x02, 0xf7,
	0xef, 0xc1, 0x76, 0xa9, 0x02, 0x82, 0x9c, 0xff, 0xae, 0x01, 0x94, 0x7a, 0xc7, 0xe4, 0x44, 0x26,
	0xd1, 0x4f, 0x51, 0xb2, 0xc2, 0x9b, 0xfb, 0x94, 0xdf, 0x83, 0x8e, 0xe0, 0x5e, 0x60, 0x5f, 0x2d,
	0x25, 0x80, 0x09, 0xf7, 0x46, 0x84, 0x92, 0x2b, 0xb6, 0xba, 0x5f, 0x2c, 0xc4, 0x8c, 0x2e, 0xe3,
	0x4a, 0x8f, 0x56, 0xf1, 0x62, 0x46, 0x97, 0x11, 0x65, 0x46, 0x2b, 0x7e, 0xe1, 0xe5, 0x1b, 0x76,
	0x8f, 0x94, 0x41, 0x13, 0x2f, 0x5a, 0x7d, 0xd5, 0xd0, 0x37, 0x62, 0x17, 0x82, 0x9b, 0x9f, 0x23,
	0xe8, 0xdb, 0xf9, 0x45, 0x0d, 0x7a, 0x5e, 0x96, 0x8d, 0xde, 0x7c, 0x7a, 0xf5, 0x43, 0xf4, 0x75,
	0x98, 0x87, 0x69, 0xa2, 0x1b, 0x1f, 0x4d, 0xd7, 0x86, 0x8a, 0xf5, 0x1a, 0xd6, 0x7a, 0xf8, 0x20,
	0x09, 0x73, 0xf5, 0x5e, 0x51, 0xe5, 0x48, 0x41, 0x53, 0x25, 0x18, 0x0a, 0xb9, 0xd4, 0x25, 0x88,
	0x22, 0x9c, 0x7f, 0xa8, 0x41, 0xc7, 0xcb, 0xb2, 0xf2, 0x7a, 0xbf, 0xa3, 0x61, 0x6b, 0xb5, 0x64,
	0xeb, 0xab, 0x2d, 0xd9, 0x47, 0xd0, 0xf0, 0xb3, 0x85, 0xae, 0x22, 0x2b, 0x31, 0x82, 0x1c, 0x2b,
	0xd2, 0x9b, 0xef, 0x18, 0xe9, 0xad, 0x37, 0x47, 0xba, 0xb3, 0x12, 0xbc, 0x5b, 0xc3, 0x15, 0x4d,
	0x2a, 0xdd, 0x39, 0xbf, 0x03, 0x1b, 0x27, 0x57, 0x72, 0x26, 0x3d, 0x7a, 0x6d, 0x9d, 0x78, 0xfe,
	0x15, 0x3e, 0x03, 0x54, 0x2f, 0xc2, 0x90, 0x78, 0x54, 0xbb, 0x62, 0x51, 0x84, 0x73, 0x53, 0xb6,
	0x7f, 0xf2, 0x3b, 0x1b, 0x24, 0x1f, 0x40, 0x8b, 0x98, 0x3a, 0x73, 0xb5, 0x87, 0x7a, 0x25, 0x57,
	0xc1, 0xec, 0x0b, 0x78, 0x7f, 0xc6, 0xfd, 0x34, 0x09, 0xf2, 0x59, 0x98, 0xf8, 0xfc, 0xc8, 0xcb,
	0xa5, 0x5a, 0x51, 0xdb, 0xe9, 0x35, 0x5c, 0xe7, 0x02, 0xda, 0xe3, 0x30, 0x50, 0x73, 0xdc, 0x6e,
	0xf8, 0xe8, 0x2e, 0x52, 0xbd, 0xec, 0x22, 0x7d, 0x01, 0xfd, 0x62, 0xa3, 0xa6, 0x07, 0xd4, 0xa8,
	0x34, 0x94, 0x72, 0xf7, 0x96, 0x8c, 0xf3, 0x1f, 0x4d, 0xe8, 0x9e, 0x29, 0x6d, 0x51, 0xcb, 0xe6,
	0x33, 0xd8, 0x36, 0xeb, 0x9a, 0x69, 0x6a, 0xba, 0x41, 0x62, 0x70, 0xb7, 0x2a, 0xc1, 0xbe, 0x04,
	0x36, 0x91, 0x42, 0xed, 0x7c, 0xc6, 0x93, 0x80, 0xca, 0xa0, 0x5b, 0x1a, 0xb9, 0x43, 0x86, 0xed,
	0xc2, 0xf6, 0x24, 0xb9, 0xf6, 0xa2, 0x30, 0x18, 0x87, 0x7a, 0x58, 0xa3, 0x32, 0xac, 0x2a, 0xc0,
	0x7e, 0x08, 0x9b, 0xd3, 0x74, 0xc4, 0x7d, 0xb1, 0xcc, 0xe4, 0xd7, 0x7c, 0x59, 0x74, 0x48, 0xcc,
	0x80, 0x15, 0x2e, 0xfb, 0x1c, 0xfa, 0xc7, 0x0b, 0xc9, 0xc5, 0x21, 0xf7, 0x02, 0x2e, 0xd4, 0x12,
	0xad, 0xca, 0x88, 0x5b, 0x12, 0xb8, 0xaf, 0x7d, 0x2f, 0x98, 0x24, 0x09, 0x17, 0xe6, 0x17, 0x9b,
	0xf5, 0xea, 0xbe, 0x2a, 0x02, 0x6c, 0x07, 0xba, 0xcf, 0xd2, 0x34, 0x30, 0xfe, 0xb5, 0x51, 0x91,
	0xb7, 0x99, 0xec, 0x63, 0x68, 0x4f, 0x0e, 0x4e, 0xd5, 0x6e, 0xda, 0x15, 0xc1, 0x82, 0x83, 0xbb,
	0xa0, 0x36, 0x86, 0xb5, 0xf5, 0x4e, 0x75, 0x17, 0x15, 0x01, 0x36, 0x84, 0xde, 0xc1, 0x25, 0xf7,
	0xaf, 0x66, 0x8b, 0x58, 0x8d, 0x80, 0xca, 0x88, 0x55, 0x36, 0xda, 0x8e, 0xfa, 0x5d, 0x2e, 0x9f,
	0x24, 0xf8, 0xee, 0x52, 0x83, 0xba, 0x55, 0xdb, 0xdd, 0x96, 0x41, 0x3b, 0x68, 0x3d, 0xab, 0x31,
	0x9b, 0x55, 0x3b, 0xd8, 0x5c, 0xe7, 0x2f, 0x6b, 0x85, 0xa3, 0x51, 0xdf, 0xfb, 0x31, 0xac, 0x4f,
	0x12, 0xaa, 0xb9, 0x6b, 0x95, 0x71, 0x1a, 0x67, 0x0e, 0x6c, 0x1c, 0x2f, 0x24, 0x89, 0x54, 0x5d,
	0xc9, 0x30, 0x50, 0x66, 0x2c, 0x04, 0xc9, 0x54, 0xfd, 0xc6, 0x30, 0x48, 0x23, 0x9e, 0x08, 0x49,
	0x41, 0x24, 0xd9, 0xbc, 0xa5, 0x11, 0x9b, 0xed, 0xfc, 0xaa, 0x06, 0xa0, 0x77, 0x7a, 0x9a, 0x25,
	0xec, 0x09, 0xb4, 0x71, 0xc3, 0x28, 0xa9, 0xb7, 0xba, 0x39, 0xb4, 0x0e, 0xe2, 0x16, 0x5c, 0xf6,
	0x03, 0xd8, 0x98, 0x5c, 0x71, 0x12, 0xac, 0xdf, 0x21, 0x68, 0x98, 0x38, 0xe3, 0xd4, 0x93, 0x2f,
	0x48, 0xb0, 0x71, 0xd7, 0x8c, 0x86, 0x8b, 0x33, 0x8e, 0xf3, 0x8c, 0x04, 0x9b, 0x77, 0xcd, 0xa8,
	0x99, 0xce, 0xef, 0xc3, 0xb6, 0xc6, 0x7f, 0x12, 0xa5, 0x37, 0xf4, 0x03, 0xcd, 0xa0, 0xf8, 0x9d,
	0xa7, 0xa6, 0xef, 0x60, 0xf3, 0x4b, 0x0f, 0x83, 0x06, 0x0f, 0x75, 0x03, 0xe0, 0x70, 0xcd, 0x45,
	0xa2, 0xfc, 0xad, 0xa8, 0x61, 0xfd, 0x56, 0xb4, 0xbf, 0x0e, 0x4d, 0x9c, 0xcb, 0xf9, 0x65, 0x0d,
	0xee, 0x5b, 0xf3, 0x17, 0x3f, 0x84, 0x0c, 0x8a, 0x1f, 0x3e, 0x8a, 0x35, 0xf4, 0x4f, 0x1f, 0x0f,
	0xa0, 0x29, 0x30, 0x55, 0x9a, 0x45, 0x88, 0x62, 0x1f, 0x43, 0x93, 0xfe, 0x72, 0xa3, 0x72, 0x7a,
	0x7f, 0x58, 0xd9, 0xb3, 0x4b, 0x5c, 0x4c, 0xa9, 0x39, 0xa5, 0xd4, 0xaa, 0xe7, 0x2a, 0x78, 0x1f,
	0xa0, 0x3d, 0x4e, 0x82, 0x0c, 0x77, 0xe0, 0xfc, 0x73, 0xe9, 0x55, 0x38, 0xcb, 0x3b, 0xfd, 0x9a,
	0xc2, 0x74, 0x45, 0xa5, 0x7f, 0x96, 0xa1, 0x02, 0xaa, 0x0f, 0x8d, 0x30, 0x0c, 0x74, 0x65, 0x80,
	0x9f, 0xf6, 0x2f, 0x2b, 0xad, 0xd5, 0x5f, 0x56, 0x76, 0xa1, 0x13, 0x19, 0x15, 0xe8, 0x3d, 0x3e,
	0x18, 0xde, 0xa1, 0x1e, 0xb7, 0x14, 0xc3, 0x31, 0xa2, 0x18, 0xd3, 0xa5, 0xe3, 0xbf, 0x66, 0x4c,
	0x21, 0xe6, 0xfc, 0xba, 0x09, 0xf7, 0xac, 0xd4, 0xfc, 0x2c, 0x4a, 0xcf, 0xbd, 0xe8, 0x37, 0xb9,
	0xf6, 0x37, 0xb9, 0xf6, 0xad, 0xb9, 0xf6, 0xdf, 0xea, 0xb0, 0xa5, 0x3d, 0xe7, 0xff, 0xef, 0x87,
	0x0b, 0xab, 0x66, 0x6b, 0xbe, 0xb9, 0x66, 0xfb, 0x10, 0x9a, 0xd7, 0x59, 0x12, 0xeb, 0x96, 0x7e,
	0x77, 0x58, 0x26, 0x5b, 0xcc, 0x14, 0xc8, 0x62, 0x1f, 0x43, 0x2b, 0x0a, 0xf3, 0x2c, 0xd6, 0x3d,
	0xfd, 0x22, 0xed, 0x95, 0x5d, 0xfd, 0x3c, 0x8b, 0xd9, 0x0e, 0x74, 0x2e, 0xa2, 0xf4, 0x66, 0xa6,
	0xb3, 0x45, 0xc3, 0x96, 0xc4, 0xa8, 0x72, 0x4b, 0x36, 0xfb, 0x0a, 0xb6, 0xa3, 0x22, 0x8a, 0xd4,
	0x88, 0xe2, 0xcf, 0x3f, 0xd5, 0x20, 0x73, 0xab, 0xa2, 0xfb, 0x7d, 0xd8, 0xd2, 0x9a, 0x34, 0x8d,
	0xc4, 0xbf, 0x2f, 0x6f, 0x89, 0xe7, 0xf9, 0xdc, 0xf4, 0x55, 0x8b, 0x4a, 0x99, 0x88, 0x6a, 0xeb,
	0xb2, 0xf1, 0x9d, 0x5a, 0x97, 0xec, 0x11, 0xd4, 0x83, 0xb8, 0x28, 0x94, 0xed, 0x17, 0xf3, 0xe1,
	0x9a, 0x5b, 0x0f, 0x62, 0xf6, 0x10, 0xea, 0x5e, 0xac, 0xb3, 0x29, 0x0c, 0x8b, 0xb2, 0xdd, 0xad,
	0x7b, 0x31, 0x0e, 0xce, 0xe3, 0xa2, 0xcd, 0xb1, 0xea, 0x0d, 0x6e, 0x3d, 0x8f, 0xf7, 0xb7, 0xa1,
	0x57, 0x5c, 0x25, 0x78, 0xa2, 0x9d, 0x17, 0xfa, 0xef, 0x38, 0xd4, 0x2f, 0x66, 0x1d, 0x68, 0x9d,
	0x85, 0xd3, 0x34, 0xeb, 0xaf, 0xb1, 0x4d, 0x68, 0x9f, 0x85, 0xaa, 0x19, 0xdc, 0xaf, 0x29, 0xc6,
	0x5e, 0x96, 0xf5, 0x1b, 0xac, 0x07, 0x9d, 0xb3, 0x50, 0xcf, 0xd9, 0x6f, 0xb2, 0xfb, 0xb0, 0x7d,
	0x16, 0xae, 0x34, 0x71, 0xfb, 0xad, 0x9d, 0xaf, 0xa0, 0x5f, 0xfd, 0xf7, 0x1e, 0x03, 0x58, 0x3f,
	0xcb, 0xa6, 0x69, 0xc2, 0xfb, 0x6b, 0x34, 0x47, 0xa6, 0xff, 0xa3, 0xd2, 0xaf, 0x29, 0x52, 0xcf,
	0xd1, 0xaf, 0xef, 0xfc, 0x4d, 0x0d, 0xda, 0xe6, 0x4f, 0x11, 0xac, 0x0b, 0x1b, 0x93, 0xe9, 0xe9,
	0xde, 0xd1, 0x64, 0xd4, 0x5f, 0x53, 0xc4, 0xe4, 0xc5, 0x64, 0xef, 0xa8, 0x5f, 0x63, 0x0f, 0xa0,
	0x3f, 0x3a, 0xfe, 0x66, 0x7a, 0x74, 0xbc, 0x37, 0xfa, 0xd9, 0xec, 0xc5, 0x9e, 0xfb, 0x62, 0x3c,
	0xea, 0xd7, 0xd9, 0x16, 0x80, 0x41, 0xc7, 0x23, 0xb5, 0xdd, 0xd1, 0xf8, 0x68, 0x72, 0x3a, 0x76,
	0xc7, 0xa3, 0x7e, 0x13, 0xc9, 0xc9, 0x74, 0xf6, 0x62, 0xef, 0xe8, 0x68, 0x3c, 0xea, 0xb7, 0x70,
	0xc2, 0xfd, 0xe3, 0xe3, 0x17, 0x93, 0xe9, 0xb3, 0xfe, 0x3a, 0x12, 0xee, 0xcb, 0xe9, 0x14, 0x89,
	0x0d, 0x24, 0x0e, 0xf7, 0x8e, 0x88, 0xd3, 0xc6, 0xbd, 0x23, 0x31, 0x1e, 0xf5, 0x3b, 0xb8, 0x80,
	0x3b, 0xa6, 0xf5, 0x90, 0x07, 0x28, 0x78, 0xf2, 0xd2, 0x7d, 0x86, 0x44, 0x77, 0xe7, 0x4f, 0x6b,
	0xd0, 0x5b, 0xf9, 0x7d, 0x9d, 0x6d, 0x43, 0xf7, 0xf4, 0x64, 0xfa, 0xb3, 0xf2, 0x0c, 0x05, 0x60,
	0xce, 0xc1, 0x60, 0x0b, 0x81, 0x83, 0xe3, 0xe9, 0x74, 0x7c, 0x40, 0x93, 0xd6, 0x51, 0xab, 0x88,
	0xe1, 0x3a, 0xfb, 0x47, 0x93, 0xd9, 0x21, 0x1d, 0xe5, 0x1e, 0xf4, 0xd4, 0x48, 0xb3, 0xff, 0xa6,
	0x99, 0xcc, 0x1d, 0x7f, 0x3d, 0xfe, 0x29, 0x1d, 0x48, 0x03, 0xa3, 0xf1, 0xd1, 0x18, 0xb7, 0x0b,
	0x3b, 0x87, 0xb0, 0xa1, 0x1b, 0xdc, 0x64, 0x81, 0x30, 0x55, 0xe6, 0x55, 0xdf, 0x63, 0x79, 0xd9,
	0xaf, 0xe9, 0xef, 0x97, 0xb3, 0xfd, 0x7e, 0x5d, 0x7f, 0x1f, 0x1c, 0x3f, 0x27, 0xd5, 0xb5, 0xcf,
	0xc2, 0xf4, 0x58, 0x5e, 0x72, 0xd1, 0xff, 0xdf, 0xda, 0xce, 0x2e, 0x6c, 0x9e, 0xa9, 0x27, 0x7c,
	0xe9, 0x2c, 0x71, 0xe9, 0x2c, 0xf1, 0x8a, 0xb3, 0xc4, 0xe4, 0x2c, 0x3b, 0x17, 0xb0, 0xb5, 0xda,
	0xbb, 0xc0, 0x93, 0x95, 0x88, 0x9a, 0x7b, 0x6d, 0x15, 0x7c, 0xe6, 0x2d, 0xc8, 0x2b, 0xde, 0x83,
	0x7b, 0x25, 0x48, 0x8f, 0x6e, 0x2e, 0x94, 0x6a, 0x4a, 0x98, 0x74, 0xdc, 0x6f, 0xec, 0xff, 0x18,
	0x1e, 0xf9, 0x69, 0x3c, 0x7c, 0xc5, 0x03, 0x1e, 0x78, 0x43, 0x6a, 0xf1, 0x0c, 0x17, 0x3a, 0x51,
	0xa9, 0x90, 0x3b, 0x7b, 0x38, 0x0f, 0xe5, 0xe5, 0xe2, 0x7c, 0xe8, 0xa7, 0xf1, 0x53, 0x25, 0xf7,
	0xd4, 0xcb, 0xc2, 0xa7, 0xaf, 0x62, 0x2e, 0xcf, 0xd7, 0x49, 0xe4, 0xb3, 0xff, 0x0b, 0x00, 0x00,
	0xff, 0xff, 0x38, 0x1d, 0xb2, 0xb1, 0x61, 0x2e, 0x00, 0x00,
}
